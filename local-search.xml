<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Async注解 导致该Bean在循环依赖时启动报错</title>
    <link href="/2021/05/12/@Async%20%E5%AF%BC%E8%87%B4%E8%AF%A5Bean%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%97%B6%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"/>
    <url>/2021/05/12/@Async%20%E5%AF%BC%E8%87%B4%E8%AF%A5Bean%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%97%B6%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h2 id="Async-导致该Bean在循环依赖时启动报错"><a href="#Async-导致该Bean在循环依赖时启动报错" class="headerlink" title="@Async 导致该Bean在循环依赖时启动报错"></a>@Async 导致该Bean在循环依赖时启动报错</h2><p>最新推荐文章于 2022-09-21 09:50:04 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-09-21 09:50:04 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天在开发代码的时候遇到了一个启动错误，错误内容大致就是：</p><blockquote><p>org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name ‘classA’: Bean with name ‘classA’ has been injected into other beans [classB] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using ‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example</p></blockquote><p>后面经过分析是跟我前面使用@Async注解有关，主要原因就是@Async 导致循环依赖失效，以下是我网上寻找的一些相关资料：</p><p><a href="https://segmentfault.com/a/1190000021217176">https://segmentfault.com/a/1190000021217176</a></p><p><a href="https://cloud.tencent.com/developer/article/1497689">https://cloud.tencent.com/developer/article/1497689</a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codis与RedisCluster的原理详解</title>
    <link href="/2021/03/13/Codis%E4%B8%8ERedisCluster%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/03/13/Codis%E4%B8%8ERedisCluster%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Codis与RedisCluster的原理详解"><a href="#Codis与RedisCluster的原理详解" class="headerlink" title="Codis与RedisCluster的原理详解"></a><a href="https://www.cnblogs.com/pingyeaa/p/11294773.html">Codis与RedisCluster的原理详解</a></h2><p>最近入职新公司，公司使用的是Codis去同步Redis节点间的数据，所以最近去了解一下Codis的相关知识，找到一篇不错的文章，故转载下来</p><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍#"></a>背景介绍<a href="https://www.cnblogs.com/pingyeaa/p/11294773.html#381988702">#</a></h3><p>我们先来看一下为什么要做集群，如果我们要部署一个单节点Redis，很明显会遇到单点故障的问题。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141103915-106719622.png"><img src="https://img-blog.csdnimg.cn/img_convert/b6db2d7c186516e1ee572d2f553df61b.png"></a></p><p>首先能想到解决单点故障的方法，就是做主从，但是当有海量存储需求时，单一的主从结构就会出问题，说问题之前要先了解一下主从之间是如何复制的。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141411608-792399561.png"><img src="https://img-blog.csdnimg.cn/img_convert/8db81742befce4fb90c531d2c3375c78.png"></a></p><p>我们把Redis分为三个部分，分别是客户端、主节点以及从节点，如果从节点要同步主节点的数据，它首先会发Sync指令给主节点，主节点收到指令之后会执行BGSAVE命令生成RDB文件，这个RDB文件指的是快照文件，它是Redis两种备份方式的其中一种，另一种叫AOF，它的原理是将所有的写入指令存入文件，mysql的binlog原理是一样的。</p><p>如果主节点在生成RDB的过程当中，客户端发来了写入指令，这个时候主节点会把指令全部写入缓冲区，等RDB生成完了，会把RDB文件发送给从节点，最后再把缓冲区的指令发送给从节点。这样就完成了整个的复制。</p><p>我们刚才说单纯地做主从是有缺陷的，这个缺陷就是如果我们要存储海量的数据，那么BGSAVE指令生成的RDB文件会非常巨大，这个文件传送给从节点也会非常慢，如果缓冲区命令很多的话，从节点同步数据时也会执行很久，所以，要解决单点问题和海量存储问题，还是要考虑做集群。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141301491-828982558.png"><img src="https://img-blog.csdnimg.cn/img_convert/fa9320154f5b3f82293dec53903e47d6.png"></a></p><h3 id="Redis常见集群方案"><a href="#Redis常见集群方案" class="headerlink" title="Redis常见集群方案#"></a>Redis常见集群方案<a href="https://www.cnblogs.com/pingyeaa/p/11294773.html#3388209721">#</a></h3><p>Redis集群方案目前主流的有三种，分别是Twemproxy、Codis和Redis Cluster。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141518199-781410417.png"><img src="https://img-blog.csdnimg.cn/img_convert/cb3bcdb745da8bd59f9d3aa1050c4b93.png"></a></p><p>Twemproxy，是推特开源的，它最大的缺点就是无法平滑的扩缩容，而Codis解决了Twemproxy扩缩容的问题，而且兼容了Twemproxy，它是由豌豆荚开源的，和Twemproxy都是代理模式。其实Codis能发展起来的一个主要原因是它是在Redis官方集群方案漏洞百出的时候率先成熟稳定的。以现在的Redis官方集群方案，这两个好像没有太大差别了，不过我也没有去做性能测试，不清楚哪个最好。</p><p>Redis Cluster是由官方出品的，用去中心化的方式实现，不属于代理模式，今天主要讲codis，redis cluster后面也会过一下。下面，来看一下Codis的实现原理。</p><h3 id="Codis原理"><a href="#Codis原理" class="headerlink" title="Codis原理#"></a>Codis原理<a href="https://www.cnblogs.com/pingyeaa/p/11294773.html#3237315914">#</a></h3><p>我们换一种方式去讲，就按照Codis的架构演进一下，这样理解会比较清晰一点，假如现在只有一个Redis Server，怎么让它变得高可用？</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141623637-1144964117.png"><img src="https://img-blog.csdnimg.cn/img_convert/d51b5e57179e78e09b633aeb88a35ea5.png"></a></p><p>开篇的时候也有讲，首先，能想到的就是做主从，这样就算主宕机了，从节点也能马上接替主节点的位置。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141735392-1050303803.png"><img src="https://img-blog.csdnimg.cn/img_convert/8b06d4f3cc1e17fcc98109b8944ab0d7.png"></a></p><p>我们现在已经做成主从结构了，那到底是谁来负责主从之间的切换？</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141802667-83409709.png"><img src="https://img-blog.csdnimg.cn/img_convert/b45cb95f1c8f6bc4b3fe9b9fc944fd61.png"></a></p><p>就是它，Sentinel，中文名叫哨兵，它呢，在Redis里面主要负责监控主从节点，如果主节点挂了，就会把从拉起来。但是哨兵本身也存在单点问题，所以它也需要做集群。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141826584-1854393400.png"><img src="https://img-blog.csdnimg.cn/img_convert/a31709270623f45d43669ac24e073fe0.png"></a></p><p>那么问题来了，哨兵是如何做主从切换呢？来看下哨兵的运行机制。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141909126-1869770004.png"><img src="https://img-blog.csdnimg.cn/img_convert/d4e170ac091f1784f0a8e3e6482be2d6.png"></a></p><p>假如有三个哨兵和一主两从的节点，下面是一主多从，哨兵之间会互相监测运行状态，并且会交换一下节点监测的状态，同时哨兵也会监测主从节点的状态。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803141937106-298777220.png"><img src="https://img-blog.csdnimg.cn/img_convert/7a7908b6ec4ab2b779920cc85ce36a57.png"></a></p><p>如果检测到某一个节点没有正常回复，并且距离上次正常回复的时间超过了某个阈值，那么就认为该节点为主观下线。</p><p>这个时候其他哨兵也会来监测该节点是不是真的主观下线，如果有足够多数量的哨兵都认为它确实主观下线了，那么它就会被标记为客观下线，这个时候哨兵会找下线节点的从节点，然后与其他哨兵协商出一个从节点做主节点，并将剩余的从节点指向新的主节点。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142023904-1656961626.png"><img src="https://img-blog.csdnimg.cn/img_convert/7073627e3030fc933542ccd818e123c0.png"></a></p><p>关于主从节点的切换有两个环节，第一个是哨兵要选举出领头人来负责下线机器的故障转移，第二是从Slave中选出主节点，领头人的选举规则是谁发现客观下线谁就可以马上要求其他哨兵认自己做老大，其他哨兵会无条件接受第一个发过来的人，并告知老大，如果超过一半人都同意了，那他老大的位置就坐实了。</p><p>关于从节点选举，一共有四个因素影响选举的结果，分别是断开连接时长、优先级排序、复制数量、进程id，如果连接断开的比较久，超过了某个阈值，就直接失去了选举权，如果拥有选举权，那就看谁的优先级高，这个在配置文件里可以设置，数值越小优先级越高，如果优先级相同，就看谁从master中复制的数据最多，选最多的那个，如果复制数量也相同，就选择进程id最小的那个。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142133873-2076188484.png"><img src="https://img-blog.csdnimg.cn/img_convert/342288e247a5c1c1ec0e0648b56e4b1f.png"></a></p><p>现在继续回过来，刚才讲痛点的时候说了，如果有存储海量数据的需求，同步会非常缓慢，所以我们应该把一个主从结构变成多个，把存储的key分摊到各个主从结构中来分担压力。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142157383-1209357826.png"><img src="https://img-blog.csdnimg.cn/img_convert/613a9fb4039d4c9108460c36cd566396.png"></a></p><p>就像这样，代理通过一种算法把要操作的key经过计算后分配到各个组中，这个过程叫做分片，我们来看一下分片的实现原理。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142215915-1873691463.png"><img src="https://img-blog.csdnimg.cn/img_convert/990c09e16ba4cd360b775dbd24bea91c.png"></a></p><h4 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法#"></a>分片算法<a href="https://www.cnblogs.com/pingyeaa/p/11294773.html#3119962178">#</a></h4><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142316372-1255776349.png"><img src="https://img-blog.csdnimg.cn/img_convert/951d430eb1c33b74ba99018cc67655b0.png"></a></p><p>在Codis里面，它把所有的key分为1024个槽，每一个槽位都对应了一个分组，具体槽位的分配，可以进行自定义，现在如果有一个key进来，首先要根据CRC32算法，针对key算出32位的哈希值，然后除以1024取余，然后就能算出这个KEY属于哪个槽，然后根据槽与分组的映射关系，就能去对应的分组当中处理数据了。</p><p>CRC全称是循环冗余校验，主要在数据存储和通信领域保证数据正确性的校验手段，我去看了这个算法的原理，还没理解透彻，这里就先不讲了，省得误导大家。</p><p>我们继续回过来，刚才所讲的槽位和分组的映射关系就保存在codis proxy当中，但是codis proxy它本身也存在单点问题，所以需要对proxy做一个集群。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142412234-301773304.png"><img src="https://img-blog.csdnimg.cn/img_convert/cf68d0878e02b2cdd1a5b45734adad5e.png"></a></p><p>部署好集群之后，有一个问题，就是槽位的映射关系是保存在proxy里面的，不同proxy之间怎么同步映射关系？</p><p>在Codis中使用的是Zookeeper来保存映射关系，由proxy上来同步配置信息，其实它支持的不止zookeeper，还有etcd和本地文件。在zookeeper中保存的数据格式就是这个样子。除了这个还会存储一些其他的信息，比如分组信息、代理信息等，感兴趣可以自己去了解一下。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142440305-245260215.png"><img src="https://img-blog.csdnimg.cn/img_convert/69ecf12069f8cee35ccbaade6d0dd0e0.png"></a></p><p>现在还有一个问题，就是codis proxy如果出现异常怎么处理，这个可能要利用一下k8s中pod的特性，在k8s里面可以设置pod冗余的数量，k8s会严格保证启动的数量与设置一致，所以只需要一个进程监测Proxy的异常，并且把它干掉就可以了，k8s会自动拉起来一个新的proxy。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142517608-1773814847.png"><img src="https://img-blog.csdnimg.cn/img_convert/ba36eab6d57b2587355c222bec1fd128.png"></a></p><p>codis给这个进程起名叫codis-ha，codis-ha实时监测proxy的运行状态，如果有异常就会干掉，它包含了哨兵的功能，所以豌豆荚直接把哨兵去掉了。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142546334-1563551816.png"><img src="https://img-blog.csdnimg.cn/img_convert/0b2c5c1112b25e0273d417c4f3ce1f3a.png"></a></p><p>但是codis-ha在Codis整个架构中是没有办法直接操作代理和服务，因为所有的代理和服务的操作都要经过dashboard处理。所以部署的时候会利用k8s的亲和性将codis-ha与dashboard部署在同一个节点上。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142613948-1526515846.png"><img src="https://img-blog.csdnimg.cn/img_convert/ac12eb13e37f6278dd99e8f72aa714a0.png"></a></p><p>除了这些，codis自己开发了集群管理界面，集群管理可以通过界面化的方式更方便的管理集群，这个模块叫codis-fe，我们可以看一下这个界面。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142713278-1555622317.png"><img src="https://img-blog.csdnimg.cn/img_convert/5427c8fa82932768fcc479eb21d6c269.png"></a></p><p>最后就是redis客户端了，这个没什么好讲的，客户端是直接通过代理来访问后端服务的。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142738274-34924996.png"><img src="https://img-blog.csdnimg.cn/img_convert/95a8c93bdb5532713108ab80c2b56477.png"></a></p><h3 id="Redis-Cluster原理"><a href="#Redis-Cluster原理" class="headerlink" title="Redis Cluster原理#"></a>Redis Cluster原理<a href="https://www.cnblogs.com/pingyeaa/p/11294773.html#2060064721">#</a></h3><p>下面来看一下redis cluster的原理，它和codis不太一样，Codis它是通过代理分片的，但是Redis Cluster是去中心化的没有代理，所以只能通过客户端分片，它分片的槽数跟Codis不太一样，Codis是1024个，而Redis cluster有16384个，槽跟节点的映射关系保存在每个节点上，每个节点每秒钟会ping十次其他几个最久没通信的节点，其他节点也是一样的原理互相PING ，PING的时候一个是判断其他节点有没有问题，另一个是顺便交换一下当前集群的节点信息、包括槽与节点映射的关系等。客户端操作key的时候先通过分片算法算出所属的槽，然后随机找一个服务端请求。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142840591-167003063.png"><img src="https://img-blog.csdnimg.cn/img_convert/7e1bc48c8a96881ab6d515d9adec1afd.png"></a></p><p>但是可能这个槽并不归随机找的这个节点管，节点如果发现不归自己管，就会返回一个MOVED ERROR通知，引导客户端去正确的节点访问，这个时候客户端就会去正确的节点操作数据。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142931535-1671539941.png"><img src="https://img-blog.csdnimg.cn/img_convert/6b34dd05b2a7fb8d2c4e15908266472d.png"></a></p><p>这是RedisCluster大概的原理，下面看一下Codis跟RedisCluster简要的区别。</p><p><a href="https://img2018.cnblogs.com/blog/1471773/201908/1471773-20190803142957436-474723415.png"><img src="https://img-blog.csdnimg.cn/img_convert/b6a006f88dcef7f2cf1b07f9405f58cd.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 循环依赖和三级缓存</title>
    <link href="/2021/01/19/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <url>/2021/01/19/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>前言</p><p>Spring中的循环依赖一直是Spring中一个很重要的话题，一方面是因为源码中为了解决循环依赖做了很多处理，另外一方面是因为面试的时候，如果问到Spring中比较高阶的问题，那么循环依赖必定逃不掉。如果你回答得好，那么这就是你的必杀技，反正，那就是面试官的必杀技，这也是取这个标题的原因，当然，本文的目的是为了让你在之后的所有面试中能多一个必杀技，专门用来绝杀面试官！</p><p>本文的核心思想就是，</p><p>当面试官问：</p><p>“请讲一讲Spring中的循环依赖。”的时候，</p><p>我们到底该怎么回答？</p><p>主要分下面几点</p><h3 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h3><p>什么情况下循环依赖可以被处理？</p><p>Spring是如何解决的循环依赖？</p><p>同时本文希望纠正几个目前业界内经常出现的几个关于循环依赖的错误的说法</p><p>只有在setter方式注入的情况下，循环依赖才能解决（错）</p><p>三级缓存的目的是为了提高效率（错）</p><p>OK，铺垫已经做完了，接下来我们开始正文</p><p>什么是循环依赖？</p><p>从字面上来理解就是A依赖B的同时B也依赖了A，就像下面这样</p><p><img src="https://img-blog.csdnimg.cn/img_convert/49462131406f26c9ee2f631344847803.png"></p><p>体现到代码层次就是这个样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class A &#123;<br>    // A中注入了B<br>    @Autowired<br>    private B b;<br>&#125;<br><br>@Component<br>public class B &#123;<br>    // B中也注入了A<br>    @Autowired<br>    private A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这是最常见的一种循环依赖，比较特殊的还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">// 自己依赖自己<br>@Component<br>public class A &#123;<br>    // A中注入了A<br>    @Autowired<br>    private A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然体现形式不一样，但是实际上都是同一个问题—–&gt;循环依赖</p><h3 id="什么情况下循环依赖可以被处理？"><a href="#什么情况下循环依赖可以被处理？" class="headerlink" title="什么情况下循环依赖可以被处理？"></a>什么情况下循环依赖可以被处理？</h3><p>在回答这个问题之前首先要明确一点，Spring解决循环依赖是有前置条件的</p><p>出现循环依赖的Bean必须要是单例</p><p>依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）</p><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class A &#123;<br>//    @Autowired<br>//    private B b;<br>    public A(B b) &#123;<br><br>    &#125;<br>&#125;<br><br><br>@Component<br>public class B &#123;<br><br>//    @Autowired<br>//    private A a;<br><br>    public B(A a)&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决，如果你的项目中有两个这样相互依赖的Bean，在启动时就会报出以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#x27;a&#x27;: Requested bean is currently in creation: Is there an unresolvable circular reference?<br></code></pre></td></tr></table></figure><p>为了测试循环依赖的解决情况跟注入方式的关系，我们做如下四种情况的测试：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/670ce918ea6d1da0797b73bff859a782.png"></p><p>具体的测试代码跟简单，我就不放了。从上面的测试结果我们可以看到，不是只有在setter方法注入的情况下循环依赖才能被解决，即使存在构造器注入的场景下，循环依赖依然被可以被正常处理掉。</p><p>那么到底是为什么呢？Spring到底是怎么处理的循环依赖呢？不要急，我们接着往下看</p><h3 id="Spring是如何解决的循环依赖？"><a href="#Spring是如何解决的循环依赖？" class="headerlink" title="Spring是如何解决的循环依赖？"></a>Spring是如何解决的循环依赖？</h3><p>关于循环依赖的解决方式应该要分两种情况来讨论</p><p>简单的循环依赖（没有AOP）</p><p>结合了AOP的循环依赖</p><p>简单的循环依赖（没有AOP）</p><p>我们先来分析一个最简单的例子，就是上面提到的那个demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class A &#123;<br>    // A中注入了B<br>    @Autowired<br>    private B b;<br>&#125;<br><br>@Component<br>public class B &#123;<br>    // B中也注入了A<br>    @Autowired<br>    private A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上文我们已经知道了这种情况下的循环依赖是能够被解决的，那么具体的流程是什么呢？我们一步步分析</p><p>首先，我们要知道Spring在创建Bean的时候默认是按照自然排序来进行创建的，所以第一步Spring会去创建A。</p><p>与此同时，我们应该知道，Spring在创建Bean的过程中分为三步</p><p>实例化，对应方法：AbstractAutowireCapableBeanFactory中的createBeanInstance方法</p><p>属性注入，对应方法：AbstractAutowireCapableBeanFactory的populateBean方法</p><p>初始化，对应方法：AbstractAutowireCapableBeanFactory的initializeBean</p><p>这些方法在之前源码分析的文章中都做过详细的解读了，如果你之前没看过我的文章，那么你只需要知道</p><p>实例化，简单理解就是new了一个对象</p><p>属性注入，为实例化中new出来的对象填充属性</p><p>初始化，执行aware接口中的方法，初始化方法，完成AOP代理</p><p>基于上面的知识，我们开始解读整个循环依赖处理的过程，整个流程应该是以A的创建为起点，前文也说了，第一步就是创建A嘛！</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b37eeaa5a8bb088c02c50aec435e8791.png"></p><p>创建A的过程实际上就是调用getBean方法，这个方法有两层含义</p><p>创建一个新的Bean</p><p>从缓存中获取到已经被创建的对象</p><p>我们现在分析的是第一层含义，因为这个时候缓存中还没有A嘛！</p><h3 id="调用getSingleton-beanName"><a href="#调用getSingleton-beanName" class="headerlink" title="调用getSingleton(beanName)"></a>调用getSingleton(beanName)</h3><p>首先调用getSingleton(a)方法，这个方法又会调用getSingleton(beanName, true)，在上图中我省略了这一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">public Object getSingleton(String beanName) &#123;<br>    return getSingleton(beanName, true);<br>&#125;<br></code></pre></td></tr></table></figure><p>getSingleton(beanName, true)这个方法实际上就是到缓存中尝试去获取Bean，整个缓存分为三级</p><p>singletonObjects，一级缓存，存储的是所有创建好了的单例Bean</p><p>earlySingletonObjects，完成实例化，但是还未进行属性注入及初始化的对象</p><p>singletonFactories，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象</p><p>因为A是第一次被创建，所以不管哪个缓存中必然都是没有的，因此会进入getSingleton的另外一个重载方法getSingleton(beanName, singletonFactory)。</p><h3 id="调用getSingleton-beanName-singletonFactory"><a href="#调用getSingleton-beanName-singletonFactory" class="headerlink" title="调用getSingleton(beanName, singletonFactory)"></a>调用getSingleton(beanName, singletonFactory)</h3><p>这个方法就是用来创建Bean的，其源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs auto">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;<br>    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);<br>    synchronized (this.singletonObjects) &#123;<br>        Object singletonObject = this.singletonObjects.get(beanName);<br>        if (singletonObject == null) &#123;<br><br>            // ....<br>            // 省略异常处理及日志<br>            // ....<br><br>            // 在单例对象创建前先做一个标记<br>            // 将beanName放入到singletonsCurrentlyInCreation这个集合中<br>            // 标志着这个单例Bean正在创建<br>            // 如果同一个单例Bean多次被创建，这里会抛出异常<br>            beforeSingletonCreation(beanName);<br>            boolean newSingleton = false;<br>            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);<br>            if (recordSuppressedExceptions) &#123;<br>                this.suppressedExceptions = new LinkedHashSet&lt;&gt;();<br>            &#125;<br>            try &#123;<br>                // 上游传入的lambda在这里会被执行，调用createBean方法创建一个Bean后返回<br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = true;<br>            &#125;<br>            // ...<br>            // 省略catch异常处理<br>            // ...<br>            finally &#123;<br>                if (recordSuppressedExceptions) &#123;<br>                    this.suppressedExceptions = null;<br>                &#125;<br>                // 创建完成后将对应的beanName从singletonsCurrentlyInCreation移除<br>                afterSingletonCreation(beanName);<br>            &#125;<br>            if (newSingleton) &#123;<br>                // 添加到一级缓存singletonObjects中<br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>        &#125;<br>        return singletonObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码我们主要抓住一点，通过createBean方法返回的Bean最终被放到了一级缓存，也就是单例池中。</p><p>那么到这里我们可以得出一个结论：一级缓存中存储的是已经完全创建好了的单例Bean</p><h3 id="调用addSingletonFactory方法"><a href="#调用addSingletonFactory方法" class="headerlink" title="调用addSingletonFactory方法"></a>调用addSingletonFactory方法</h3><p>如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fefaade085b561704af220ceef300b53.png"></p><p>在完成Bean的实例化后，属性注入之前Spring将Bean包装成一个工厂添加进了三级缓存中，对应源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">// 这里传入的参数也是一个lambda表达式，() -&gt; getEarlyBeanReference(beanName, mbd, bean)<br>protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;<br>    Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);<br>    synchronized (this.singletonObjects) &#123;<br>        if (!this.singletonObjects.containsKey(beanName)) &#123;<br>            // 添加到三级缓存中<br>            this.singletonFactories.put(beanName, singletonFactory);<br>            this.earlySingletonObjects.remove(beanName);<br>            this.registeredSingletons.add(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只是添加了一个工厂，通过这个工厂（ObjectFactory）的getObject方法可以得到一个对象，而这个对象实际上就是通过getEarlyBeanReference这个方法创建的。那么，什么时候会去调用这个工厂的getObject方法呢？这个时候就要到创建B的流程了。</p><p>当A完成了实例化并添加进了三级缓存后，就要开始为A进行属性注入了，在注入时发现A依赖了B，那么这个时候Spring又会去getBean(b)，然后反射调用setter方法完成属性注入。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b7e6c73f67c84e50c11bbadfd806f5de.png"></p><p>因为B需要注入A，所以在创建B的时候，又会去调用getBean(a)，这个时候就又回到之前的流程了，但是不同的是，之前的getBean是为了创建Bean，而此时再调用getBean不是为了创建了，而是要从缓存中获取，因为之前A在实例化后已经将其放入了三级缓存singletonFactories中，所以此时getBean(a)的流程就是这样子了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f5d078f0b1c26589d9ae5be4cf883402.png"></p><p>从这里我们可以看出，注入到B中的A是通过getEarlyBeanReference方法提前暴露出去的一个对象，还不是一个完整的Bean，那么getEarlyBeanReference到底干了啥了，我们看下它的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;<br>    Object exposedObject = bean;<br>    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;<br>                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>它实际上就是调用了后置处理器的getEarlyBeanReference，而真正实现了这个方法的后置处理器只有一个，就是通过@EnableAspectJAutoProxy注解导入的AnnotationAwareAspectJAutoProxyCreator。也就是说如果在不考虑AOP的情况下，上面的代码等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;<br>    Object exposedObject = bean;<br>    return exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说这个工厂啥都没干，直接将实例化阶段创建的对象返回了！所以说在不考虑AOP的情况下三级缓存有用嘛？讲道理，真的没什么用，我直接将这个对象放到二级缓存中不是一点问题都没有吗？如果你说它提高了效率，那你告诉我提高的效率在哪?</p><p>那么三级缓存到底有什么作用呢？不要急，我们先把整个流程走完，在下文结合AOP分析循环依赖的时候你就能体会到三级缓存的作用！</p><p>到这里不知道小伙伴们会不会有疑问，B中提前注入了一个没有经过初始化的A类型对象不会有问题吗？</p><p>答：不会</p><p>这个时候我们需要将整个创建A这个Bean的流程走完，如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/49ed72a2793cccdb3800e41075228daf.png"></p><p>从上图中我们可以看到，虽然在创建B时会提前给B注入了一个还未初始化的A对象，但是在创建A的流程中一直使用的是注入到B中的A对象的引用，之后会根据这个引用对A进行初始化，所以这是没有问题的。</p><h3 id="结合了AOP的循环依赖"><a href="#结合了AOP的循环依赖" class="headerlink" title="结合了AOP的循环依赖"></a>结合了AOP的循环依赖</h3><p>之前我们已经说过了，在普通的循环依赖的情况下，三级缓存没有任何作用。三级缓存实际上跟Spring中的AOP相关，我们再来看一看getEarlyBeanReference的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;<br>    Object exposedObject = bean;<br>    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;<br>                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在开启AOP的情况下，那么就是调用到AnnotationAwareAspectJAutoProxyCreator的getEarlyBeanReference方法，对应的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs auto">public Object getEarlyBeanReference(Object bean, String beanName) &#123;<br>    Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>    this.earlyProxyReferences.put(cacheKey, bean);<br>    // 如果需要代理，返回一个代理对象，不需要代理，直接返回当前传入的这个bean对象<br>    return wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>回到上面的例子，我们对A进行了AOP代理的话，那么此时getEarlyBeanReference将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ce0a289060ce766f18710e20eb94ddc6.png"></p><p>看到这个图你可能会产生下面这些疑问</p><p>在给B注入的时候为什么要注入一个代理对象？</p><p>答：当我们对A进行了AOP代理时，说明我们希望从容器中获取到的就是A代理后的对象而不是A本身，因此把A当作依赖进行注入时也要注入它的代理对象</p><p>明明初始化的时候是A对象，那么Spring是在哪里将代理对象放入到容器中的呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/129a11ee7d70690e46c0101341dd08d4.png"></p><p>在完成初始化后，Spring又调用了一次getSingleton方法，这一次传入的参数又不一样了，false可以理解为禁用三级缓存，前面图中已经提到过了，在为B中注入A时已经将三级缓存中的工厂取出，并从工厂中获取到了一个对象放入到了二级缓存中，所以这里的这个getSingleton方法做的时间就是从二级缓存中获取到这个代理后的A对象。exposedObject &#x3D;&#x3D; bean可以认为是必定成立的，除非你非要在初始化阶段的后置处理器中替换掉正常流程中的Bean，例如增加一个后置处理器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class MyPostProcessor implements BeanPostProcessor &#123;<br>    @Override<br>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;<br>        if (beanName.equals(&quot;a&quot;)) &#123;<br>            return new A();<br>        &#125;<br>        return bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，请不要做这种骚操作，徒增烦恼！</p><p>初始化的时候是对A对象本身进行初始化，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</p><p>答：不会，这是因为不管是cglib代理还是jdk动态代理生成的代理类，内部都持有一个目标类的引用，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化</p><p>三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？</p><p>答：这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</p><p>我们思考一种简单的情况，就以单独创建A为例，假设AB之间现在没有依赖关系，但是A被代理了，这个时候当A完成实例化后还是会进入下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs auto">// A是单例的，mbd.isSingleton()条件满足<br>// allowCircularReferences：这个变量代表是否允许循环依赖，默认是开启的，条件也满足<br>// isSingletonCurrentlyInCreation：正在在创建A，也满足<br>// 所以earlySingletonExposure=true<br>boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;<br>                                  isSingletonCurrentlyInCreation(beanName));<br>// 还是会进入到这段代码中<br>if (earlySingletonExposure) &#123;<br>    // 还是会通过三级缓存提前暴露一个工厂对象<br>    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br></code></pre></td></tr></table></figure><p>看到了吧，即使没有循环依赖，也会将其添加到三级缓存中，而且是不得不添加到三级缓存中，因为到目前为止Spring也不能确定这个Bean有没有跟别的Bean出现循环依赖。</p><p>假设我们在这里直接使用二级缓存的话，那么意味着所有的Bean在这一步都要完成AOP代理。这样做有必要吗？</p><p>不仅没有必要，而且违背了Spring在结合AOP跟Bean的生命周期的设计！Spring结合AOP跟Bean的生命周期本身就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来完成的，在这个后置处理的postProcessAfterInitialization方法中对初始化后的Bean完成AOP代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。</p><h3 id="三级缓存真的提高了效率了吗？"><a href="#三级缓存真的提高了效率了吗？" class="headerlink" title="三级缓存真的提高了效率了吗？"></a>三级缓存真的提高了效率了吗？</h3><p>现在我们已经知道了三级缓存的真正作用，但是这个答案可能还无法说服你，所以我们再最后总结分析一波，三级缓存真的提高了效率了吗？分为两点讨论：</p><p>没有进行AOP的Bean间的循环依赖</p><p>从上文分析可以看出，这种情况下三级缓存根本没用！所以不会存在什么提高了效率的说法</p><p>进行了AOP的Bean间的循环依赖</p><p>就以我们上的A、B为例，其中A被AOP代理，我们先分析下使用了三级缓存的情况下，A、B的创建流程</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ea2b630fc6e5055e1e91699e1ba0f389.png"></p><p>假设不使用三级缓存，直接在二级缓存中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/75153d446d1c125a9605aa9c881904b1.png"></p><p>上面两个流程的唯一区别在于为A对象创建代理的时机不同，在使用了三级缓存的情况下为A创建代理的时机是在B中需要注入A的时候，而不使用三级缓存的话在A实例化后就需要马上为A创建代理然后放入到二级缓存中去。对于整个A、B的创建过程而言，消耗的时间是一样的</p><p>综上，不管是哪种情况，三级缓存提高了效率这种说法都是错误的！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试官：”Spring是如何解决的循环依赖？“</p><p>答：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><p>面试官：”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“</p><p>答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p><h3 id="一道思考题"><a href="#一道思考题" class="headerlink" title="一道思考题"></a>一道思考题</h3><p>为什么在下表中的第三种情况的循环依赖能被解决，而第四种情况不能被解决呢？</p><p>提示：Spring在创建Bean时默认会根据自然排序进行创建，所以A会先于B进行创建。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/80dae51e68b503803e4143ec18864c8c.png"></p><p>作者：Java程序猿阿谷<br>链接：<a href="https://zhuanlan.zhihu.com/p/157611040">https://zhuanlan.zhihu.com/p/157611040</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux面试的5个经典问题</title>
    <link href="/2021/01/08/Linux%E9%9D%A2%E8%AF%95%E7%9A%845%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/08/Linux%E9%9D%A2%E8%AF%95%E7%9A%845%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1-CPU负载和CPU利用率的区别是什么？"><a href="#1-CPU负载和CPU利用率的区别是什么？" class="headerlink" title="1.CPU负载和CPU利用率的区别是什么？"></a>1.CPU负载和CPU利用率的区别是什么？</h4><p>首先，我们可以通过<code>uptime</code>，<code>w</code>或者<code>top</code>命令看到CPU的平均负载。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaHZ3UklsSmQ4cFNmU2I2QUF4dzFrVWhGUEo4S2liUmlhNEt4a0hXSHdCUXZUT2todGliMzlLeGZ2Zy82NDA?x-oss-process=image/format,png"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaERZNnlJTkJZaEV5Y3dsWldyOFh4R3FoaWFTNW1velZNVlozeXE0MkgyZEF5WldnUVh4a0ZVcWcvNjQw?x-oss-process=image/format,png"></p><p><strong>Load Average</strong> ：负载的3个数字，比如上图的4.86，5.28，5.00，分别代表系统在过去的1分钟，5分钟，15分钟内的系统平均负载。他代表的是<strong>当前系统正在运行的和处于等待运行的进程数之和</strong>。也指的是处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数。</p><p>如果单核CPU的话，负载达到1就代表CPU已经达到满负荷的状态了，超过1，后面的进行就需要排队等待处理了。</p><p>如果是是多核多CPU的话，假设现在服务器是2个CPU，每个CPU2个核，那么总负载不超过4都没什么问题。</p><p>怎么查看CPU有多少核呢？</p><p>通过命令<code>cat /proc/cpuinfo | grep &quot;model name&quot;</code>查看CPU的情况。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaFN1UGhHR0JNYWg5Rlc5WjZiSTFsenNId0RDSmlhZXBWSWljaWMzSnNENkdYbDI4WkJjSlhSMjJBZy82NDA?x-oss-process=image/format,png"></p><p>通过<code>cat /proc/cpuinfo | grep &quot;cpu cores&quot;</code>查看CPU的核数</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaE9lbUFGWlNJaWFhc2UwYkdUdDRNdDhBWFQ0aEplYzltMjZlUWJ2eHJNNlcxbEkwUWdQQWdsd0EvNjQw?x-oss-process=image/format,png"></p><p><strong>CPU 利用率</strong>：和负载不同，CPU利用率指的是当前<strong>正在运行</strong>的进程实时占用CPU的百分比，它是对一段时间内CPU使用状况的统计。</p><p>我举个栗子????：</p><p>假设你们公司厕所有1个坑位，有一个人占了坑位，这时候负载就是1，如果还有一个人在排队，那么负载就是2。</p><p>如果在1个小时内，A上厕所花了10分钟，B上厕所花了20分钟，剩下30分钟厕所都没人使用，那么这一个小时内利用率就是50%。</p><h4 id="2-那如果CPU负载很高，利用率却很低该怎么办？"><a href="#2-那如果CPU负载很高，利用率却很低该怎么办？" class="headerlink" title="2.那如果CPU负载很高，利用率却很低该怎么办？"></a>2.那如果CPU负载很高，利用率却很低该怎么办？</h4><p>CPU负载很高，利用率却很低，说明处于等待状态的任务很多，负载越高，代表可能很多僵死的进程。通常这种情况是IO密集型的任务，大量请求在请求相同的IO，导致任务队列堆积。</p><p>同样，可以先通过<code>top</code>命令观察(截图只是示意，不代表真实情况)，假设发现现在确实是高负载低使用率。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaFp0cVdLVlM4aWFkMnJZbzFZajNCWjFwa3NXcGtnZHBpY1ltczI0cURuQkxYRnpKZU9QRlJKaWNpYWcvNjQw?x-oss-process=image/format,png"></p><p>然后，再通过命令<code>ps -axjf</code>查看是否存在状态为<code>D+</code>状态的进程，这个状态指的就是不可中断的睡眠状态的进程。处于这个状态的进程无法终止，也无法自行退出，只能通过恢复其依赖的资源或者重启系统来解决。(对不起，我截不到D+的状态)</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaElNNVA5R1NlRnFRM2NJZ0RpYU5OUE1wYk1VNXdKWFpCdzRmaWFhVDdDR1NwREsxbnR4OU9VWGZnLzY0MA?x-oss-process=image/format,png"></p><h4 id="3-那如果负载很低，利用率却很高呢？"><a href="#3-那如果负载很低，利用率却很高呢？" class="headerlink" title="3.那如果负载很低，利用率却很高呢？"></a>3.那如果负载很低，利用率却很高呢？</h4><p>如果你的公司只有一个厕所，外面没人排队，却有一个人在里面上了大半个小时，这说明什么？</p><p>两种可能：他没带纸，或者一些奇怪的事情发生了？</p><p>这表示CPU的任务并不多，但是任务执行的时间很长，大概率就是你写的代码本身有问题，通常是计算密集型任务，生成了大量耗时短的计算任务。</p><p>怎么排查？直接<code>top</code>命令找到使用率最高的任务，定位到去看看就行了。如果代码没有问题，那么过段时间CPU使用率就会下降的。</p><h4 id="4-那如果CPU使用率达到100-呢？怎么排查？"><a href="#4-那如果CPU使用率达到100-呢？怎么排查？" class="headerlink" title="4.那如果CPU使用率达到100%呢？怎么排查？"></a>4.那如果CPU使用率达到100%呢？怎么排查？</h4><ol><li>通过<code>top</code>找到占用率高的进程。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaHVSc2liVlh4VzlTUmZ5cXBRM0JpYndCUVB0Z3NDQmZEQWFlWGRZY1ZlUVRVanVZWUlvY2RxTWVBLzY0MA?x-oss-process=image/format,png"></p><ol><li>通过<code>top -Hp pid</code>找到占用CPU高的线程ID。这里找到958的线程ID</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaFJzOVpLWDFVQXV1QUJWSGVxV2lhTUpzRE9VakdJalV5SG5KQWJMRWljV2dENGlhV1FZYWlia2xiYWcvNjQw?x-oss-process=image/format,png"></p><ol><li>再把线程ID转化为16进制，<code>printf &quot;0x%x\n&quot; 958</code>，得到线程ID<code>0x3be</code></li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaEtPQ2szcHNqTkg0bE9NeEp3S21QNTAzM0I4aWNwc2h6a1F2ZHpEb3R0YVZoMjhrY1o2ekpseHcvNjQw?x-oss-process=image/format,png"></p><ol><li>通过命令<code>jstack 163 | grep &#39;0x3be&#39; -C5 --color</code> 或者 <code>jstack 163|vim +/0x3be -</code> 找到有问题的代码</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaGdQSzlybVo1bnBMQXRnbUlpYTRUTGpGZEdWclNYQUFaZU1uM201UkU4dEtNTG45V0JuVTlDWncvNjQw?x-oss-process=image/format,png"></p><h4 id="5-说说常见的Linux命令吧？"><a href="#5-说说常见的Linux命令吧？" class="headerlink" title="5.说说常见的Linux命令吧？"></a>5.说说常见的Linux命令吧？</h4><p><strong>常用的文件、目录命令</strong></p><p><code>ls</code>：用户查看目录下的文件，<code>ls -a</code>可以用来查看隐藏文件，<code>ls -l</code>可以用于查看文件的详细信息，包括权限、大小、所有者等信息。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaGliWFhvY0NTQnFpYzc3c2RjU1hCNG9TZGprMEs1VjV6aDVOajFZbkJsajk4OHlOVjI2aGFzb0xBLzY0MA?x-oss-process=image/format,png"></p><p><code>touch</code>：用于创建文件。如果文件不存在，则创建一个新的文件，如果文件已存在，则会修改文件的时间戳。</p><p><code>cat</code>：cat是英文<code>concatenate</code>的缩写，用于查看文件内容。使用<code>cat</code>查看文件的话，不管文件的内容有多少，都会一次性显示，所以他不适合查看太大的文件。</p><p><code>more</code>：more和cat有点区别，more用于分屏显示文件内容。可以用<code>空格键</code>向下翻页，<code>b</code>键向上翻页</p><p><code>less</code>：和more类似，less用于分行显示</p><p><code>tail</code>：可能是平时用的最多的命令了，查看日志文件基本靠他了。一般用户<code>tail -fn 100 xx.log</code>查看最后的100行内容</p><p><strong>常用的权限命令</strong></p><p><code>chmod</code>：修改权限命令。一般用<code>+</code>号添加权限，<code>-</code>号删除权限，<code>x</code>代表执行权限，<code>r</code>代表读取权限，<code>w</code>代表写入权限，常见写法比如<code>chmod +x 文件名</code> 添加执行权限。</p><p>还有另外一种写法，使用数字来授权，因为<code>r</code>=4，<code>w</code>=2，<code>x</code>=1，平时执行命令<code>chmod 777 文件名</code>这就是最高权限了。</p><p>第一个数字7&#x3D;4+2+1代表着所有者的权限，第二个数字7代表所属组的权限，第三个数字代表其他人的权限。</p><p>常见的权限数字还有644，所有者有读写权限，其他人只有只读权限，755代表其他人有只读和执行权限。</p><p><code>chown</code>：用于修改文件和目录的所有者和所属组。一般用法<code>chown user 文件</code>用于修改文件所有者，<code>chown user:user 文件</code>修改文件所有者和组，冒号前面是所有者，后面是组。</p><p><strong>常用的压缩命令</strong></p><p><code>zip</code>：压缩zip文件命令，比如<code>zip test.zip 文件</code>可以把文件压缩成zip文件，如果压缩目录的话则需添加<code>-r</code>选项。</p><p><code>unzip</code>：与zip对应，解压zip文件命令。<code>unzip xxx.zip</code>直接解压，还可以通过<code>-d</code>选项指定解压目录。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9pYkJNVnVEZmtaVW12UEZ2UTN5VkwxdFFZR2liSGljWUNsaHNLekpmZ0VqUHNXMXpxbm50eGQ1NUpyRDZDaWFpYXRmQjZjdXdaSE5BZFp2aWN0NGdoUFJEMnZMQS82NDA?x-oss-process=image/format,png"></p><p><code>gzip</code>：用于压缩.gz后缀文件，gzip命令不能打包目录。需要注意的是直接使用<code>gzip 文件名</code>源文件会消失，如果要保留源文件，可以使用<code>gzip -c 文件名 &gt; xx.gz</code>，解压缩直接使用<code>gzip -d xx.gz</code></p><p><code>tar</code>：tar常用几个选项，<code>-x</code>解打包，<code>-c</code>打包，<code>-f</code>指定压缩包文件名，<code>-v</code>显示打包文件过程，一般常用<code>tar -cvf xx.tar 文件</code>来打包，解压则使用<code>tar -xvf xx.tar</code>。</p><p>Linux的打包和压缩是分开的操作，如果要打包并且压缩的话，按照前面的做法必须先用tar打包，然后再用gzip压缩。当然，还有更好的做法就是<code>-z</code>命令，打包并且压缩。</p><p>使用命令<code>tar -zcvf xx.tar.gz 文件</code>来打包压缩，使用命令<code>tar -zxvf xx.tar.gz</code>来解压缩</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成kafka全面实战</title>
    <link href="/2021/01/05/SpringBoot%E9%9B%86%E6%88%90kafka%E5%85%A8%E9%9D%A2%E5%AE%9E%E6%88%98/"/>
    <url>/2021/01/05/SpringBoot%E9%9B%86%E6%88%90kafka%E5%85%A8%E9%9D%A2%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>一、生产者实践</p><ul><li><p>普通生产者</p></li><li><p>带回调的生产者</p></li><li><p>自定义分区器</p></li><li><p>kafka事务提交</p></li></ul><p>二、消费者实践</p><ul><li><p>简单消费</p></li><li><p>指定topic、partition、offset消费</p></li><li><p>批量消费</p></li><li><p>监听异常处理器</p></li><li><p>消息过滤器</p></li><li><p>消息转发</p></li><li><p>定时启动&#x2F;停止监听器</p></li></ul><h3 id="一、前戏"><a href="#一、前戏" class="headerlink" title="一、前戏"></a>一、前戏</h3><p>1、在项目中连接kafka，因为是外网，首先要开放kafka配置文件中的如下配置（其中IP为公网IP），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">advertised.listeners=PLAINTEXT://112.126.74.249:9092<br></code></pre></td></tr></table></figure><p>2、在开始前我们先创建两个topic：topic1、topic2，其分区和副本数都设置为2，用来测试，</p><ol><li><p><code>[root@iZ2zegzlkedbo3e64vkbefZ ~]# cd /usr/local/kafka-cluster/kafka1/bin/</code></p></li><li><p><code>[root@iZ2zegzlkedbo3e64vkbefZ bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic1</code></p></li><li><p><code>Created topic topic1.</code></p></li><li><p><code>[root@iZ2zegzlkedbo3e64vkbefZ bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic2</code></p></li><li><p><code>Created topic topic2.</code></p></li></ol><p>当然我们也可以不手动创建topic，在执行代码kafkaTemplate.send(“topic1”, normalMessage)发送消息时，kafka会帮我们自动完成topic的创建工作，但这种情况下创建的topic默认只有一个分区，分区也没有副本。所以，我们可以在项目中新建一个配置类专门用来初始化topic，如下，</p><ol><li><p><code>@Configuration</code></p></li><li><p><code>public class KafkaInitialConfiguration &#123;</code></p></li><li><p><code>// 创建一个名为testtopic的Topic并设置分区数为8，分区副本数为2</code></p></li><li><p><code>@Bean</code></p></li><li><p><code>public NewTopic initialTopic() &#123;</code></p></li><li><p><code>return new NewTopic(&quot;testtopic&quot;,8, (short) 2 );</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 如果要修改分区数，只需修改配置值重启项目即可</code></p></li><li><p><code>// 修改分区数并不会导致数据的丢失，但是分区数只能增大不能减小</code></p></li><li><p><code>@Bean</code></p></li><li><p><code>public NewTopic updateTopic() &#123;</code></p></li><li><p><code>return new NewTopic(&quot;testtopic&quot;,10, (short) 2 );</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;</code></p></li></ol><p>3、新建SpringBoot项目</p><p>① 引入pom依赖</p><ol><li><p><code>&lt;dependency&gt;</code></p></li><li><p><code>&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</code></p></li><li><p><code>&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</code></p></li><li><p><code>&lt;/dependency&gt;</code></p></li></ol><p>② application.propertise配置（本文用到的配置项这里全列了出来）</p><ol><li><p><code>###########【Kafka集群】###########</code></p></li><li><p><code>spring.kafka.bootstrap-servers=112.126.74.249:9092,112.126.74.249:9093</code></p></li><li><p><code>###########【初始化生产者配置】###########</code></p></li><li><p><code># 重试次数</code></p></li><li><p><code>spring.kafka.producer.retries=0</code></p></li><li><p><code># 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)</code></p></li><li><p><code>spring.kafka.producer.acks=1</code></p></li><li><p><code># 批量大小</code></p></li><li><p><code>spring.kafka.producer.batch-size=16384</code></p></li><li><p><code># 提交延时</code></p></li><li><p><code>spring.kafka.producer.properties.linger.ms=0</code></p></li><li><p><code># 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka</code></p></li><li><p><code># linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了</code></p></li><li><p><code>​</code></p></li><li><p><code># 生产端缓冲区大小</code></p></li><li><p><code>spring.kafka.producer.buffer-memory = 33554432</code></p></li><li><p><code># Kafka提供的序列化和反序列化类</code></p></li><li><p><code>spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</code></p></li><li><p><code>spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</code></p></li><li><p><code># 自定义分区器</code></p></li><li><p><code># spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner</code></p></li><li><p><code>​</code></p></li><li><p><code>###########【初始化消费者配置】###########</code></p></li><li><p><code># 默认的消费组ID</code></p></li><li><p><code>spring.kafka.consumer.properties.group.id=defaultConsumerGroup</code></p></li><li><p><code># 是否自动提交offset</code></p></li><li><p><code>spring.kafka.consumer.enable-auto-commit=true</code></p></li><li><p><code># 提交offset延时(接收到消息后多久提交offset)</code></p></li><li><p><code>spring.kafka.consumer.auto.commit.interval.ms=1000</code></p></li><li><p><code># 当kafka中没有初始offset或offset超出范围时将自动重置offset</code></p></li><li><p><code># earliest:重置为分区中最小的offset;</code></p></li><li><p><code># latest:重置为分区中最新的offset(消费分区中新产生的数据);</code></p></li><li><p><code># none:只要有一个分区不存在已提交的offset,就抛出异常;</code></p></li><li><p><code>spring.kafka.consumer.auto-offset-reset=latest</code></p></li><li><p><code># 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)</code></p></li><li><p><code>spring.kafka.consumer.properties.session.timeout.ms=120000</code></p></li><li><p><code># 消费请求超时时间</code></p></li><li><p><code>spring.kafka.consumer.properties.request.timeout.ms=180000</code></p></li><li><p><code># Kafka提供的序列化和反序列化类</code></p></li><li><p><code>spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</code></p></li><li><p><code>spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</code></p></li><li><p><code># 消费端监听的topic不存在时，项目启动会报错(关掉)</code></p></li><li><p><code>spring.kafka.listener.missing-topics-fatal=false</code></p></li><li><p><code># 设置批量消费</code></p></li><li><p><code># spring.kafka.listener.type=batch</code></p></li><li><p><code># 批量消费每次最多消费多少条消息</code></p></li><li><p><code># spring.kafka.consumer.max-poll-records=50</code></p></li></ol><h3 id="二、Hello-Kafka"><a href="#二、Hello-Kafka" class="headerlink" title="二、Hello Kafka"></a>二、Hello Kafka</h3><p>1、简单生产者</p><ol><li><p><code>@RestController</code></p></li><li><p><code>public class KafkaProducer &#123;</code></p></li><li><p><code>@Autowired</code></p></li><li><p><code>private KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 发送消息</code></p></li><li><p><code>@GetMapping(&quot;/kafka/normal/&#123;message&#125;&quot;)</code></p></li><li><p><code>public void sendMessage1(@PathVariable(&quot;message&quot;) String normalMessage) &#123;</code></p></li><li><p><code>kafkaTemplate.send(&quot;topic1&quot;, normalMessage);</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;</code></p></li></ol><p> 2、简单消费</p><ol><li><p><code>@Component</code></p></li><li><p><code>public class KafkaConsumer &#123;</code></p></li><li><p><code>// 消费监听</code></p></li><li><p><code>@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;)</code></p></li><li><p><code>public void onMessage1(ConsumerRecord&lt;?, ?&gt; record)&#123;</code></p></li><li><p><code>// 消费的哪个topic、partition的消息,打印出消息内容</code></p></li><li><p><code>System.out.println(&quot;简单消费：&quot;+record.topic()+&quot;-&quot;+record.partition()+&quot;-&quot;+record.value());</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;</code></p></li></ol><p>上面示例创建了一个生产者，发送消息到topic1，消费者监听topic1消费消息。监听器用@KafkaListener注解，topics表示监听的topic，支持同时监听多个，用英文逗号分隔。启动项目，postman调接口触发生产者发送消息，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djNhdVV6azR4U0JPdTZneGljMk1oSzV0bWdSNHd3NWQzUG9EeERCS2tUUGNDQjdwTTJYbzBTdzZRLzY0MA?x-oss-process=image/format,png"></p><p>可以看到监听器消费成功，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djNwc09pYzY3aWNYV2lid0k0a0ptV2VpYURpY01OVTB6QUxyR3dGVWd2aWI2c09pYjRtOU5zRllTeEMxcmdBLzY0MA?x-oss-process=image/format,png"></p><h3 id="三、生产者"><a href="#三、生产者" class="headerlink" title="三、生产者"></a>三、生产者</h3><p>1、带回调的生产者</p><p>kafkaTemplate提供了一个回调方法addCallback，我们可以在回调方法中监控消息是否发送成功 或 失败时做补偿处理，有两种写法，</p><ol><li><p><code>@GetMapping(&quot;/kafka/callbackOne/&#123;message&#125;&quot;)</code></p></li><li><p><code>public void sendMessage2(@PathVariable(&quot;message&quot;) String callbackMessage) &#123;</code></p></li><li><p><code>kafkaTemplate.send(&quot;topic1&quot;, callbackMessage).addCallback(success -&gt; &#123;</code></p></li><li><p><code>// 消息发送到的topic</code></p></li><li><p><code>String topic = success.getRecordMetadata().topic();</code></p></li><li><p><code>// 消息发送到的分区</code></p></li><li><p><code>int partition = success.getRecordMetadata().partition();</code></p></li><li><p><code>// 消息在分区内的offset</code></p></li><li><p><code>long offset = success.getRecordMetadata().offset();</code></p></li><li><p><code>System.out.println(&quot;发送消息成功:&quot; + topic + &quot;-&quot; + partition + &quot;-&quot; + offset);</code></p></li><li><p><code>&#125;, failure -&gt; &#123;</code></p></li><li><p><code>System.out.println(&quot;发送消息失败:&quot; + failure.getMessage());</code></p></li><li><p><code>&#125;);</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>@GetMapping(&quot;/kafka/callbackTwo/&#123;message&#125;&quot;)</code></p></li><li><p><code>public void sendMessage3(@PathVariable(&quot;message&quot;) String callbackMessage) &#123;</code></p></li><li><p><code>kafkaTemplate.send(&quot;topic1&quot;, callbackMessage).addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</code></p></li><li><p><code>@Override</code></p></li><li><p><code>public void onFailure(Throwable ex) &#123;</code></p></li><li><p><code>System.out.println(&quot;发送消息失败：&quot;+ex.getMessage());</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>@Override</code></p></li><li><p><code>public void onSuccess(SendResult&lt;String, Object&gt; result) &#123;</code></p></li><li><p><code>System.out.println(&quot;发送消息成功：&quot; + result.getRecordMetadata().topic() + &quot;-&quot;</code></p></li><li><p><code>+ result.getRecordMetadata().partition() + &quot;-&quot; + result.getRecordMetadata().offset());</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;);</code></p></li><li><p><code>&#125;</code></p></li></ol><p>2、自定义分区器</p><p>我们知道，kafka中每个topic被划分为多个分区，那么生产者将消息发送到topic时，具体追加到哪个分区呢？这就是所谓的分区策略，Kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略。其路由机制为：</p><p>① 若发送消息时指定了分区（即自定义分区策略），则直接将消息append到指定分区；</p><p>② 若发送消息时未指定 patition，但指定了 key（kafka允许为每条消息设置一个key），则对key值进行hash计算，根据计算结果路由到指定分区，这种情况下可以保证同一个 Key 的所有消息都进入到相同的分区；</p><p>③  patition 和 key 都未指定，则使用kafka默认的分区策略，轮询选出一个 patition；</p><p>※ 我们来自定义一个分区策略，将消息发送到我们指定的partition，首先新建一个分区器类实现Partitioner接口，重写方法，其中partition方法的返回值就表示将消息发送到几号分区，</p><ol><li><p><code>public class CustomizePartitioner implements Partitioner &#123;</code></p></li><li><p><code>@Override</code></p></li><li><p><code>public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</code></p></li><li><p><code>// 自定义分区规则(这里假设全部发到0号分区)</code></p></li><li><p><code>// ......</code></p></li><li><p><code>return 0;</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>@Override</code></p></li><li><p><code>public void close() &#123;</code></p></li><li><p><code>​</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>@Override</code></p></li><li><p><code>public void configure(Map&lt;String, ?&gt; configs) &#123;</code></p></li><li><p><code>​</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;</code></p></li></ol><p>在application.propertise中配置自定义分区器，配置的值就是分区器类的全路径名，</p><ol><li><p><code># 自定义分区器</code></p></li><li><p><code>spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner</code></p></li></ol><p>3、kafka事务提交</p><p>如果在发送消息时需要创建事务，可以使用 KafkaTemplate 的 executeInTransaction 方法来声明事务，</p><ol><li><p><code>@GetMapping(&quot;/kafka/transaction&quot;)</code></p></li><li><p><code>public void sendMessage7()&#123;</code></p></li><li><p><code>// 声明事务：后面报错消息不会发出去</code></p></li><li><p><code>kafkaTemplate.executeInTransaction(operations -&gt; &#123;</code></p></li><li><p><code>operations.send(&quot;topic1&quot;,&quot;test executeInTransaction&quot;);</code></p></li><li><p><code>throw new RuntimeException(&quot;fail&quot;);</code></p></li><li><p><code>&#125;);</code></p></li><li><p><code>​</code></p></li><li><p><code>// 不声明事务：后面报错但前面消息已经发送成功了</code></p></li><li><p><code>kafkaTemplate.send(&quot;topic1&quot;,&quot;test executeInTransaction&quot;);</code></p></li><li><p><code>throw new RuntimeException(&quot;fail&quot;);</code></p></li><li><p><code>&#125;</code></p></li></ol><h3 id="四、消费者"><a href="#四、消费者" class="headerlink" title="四、消费者"></a>四、消费者</h3><p>1、指定topic、partition、offset消费</p><p>前面我们在监听消费topic1的时候，监听的是topic1上所有的消息，如果我们想指定topic、指定partition、指定offset来消费呢？也很简单，@KafkaListener注解已全部为我们提供，</p><ol><li><p><code>/**</code></p></li><li><p><code>* @Title 指定topic、partition、offset消费</code></p></li><li><p><code>* @Description 同时监听topic1和topic2，监听topic1的0号分区、topic2的 &quot;0号和1号&quot; 分区，指向1号分区的offset初始值为8</code></p></li><li><p><code>* @Author long.yuan</code></p></li><li><p><code>* @Date 2020/3/22 13:38</code></p></li><li><p><code>* @Param [record]</code></p></li><li><p><code>* @return void</code></p></li><li><p><code>**/</code></p></li><li><p><code>@KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;felix-group&quot;,topicPartitions = &#123;</code></p></li><li><p><code>@TopicPartition(topic = &quot;topic1&quot;, partitions = &#123; &quot;0&quot; &#125;),</code></p></li><li><p><code>@TopicPartition(topic = &quot;topic2&quot;, partitions = &quot;0&quot;, partitionOffsets = @PartitionOffset(partition = &quot;1&quot;, initialOffset = &quot;8&quot;))</code></p></li><li><p><code>&#125;)</code></p></li><li><p><code>public void onMessage2(ConsumerRecord&lt;?, ?&gt; record) &#123;</code></p></li><li><p><code>System.out.println(&quot;topic:&quot;+record.topic()+&quot;|partition:&quot;+record.partition()+&quot;|offset:&quot;+record.offset()+&quot;|value:&quot;+record.value());</code></p></li><li><p><code>&#125;</code></p></li></ol><p>属性解释：</p><p>① id：消费者ID；</p><p>② groupId：消费组ID；</p><p>③ topics：监听的topic，可监听多个；</p><p>④ topicPartitions：可配置更加详细的监听信息，可指定topic、parition、offset监听。</p><p>上面onMessage2监听的含义：监听topic1的0号分区，同时监听topic2的0号分区和topic2的1号分区里面offset从8开始的消息。</p><p>注意：topics和topicPartitions不能同时使用；</p><p>2、批量消费</p><p>设置application.prpertise开启批量消费即可，</p><ol><li><p><code># 设置批量消费</code></p></li><li><p><code>spring.kafka.listener.type=batch</code></p></li><li><p><code># 批量消费每次最多消费多少条消息</code></p></li><li><p><code>spring.kafka.consumer.max-poll-records=50</code></p></li></ol><p>接收消息时用List来接收，监听代码如下，</p><ol><li><p><code>@KafkaListener(id = &quot;consumer2&quot;,groupId = &quot;felix-group&quot;, topics = &quot;topic1&quot;)</code></p></li><li><p><code>public void onMessage3(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) &#123;</code></p></li><li><p><code>System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.size());</code></p></li><li><p><code>for (ConsumerRecord&lt;?, ?&gt; record : records) &#123;</code></p></li><li><p><code>System.out.println(record.value());</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;</code></p></li></ol><p>3、ConsumerAwareListenerErrorHandler 异常处理器</p><p>通过异常处理器，我们可以处理consumer在消费时发生的异常。</p><p>新建一个 ConsumerAwareListenerErrorHandler 类型的异常处理方法，用@Bean注入，BeanName默认就是方法名，然后我们将这个异常处理器的BeanName放到@KafkaListener注解的errorHandler属性里面，当监听抛出异常的时候，则会自动调用异常处理器，</p><ol><li><p><code>// 新建一个异常处理器，用@Bean注入</code></p></li><li><p><code>@Bean</code></p></li><li><p><code>public ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() &#123;</code></p></li><li><p><code>return (message, exception, consumer) -&gt; &#123;</code></p></li><li><p><code>System.out.println(&quot;消费异常：&quot;+message.getPayload());</code></p></li><li><p><code>return null;</code></p></li><li><p><code>&#125;;</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 将这个异常处理器的BeanName放到@KafkaListener注解的errorHandler属性里面</code></p></li><li><p><code>@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;,errorHandler = &quot;consumerAwareErrorHandler&quot;)</code></p></li><li><p><code>public void onMessage4(ConsumerRecord&lt;?, ?&gt; record) throws Exception &#123;</code></p></li><li><p><code>throw new Exception(&quot;简单消费-模拟异常&quot;);</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 批量消费也一样，异常处理器的message.getPayload()也可以拿到各条消息的信息</code></p></li><li><p><code>@KafkaListener(topics = &quot;topic1&quot;,errorHandler=&quot;consumerAwareErrorHandler&quot;)</code></p></li><li><p><code>public void onMessage5(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) throws Exception &#123;</code></p></li><li><p><code>System.out.println(&quot;批量消费一次...&quot;);</code></p></li><li><p><code>throw new Exception(&quot;批量消费-模拟异常&quot;);</code></p></li><li><p><code>&#125;</code></p></li></ol><p>执行看一下效果，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djNzaWJWNFpVUzNZQjJEQkVSc01PM1pZaG9RNjlCQmlidU1scTNpY1QwYm40bm9wNGliWWlhODNXZE9wQS82NDA?x-oss-process=image/format,png"></p><p>4、消息过滤器</p><p>消息过滤器可以在消息抵达consumer之前被拦截，在实际应用中，我们可以根据自己的业务逻辑，筛选出需要的信息再交由KafkaListener处理，不需要的消息则过滤掉。</p><p>配置消息过滤只需要为 监听器工厂 配置一个RecordFilterStrategy（消息过滤策略），返回true的时候消息将会被抛弃，返回false时，消息能正常抵达监听容器。</p><ol><li><p><code>@Component</code></p></li><li><p><code>public class KafkaConsumer &#123;</code></p></li><li><p><code>@Autowired</code></p></li><li><p><code>ConsumerFactory consumerFactory;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 消息过滤器</code></p></li><li><p><code>@Bean</code></p></li><li><p><code>public ConcurrentKafkaListenerContainerFactory filterContainerFactory() &#123;</code></p></li><li><p><code>ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory();</code></p></li><li><p><code>factory.setConsumerFactory(consumerFactory);</code></p></li><li><p><code>// 被过滤的消息将被丢弃</code></p></li><li><p><code>factory.setAckDiscarded(true);</code></p></li><li><p><code>// 消息过滤策略</code></p></li><li><p><code>factory.setRecordFilterStrategy(consumerRecord -&gt; &#123;</code></p></li><li><p><code>if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) &#123;</code></p></li><li><p><code>return false;</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>//返回true消息则被过滤</code></p></li><li><p><code>return true;</code></p></li><li><p><code>&#125;);</code></p></li><li><p><code>return factory;</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 消息过滤监听</code></p></li><li><p><code>@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;,containerFactory = &quot;filterContainerFactory&quot;)</code></p></li><li><p><code>public void onMessage6(ConsumerRecord&lt;?, ?&gt; record) &#123;</code></p></li><li><p><code>System.out.println(record.value());</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;</code></p></li></ol><p>上面实现了一个”过滤奇数、接收偶数”的过滤策略，我们向topic1发送0-99总共100条消息，看一下监听器的消费情况，可以看到监听器只消费了偶数，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djNBV1hkQ1ppYTkzR1VmZjBpYnBUcmJpY0o2cHZhbEFXMUJTdmtkR2FhR0lNWmljaWFpYTdPbXJhZFZxOXcvNjQw?x-oss-process=image/format,png"></p><p>5、消息转发</p><p>在实际开发中，我们可能有这样的需求，应用A从TopicA获取到消息，经过处理后转发到TopicB，再由应用B监听处理消息，即一个应用处理完成后将该消息转发至其他应用，完成消息的转发。</p><p>在SpringBoot集成Kafka实现消息的转发也很简单，只需要通过一个@SendTo注解，被注解方法的return值即转发的消息内容，如下，</p><ol><li><p><code>/**</code></p></li><li><p><code>* @Title 消息转发</code></p></li><li><p><code>* @Description 从topic1接收到的消息经过处理后转发到topic2</code></p></li><li><p><code>* @Author long.yuan</code></p></li><li><p><code>* @Date 2020/3/23 22:15</code></p></li><li><p><code>* @Param [record]</code></p></li><li><p><code>* @return void</code></p></li><li><p><code>**/</code></p></li><li><p><code>@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;)</code></p></li><li><p><code>@SendTo(&quot;topic2&quot;)</code></p></li><li><p><code>public String onMessage7(ConsumerRecord&lt;?, ?&gt; record) &#123;</code></p></li><li><p><code>return record.value()+&quot;-forward message&quot;;</code></p></li><li><p><code>&#125;</code></p></li></ol><p>6、定时启动、停止监听器</p><p>默认情况下，当消费者项目启动的时候，监听器就开始工作，监听消费发送到指定topic的消息，那如果我们不想让监听器立即工作，想让它在我们指定的时间点开始工作，或者在我们指定的时间点停止工作，该怎么处理呢——使用KafkaListenerEndpointRegistry，下面我们就来实现：</p><p>① 禁止监听器自启动；</p><p>② 创建两个定时任务，一个用来在指定时间点启动定时器，另一个在指定时间点停止定时器；</p><p>新建一个定时任务类，用注解@EnableScheduling声明，KafkaListenerEndpointRegistry 在SpringIO中已经被注册为Bean，直接注入，设置禁止KafkaListener自启动，</p><ol><li><p><code>@EnableScheduling</code></p></li><li><p><code>@Component</code></p></li><li><p><code>public class CronTimer &#123;</code></p></li><li><p><code>​</code></p></li><li><p><code>/**</code></p></li><li><p><code>* @KafkaListener注解所标注的方法并不会在IOC容器中被注册为Bean，</code></p></li><li><p><code>* 而是会被注册在KafkaListenerEndpointRegistry中，</code></p></li><li><p><code>* 而KafkaListenerEndpointRegistry在SpringIOC中已经被注册为Bean</code></p></li><li><p><code>**/</code></p></li><li><p><code>@Autowired</code></p></li><li><p><code>private KafkaListenerEndpointRegistry registry;</code></p></li><li><p><code>​</code></p></li><li><p><code>@Autowired</code></p></li><li><p><code>private ConsumerFactory consumerFactory;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 监听器容器工厂(设置禁止KafkaListener自启动)</code></p></li><li><p><code>@Bean</code></p></li><li><p><code>public ConcurrentKafkaListenerContainerFactory delayContainerFactory() &#123;</code></p></li><li><p><code>ConcurrentKafkaListenerContainerFactory container = new ConcurrentKafkaListenerContainerFactory();</code></p></li><li><p><code>container.setConsumerFactory(consumerFactory);</code></p></li><li><p><code>//禁止KafkaListener自启动</code></p></li><li><p><code>container.setAutoStartup(false);</code></p></li><li><p><code>return container;</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 监听器</code></p></li><li><p><code>@KafkaListener(id=&quot;timingConsumer&quot;,topics = &quot;topic1&quot;,containerFactory = &quot;delayContainerFactory&quot;)</code></p></li><li><p><code>public void onMessage1(ConsumerRecord&lt;?, ?&gt; record)&#123;</code></p></li><li><p><code>System.out.println(&quot;消费成功：&quot;+record.topic()+&quot;-&quot;+record.partition()+&quot;-&quot;+record.value());</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 定时启动监听器</code></p></li><li><p><code>@Scheduled(cron = &quot;0 42 11 * * ? &quot;)</code></p></li><li><p><code>public void startListener() &#123;</code></p></li><li><p><code>System.out.println(&quot;启动监听器...&quot;);</code></p></li><li><p><code>// &quot;timingConsumer&quot;是@KafkaListener注解后面设置的监听器ID,标识这个监听器</code></p></li><li><p><code>if (!registry.getListenerContainer(&quot;timingConsumer&quot;).isRunning()) &#123;</code></p></li><li><p><code>registry.getListenerContainer(&quot;timingConsumer&quot;).start();</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>//registry.getListenerContainer(&quot;timingConsumer&quot;).resume();</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>​</code></p></li><li><p><code>// 定时停止监听器</code></p></li><li><p><code>@Scheduled(cron = &quot;0 45 11 * * ? &quot;)</code></p></li><li><p><code>public void shutDownListener() &#123;</code></p></li><li><p><code>System.out.println(&quot;关闭监听器...&quot;);</code></p></li><li><p><code>registry.getListenerContainer(&quot;timingConsumer&quot;).pause();</code></p></li><li><p><code>&#125;</code></p></li><li><p><code>&#125;</code></p></li></ol><p>启动项目，触发生产者向topic1发送消息，可以看到consumer没有消费，因为这时监听器还没有开始工作，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djMySE1QbzdtOFlRQzZsVTVwT21mWmNTREtobTR0cUtMVzQzVXNUOTQ2aWM1NXhUQ2VNdlVXbmpnLzY0MA?x-oss-process=image/format,png"></p><p>11:42分监听器启动开始工作，消费消息，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djN1Njg0cXJabkl2aWFWUmZIOU0waWJkUEdLaHJCdW5kV2ljaWJpYW5rbVd1U2lhUzIwWEg3aWJXMWdPSmdRLzY0MA?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djN2dnhZc1lhN2lic2xnbGtaSmE1WWdaMFE1eU8yZ0c5TVhKQlJiSXB5ZUNQeUd2S0tyZXR5NFZBLzY0MA?x-oss-process=image/format,png"></p><p>11：45分监听器停止工作，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy80aWNWdnd0d1ZleUZDTkpkdGhuVFZuYnJwOUxJMXd1djN6QXY5UGRkaWJ6bmczQ3U1QTNDOTVva1dpY2RaZ21tUU0waWFYVGxxeTJaM0Zjd0dsUFk3UGFTWVEvNjQw?x-oss-process=image/format,png"></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒懂 kafka HA（高可用）</title>
    <link href="/2021/01/05/%E7%A7%92%E6%87%82%20kafka%20HA%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <url>/2021/01/05/%E7%A7%92%E6%87%82%20kafka%20HA%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和-kafka-高可用相关的一些策略。"><a href="#我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和-kafka-高可用相关的一些策略。" class="headerlink" title="我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和 kafka 高可用相关的一些策略。"></a>我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和 kafka 高可用相关的一些策略。</h3><p>01</p><p>名词解释</p><p>要想说明白kafka的HA机制，我们必须先搞明白几个缩写名词，</p><p><strong>1、AR、ISR、OSR</strong></p><p>AR：Assigned Replicas，某分区的所有副本（这里所说的副本包括leader和follower）统称为 AR。</p><p>ISR：In Sync Replicas，所有与leader副本保持”一定程度同步”的副本（包括leader副本在内）组成 ISR 。生产者发送消息时，只有leader与客户端发生交互，follower只是同步备份leader的数据，以保障高可用，所以生产者的消息会先发送到leader，然后follower才能从leader中拉取消息进行同步，同步期间，follower的数据相对leader而言会有一定程度的滞后，前面所说的”一定程度同步”就是指可忍受的滞后范围，这个范围可以通过server.properties中的参数进行配置。</p><p>OSR ：Out-of-Sync Replied，在上面的描述中，相对leader滞后过多的follower将组成OSR 。</p><p>由此可见，AR &#x3D; ISR + OSR，理想情况下，所有的follower副本都应该与leader 保持一定程度的同步，即AR&#x3D;ISR，OSR集合为空</p><p><strong>2、ISR 的伸缩性</strong></p><p>leader负责跟踪维护 ISR 集合中所有follower副本的滞后状态，当follower副本”落后太多” 或 “follower超过一定时间没有向leader发送同步请求”时，leader副本会把它从 ISR 集合中剔除。如果 OSR 集合中有follower副本”追上”了leader副本，那么leader副本会把它从 OSR 集合转移至 ISR 集合。</p><p>上面描述的”落后太多”是指follower复制的消息落后于leader的条数超过预定值，这个预定值可在server.properties中通过replica.lag.max.messages配置，其默认值是4000。”超过一定时间没有向leader发送同步请求”，这个”一定时间”可以在server.properties中通过replica.lag.time.max.ms来配置，其默认值是10000，默认情况下，当leader发生故障时，只有 ISR 集合中的follower副本才有资格被选举为新的leader，而在 OSR 集合中的副本则没有任何机会（不过这个可以通过配置来改变）。</p><p><strong>3、HW</strong></p><p>HW （High Watermark）俗称高水位，它标识了一个特定的消息偏移量（offset），消费者只能消费HW之前的消息。</p><p>下图表示一个日志文件，这个日志文件中有9条消息，第一条消息的offset为0，最后一条消息的offset为8，虚线表示的offset为9的消息，代表下一条待写入的消息。日志文件的 HW 为6，表示消费者只能拉取offset在 0 到 5 之间的消息，offset为6的消息对消费者而言是不可见的。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a0b27955baa4da021745a5d8120dba3c.png" alt="Image"></p><p><strong>4、LEO</strong></p><p>LEO （Log End Offset），标识当前日志文件中下一条待写入的消息的offset。上图中offset为9的位置即为当前日志文件的 LEO，分区 ISR 集合中的每个副本都会维护自身的 LEO ，而 ISR 集合中最小的 LEO 即为分区的 HW（你品，你细品…），对消费者而言只能消费 HW 之前的消息。</p><p><strong>5、 ISR 集合和 HW、LEO的关系</strong></p><p>producer在发布消息到partition时，只会与该partition的leader发生交互将消息发送给leader，leader会将该消息写入其本地log，每个follower都从leader上pull数据做同步备份，follower在pull到该消息并写入其log后，会向leader发送ack，一旦leader收到了ISR中的所有follower的ack（只关注ISR中的所有follower，不考虑OSR，一定程度上提升了吞吐），该消息就被认为已经commit了，leader将增加HW，然后向producer发送ack。</p><p>也就是说，在ISR中所有的follower还没有完成数据备份之前，leader不会增加HW，也就是这条消息暂时还不能被消费者消费，只有当ISR中所有的follower都备份完成后，leader才会将HW后移。</p><p>ISR集合中LEO最小的副本，即同步数据同步的最慢的一个，这个最慢副本的LEO即leader的HW，消费者只能消费HW之前的消息。</p><p>02</p><p>kafka HA</p><p>Tips：我们说的副本包括leader和follower，都叫副本，不要认为叫副本说的就是follower。</p><p>kafka在0.8以前的版本中是没有分区副本的概念的，一旦某一个broker宕机，这个broker上的所有分区都将不可用。在0.8版本以后，引入了分区副本的概念，同一个partition可以有多个副本，在多个副本中会选出一个做leader，其余的作为follower，只有leader对外提供读写服务，follower只负责从leader上同步拉取数据，已保障高可用。</p><p>1、partition副本的分配策略</p><p>每个topic有多个partition，每个partition有多个副本，这些partition副本分布在不同的broker上，以保障高可用，那么这些partition副本是怎么均匀的分布到集群中的每个broker上的呢？</p><p>※ kafka分配partition副本的算法如下，</p><p>① 将所有的broker（假设总共n个broker）和 待分配的partition排序；</p><p>② 将第i个partition分配到第（i mod n）个broker上；</p><p>③ 第i个partition的第j个副本分配到第（(i+j) mod n）个broker上；</p><p>2、kafka的消息传递备份策略</p><p>生产者将消息发送给分区的leader，leader会将该消息写入其本地log，然后每个follower都会从leader pull数据，follower pull到该消息并将其写入log后，会向leader发送ack，当leader收到了ISR集合中所有follower的ack后，就认为这条消息已经commit了，leader将增加HW并且向生产者返回ack。在整个流程中，follower也可以批量的从leader复制数据，以提升复制性能。</p><p>producer在发送消息的时候，可指定参数acks，表示”在生产者认为发送请求完成之前，有多少分区副本必须接收到数据”，有三个可选值，0、1、all(或-1)，默认为1，</p><ul><li><p>acks&#x3D;0，表示producer只管发，只要发出去就认为发发送请求完成了，不管leader有没有收到，更不管follower有没有备份完成。</p></li><li><p>acks&#x3D;1，表示只要leader收到消息，并将其写入自己log后，就会返回给producer ack，不考虑follower有没有备份完成。</p></li><li><p>acks&#x3D;all(或-1)，表示不仅要leader收到消息写入本地log，还要等所有ISR集合中的follower都备份完成后，producer才认为发送成功。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/420b84aa4e74c2ec169520070903c101.png" alt="Image">实际上，为了提高性能，follower在pull到消息将其保存到内存中而尚未写入磁盘时，就会向leader发送ack，所以也就不能完全保证异常发生后该条消息一定能被Consumer消费。</p><p>3、kafka中的Leader选举</p><p>面试官在考查你kafka知识的时候如果问你：kafka中的选举是怎么回事？而不说具体哪种选举，那这个面试官可能对kafka也是一知半解，这个时候就是”弄死”他的时候了，当然如果你没有一定的知识储备，那么就是你被”弄死”的时候。</p><p>因为kafka中涉及到选举的地方有多处，最常提及的也有：①cotroller选举 、 ②分区leader选举 和 ③consumer group leader的选举。我们在前面说过同一个partition有多个副本，其中一个副本作为leader，其余的作为follower。这里我们再说一个角色：controller！kafka集群中多个broker，有一个会被选举为controller，注意区分两者，一个是broker的leader，我们称为controller，一个是分区副本的leader，我们称为leader。</p><p>① controller的选举【broker的leader】</p><p>controller的选举是通过broker在zookeeper的”&#x2F;controller”节点下创建临时节点来实现的，并在该节点中写入当前broker的信息 {“version”:1,”brokerid”:1,”timestamp”:”1512018424988”} ，利用zookeeper的强一致性特性，一个节点只能被一个客户端创建成功，创建成功的broker即为controller，即”先到先得”。 </p><p>当controller宕机或者和zookeeper失去连接时，zookeeper检测不到心跳，zookeeper上的临时节点会被删除，而其它broker会监听临时节点的变化，当节点被删除时，其它broker会收到通知，重新发起controller选举。</p><p>② leader的选举【分区副本的leader】</p><p>分区leader的选举由 controller 负责管理和实施，当leader发生故障时，controller会将leader的改变直接通过RPC的方式通知需要为此作出响应的broker，需要为此作出响应的broker即该分区的ISR集合中follower所在的broker，kafka在zookeeper中动态维护了一个ISR，只有ISR里的follower才有被选为Leader的可能。</p><p>具体过程是这样的：按照AR集合中副本的顺序 查找到 第一个 存活的、并且属于ISR集合的 副本作为新的leader。一个分区的AR集合在创建分区副本的时候就被指定，只要不发生重分配的情况，AR集合内部副本的顺序是保持不变的，而分区的ISR集合上面说过因为同步滞后等原因可能会改变，所以注意这里是根据AR的顺序而不是ISR的顺序找。</p><p>※ 对于上面描述的过程我们假设一种极端的情况，如果partition的所有副本都不可用时，怎么办？这种情况下kafka提供了两种可行的方案：</p><p>1、选择 ISR中 第一个活过来的副本作为Leader；</p><p>2、选择第一个活过来的副本（不一定是ISR中的）作为Leader；</p><p>这就需要在可用性和数据一致性当中做出选择，如果一定要等待ISR中的副本活过来，那不可用的时间可能会相对较长。选择第一个活过来的副本作为Leader，如果这个副本不在ISR中，那数据的一致性则难以保证。kafka支持用户通过配置选择，以根据业务场景在可用性和数据一致性之间做出权衡。</p><p>③消费组leader的选举</p><p>组协调器会为消费组（consumer group）内的所有消费者选举出一个leader，这个选举的算法也很简单，第一个加入consumer group的consumer即为leader，如果某一时刻leader消费者退出了消费组，那么会重新 随机 选举一个新的leader。</p><p>03</p><p>kafka架构中zookeeper的结构</p><p>1、查看方式</p><p>我们知道，kafka是基于zookeeper协调管理的，那么zookeeper中究竟存储了哪些信息？另外在后面分析 broker宕机 和 controller宕机 时，我们也需要先了解zookeeper的目录结构，所以我们先学习一下怎么查看zookeeper的目录结构？</p><p>① 首先启动zookeeper客户端连接zk服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto"># cd /usr/local/zookeeper-cluster/zk1/bin# ./zkCli.sh<br></code></pre></td></tr></table></figure><p>② 查看zk根节点的子目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">[zk: localhost:2181(CONNECTED) 0] ls /[cluster, controller_epoch, controller, brokers, zookeeper, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]<br></code></pre></td></tr></table></figure><p>③ 可以看到zk根节点下有很多子目录，以brokers为例，查看brokers的层级结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">[zk: localhost:2181(CONNECTED) 1] ls /brokers[ids, topics, seqid][zk: localhost:2181(CONNECTED) 2] ls /brokers/ids[0][zk: localhost:2181(CONNECTED) 3] get /brokers/ids/0&#123;&quot;listener_security_protocol_map&quot;:&#123;&quot;PLAINTEXT&quot;:&quot;PLAINTEXT&quot;&#125;,&quot;endpoints&quot;:[&quot;PLAINTEXT://172.17.80.219:9092&quot;],&quot;jmx_port&quot;:-1,&quot;host&quot;:&quot;172.17.80.219&quot;,&quot;timestamp&quot;:&quot;1584267365984&quot;,&quot;port&quot;:9092,&quot;version&quot;:4&#125;cZxid = 0x300000535ctime = Sun Mar 15 18:16:06 CST 2020mZxid = 0x300000535mtime = Sun Mar 15 18:16:06 CST 2020pZxid = 0x300000535cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x20191d7053f0009dataLength = 196numChildren = 0[zk: localhost:2181(CONNECTED) 4] [zk: localhost:2181(CONNECTED) 4][zk: localhost:2181(CONNECTED) 4][zk: localhost:2181(CONNECTED) 4] ls /brokers/topics[__consumer_offsets, first][zk: localhost:2181(CONNECTED) 5] ls /brokers/topics/first[partitions][zk: localhost:2181(CONNECTED) 6] ls /brokers/topics/first/partitions[0, 1][zk: localhost:2181(CONNECTED) 7] ls /brokers/topics/first/partitions/0[state][zk: localhost:2181(CONNECTED) 8] get /brokers/topics/first/partitions/0/state&#123;&quot;controller_epoch&quot;:21,&quot;leader&quot;:0,&quot;version&quot;:1,&quot;leader_epoch&quot;:8,&quot;isr&quot;:[0]&#125;cZxid = 0x3000003e9ctime = Sun Mar 08 16:24:37 CST 2020mZxid = 0x3000005cbmtime = Sun Mar 15 18:54:09 CST 2020pZxid = 0x3000003e9cversion = 0dataVersion = 10aclVersion = 0ephemeralOwner = 0x0dataLength = 73numChildren = 0[zk: localhost:2181(CONNECTED) 9]<br></code></pre></td></tr></table></figure><p>可以看到，brokers下包括[ids, topics, seqid]，ids里面存储了存活的broker的信息，topics里面存储了kafka集群中topic的信息。同样的方法，可以查看其余节点的结构，这里不再演示。</p><p>2、节点信息（这里只列出和HA相关的部分节点）</p><p>① controller</p><p>controller节点下存放的是kafka集群中controller的信息（controller即kafka集群中所有broker的leader）。</p><p>② controller_epoch</p><p>controller_epoch用于记录controller发生变更的次数（controller宕机后会重新选举controller，这时候controller_epoch的值会+1），即记录当前的控制器是第几代控制器，用于防止broker脑裂。</p><p>③ brokes</p><p>brokers下的ids存储了存活的broker信息，topics存储了kafka集群中topic的信息，其中有一个特殊的topic：_consumer_offsets，新版本的kafka将消费者的offset就存储在__consumer_offsets下。</p><p>04</p><p>broker failover</p><p>我们了解了kafka集群中zookpeeper的结构，本文的主题是kafka的高可用分析，所以我们还是结合zookpper的结构，来分析一下，当kafka集群中的一个broker节点宕机时（非controller节点），会发生什么？</p><p>在讲之前，我们再来回顾一下brokers的结构，</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4405f61410cff44764a91cb77ec2f4d1.png" alt="Image"></p><p>※ 当非controller的broker宕机时，会执行如下操作，</p><p>1、controller会在zookeeper的 “ &#x2F;brokers&#x2F;ids&#x2F;“ 节点注册一个watcher（监视器），当有broker宕机时，zookeeper会触发监视器（fire watch）通知controller。</p><p>2、controller 从 “&#x2F;brokers&#x2F;ids” 节点读取到所有可用的broker。</p><p>3、controller会声明一个set_p集合，该集合包含了宕机broker上所有的partition。</p><p>4、针对set_p中的每一个partition，</p><p>① 从 “&#x2F;state”节点 读取该partition当前的ISR；</p><p>② 决定该partition的新leader：如果该分区的 ISR中有存活的副本，则选择其中一个作为新leader；如果该partition的ISR副本全部挂了，则选择该partition的 AR集合 中任一幸存的副本作为leader；如果该partition的所有副本都挂，则将分区的leader设为-1；</p><p>③ 将新 leader、ISR、controller_epoch 和 leader_epoch 等信息写入 state 节点；</p><p>5、通过RPC向set_p相关的broker发送LeaderAndISR Request命令。</p><p>05</p><p>controller failover</p><p>当 controller 宕机时会触发 controller failover。每个 broker 都会在 zookeeper 的 “&#x2F;controller” 节点注册 watcher（监听器），当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知，每个 broker 都尝试创建新的临时节点，只有一个会创建成功并当选为 controller。</p><p>当新的 controller 当选时，会回调KafkaController的onControllerFailover()方法，在这个方法中完成controller的初始化，controller 在初始化时，首先会利用 ZK 的 watch 机制注册很多不同类型的监听器，主要有以下几种：</p><ul><li><p>监听 &#x2F;admin&#x2F;reassign_partitions 节点，用于分区副本迁移的监听；</p></li><li><p>监听 &#x2F;isr_change_notification 节点，用于 Partition Isr 变动的监听；</p></li><li><p>监听 &#x2F;admin&#x2F;preferred_replica_election 节点，用于 Partition 最优 leader 选举的监听；</p></li><li><p>监听 &#x2F;brokers&#x2F;topics 节点，用于 topic 新建的监听；</p></li><li><p>监听 &#x2F;brokers&#x2F;topics&#x2F;TOPIC_NAME 节点，用于 Topic Partition 扩容的监听；</p></li><li><p>监听 &#x2F;admin&#x2F;delete_topics 节点，用于 topic 删除的监听；</p></li><li><p>监听 &#x2F;brokers&#x2F;ids 节点，用于 Broker 上下线的监听；</p></li></ul><p>除了注册多种监听器外，controller初始化时还做以下操作，</p><ul><li><p>initializeControllerContext()</p><p>初始化controller上下文，设置当前所有broker、topic、partition的leader、ISR等；</p></li><li><p>replicaStateMachine.startup()</p></li><li><p>partitionStateMachine.startup()</p><p>启动状态机；</p></li><li><p>brokerState.newState(RunningAsController)</p><p>将 brokerState 状态设置为 RunningAsController；</p></li><li><p>sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq)</p><p>把partition leadership信息发到所有brokers；</p></li><li><p>autoRebalanceScheduler.startup()</p><p>如果打开了autoLeaderRebalance，则启动”partition-rebalance-thread”线程；</p></li><li><p>deleteTopicManager.start()</p><p>如果delete.topic.enable&#x3D;true，且 &#x2F;admin&#x2F;delete_topics 节点下有值，则删除相应的topic；</p></li></ul><p>最后，把onControllerFailover()方法的源码贴一下，上面说的这些操作就是在这个方法中完成的，感兴趣的可以再去看下kafka源码，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">def onControllerFailover() &#123;    if (isRunning) &#123;        info(&quot;Broker %d starting become controller state transition&quot;.format(config.brokerId))        //read controller epoch from zk        readControllerEpochFromZookeeper()        // increment the controller epoch        incrementControllerEpoch(zkUtils.zkClient)        // before reading source of truth from zookeeper, register the listeners to get broker/topic callbacks        registerReassignedPartitionsListener()        registerIsrChangeNotificationListener()        registerPreferredReplicaElectionListener()        partitionStateMachine.registerListeners()        replicaStateMachine.registerListeners()        initializeControllerContext()        replicaStateMachine.startup()        partitionStateMachine.startup()        // register the partition change listeners for all existing topics on failover        controllerContext.allTopics.foreach(topic =&gt; partitionStateMachine.registerPartitionChangeListener(topic))        info(&quot;Broker %d is ready to serve as the new controller with epoch %d&quot;.format(config.brokerId, epoch))        brokerState.newState(RunningAsController)        maybeTriggerPartitionReassignment()        maybeTriggerPreferredReplicaElection()        /* send partition leadership info to all live brokers */        sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq)        if (config.autoLeaderRebalanceEnable) &#123;            info(&quot;starting the partition rebalance scheduler&quot;)            autoRebalanceScheduler.startup()            autoRebalanceScheduler.schedule(&quot;partition-rebalance-thread&quot;, checkAndTriggerPartitionRebalance,                5, config.leaderImbalanceCheckIntervalSeconds.toLong, TimeUnit.SECONDS)        &#125;        deleteTopicManager.start()    &#125;    else        info(&quot;Controller has been shut down, aborting startup/failover&quot;)&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大白话 kafka 架构原理</title>
    <link href="/2021/01/05/%E5%A4%A7%E7%99%BD%E8%AF%9D%20kafka%20%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <url>/2021/01/05/%E5%A4%A7%E7%99%BD%E8%AF%9D%20kafka%20%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。"><a href="#大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。" class="headerlink" title="大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。"></a>大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。</h3><p>kafka官网：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p><p>01</p><p>PART</p><p>kafka简介</p><p>Kafka最初由Linkedin公司开发，是一个分布式的、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常用于web&#x2F;nginx日志、访问日志、消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p><p>02</p><p>PART</p><p>kafka的特性</p><ul><li><p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒；</p></li><li><p>可扩展性：kafka集群支持热扩展；</p></li><li><p>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止丢失；</p></li><li><p>容错性：允许集群中的节点失败(若分区副本数量为n,则允许n-1个节点失败)；</p></li><li><p>高并发：单机可支持数千个客户端同时读写；</p></li></ul><p>03</p><p>PART</p><p>kafka的应用场景</p><ul><li><p>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口开放给各种消费端，例如hadoop、Hbase、Solr等。</p></li><li><p>消息系统：解耦生产者和消费者、缓存消息等。</p></li><li><p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索记录、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p></li><li><p>运营指标：Kafka也经常用来记录运营监控数据。</p></li><li><p>流式处理</p></li></ul><p>04</p><p>PART</p><p>kafka架构（重头戏!）</p><p>下面是一个kafka的架构图，</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e243ead512ce442d090f6cf29ddd3a4.png" alt="Image"></p><p>整体来看，kafka架构中包含四大组件：生产者、消费者、kafka集群、zookeeper集群。对照上面的结构图，我们先来搞清楚几个很重要的术语，（看图！对照图理解~）</p><p>1、broker</p><p>kafka 集群包含一个或多个服务器，每个服务器节点称为一个broker。</p><p>2、topic</p><p>每条发布到kafka集群的消息都有一个类别，这个类别称为topic，其实就是将消息按照topic来分类，topic就是逻辑上的分类，同一个topic的数据既可以在同一个broker上也可以在不同的broker结点上。</p><p>3、partition</p><p>分区，每个topic被物理划分为一个或多个分区，每个分区在物理上对应一个文件夹，该文件夹里面存储了这个分区的所有消息和索引文件。在创建topic时可指定parition数量，生产者将消息发送到topic时，消息会根据 分区策略 追加到分区文件的末尾，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5a5ecec9dd76ef9560625073e0cb3c8d.png" alt="Image"></p><p>上面提到了分区策略，所谓分区策略就是决定生产者将消息发送到哪个分区的算法。Kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略。kafka允许为每条消息设置一个key，一旦消息被定义了 Key，那么就可以保证同一个 Key 的所有消息都进入到相同的分区，这种策略属于自定义策略的一种，被称作”按消息key保存策略”，或Key-ordering 策略。</p><p>同一主题的多个分区可以部署在多个机器上，以此来实现 kafka 的伸缩性。同一partition中的数据是有序的，但topic下的多个partition之间在消费数据时不能保证有序性，在需要严格保证消息顺序消费的场景下，可以将partition数设为1，但这种做法的缺点是降低了吞吐，一般来说，只需要保证每个分区的有序性，再对消息设置key来保证相同key的消息落入同一分区，就可以满足绝大多数的应用。</p><p>4、offset</p><p>partition中的每条消息都被标记了一个序号，这个序号表示消息在partition中的偏移量，称为offset，每一条消息在partition都有唯一的offset，消息者通过指定offset来指定要消费的消息。</p><p>正常情况下，消费者在消费完一条消息后会递增offset，准备去消费下一条消息，但也可以将offset设成一个较小的值，重新消费一些消费过的消息，可见offset是由consumer控制的，consumer想消费哪一条消息就消费哪一条消息，所以kafka broker是无状态的，它不需要标记哪些消息被消费过。</p><p>5、producer</p><p>生产者，生产者发送消息到指定的topic下，消息再根据分配规则append到某个partition的末尾。</p><p>6、consumer</p><p>消费者，消费者从topic中消费数据。</p><p>7、consumer group</p><p>消费者组，每个consumer属于一个特定的consumer group，可为每个consumer指定consumer group，若不指定则属于默认的group。</p><p>同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。这也是kafka用来实现一个topic消息的广播和单播的手段，如果需要实现广播，一个consumer group内只放一个消费者即可，要实现单播，将所有的消费者放到同一个consumer group即可。</p><p>用consumer group还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</p><p>8、leader</p><p>每个partition有多个副本，其中有且仅有一个作为leader，leader会负责所有的客户端读写操作。</p><p>9、follower</p><p>follower不对外提供服务，只与leader保持数据同步，如果leader失效，则选举一个follower来充当新的leader。当follower与leader挂掉、卡住或者同步太慢，leader会把这个follower从ISR列表中删除，重新创建一个follower。</p><p>10、rebalance</p><p>同一个consumer group下的多个消费者互相协调消费工作，我们这样想，一个topic分为多个分区，一个consumer group里面的所有消费者合作，一起去消费所订阅的某个topic下的所有分区(每个消费者消费部分分区)，kafka会将该topic下的所有分区均匀的分配给consumer group下的每个消费者，如下图，</p><p><img src="https://img-blog.csdnimg.cn/img_convert/924db4e3900f5802bd337b0f9b08327d.png" alt="Image"></p><p>rebalance表示”重平衡”，consumer group内某个消费者挂掉后，其他消费者自动重新分配订阅主题分区的过程，是 Kafka 消费者端实现高可用的重要手段。如下图Consumer Group A中的C2挂掉，C1会接收P1和P2，以达到重新平衡。同样的，当有新消费者加入consumer group，也会触发重平衡操作。</p><p>05</p><p>PART</p><p>对kafka架构的几点解释</p><ul><li><p>一个典型的kafka集群中包含若干producer，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干consumer group，以及一个zookeeper集群。kafka通过zookeeper协调管理kafka集群，选举分区leader，以及在consumer group发生变化时进行rebalance。</p></li><li><p>kafka的topic被划分为一个或多个分区，多个分区可以分布在一个或多个broker节点上，同时为了故障容错，每个分区都会复制多个副本，分别位于不同的broker节点，这些分区副本中（不管是leader还是follower都称为分区副本），一个分区副本会作为leader，其余的分区副本作为follower。其中leader负责所有的客户端读写操作，follower不对外提供服务，仅仅从leader上同步数据，当leader出现故障时，其中的一个follower会顶替成为leader，继续对外提供服务。</p></li><li><p>对于传统的MQ而言，已经被消费的消息会从队列中删除，但在Kafka中被消费的消息也不会立马删除，在kafka的server.propertise配置文件中定义了数据的保存时间，当文件到设定的保存时间时才会删除，</p><p># 数据的保存时间(单位:小时，默认为7天)</p><p>log.retention.hours&#x3D;168</p><p>因为Kafka读取消息的时间复杂度为O(1)，与文件大小无关，所以这里删除过期文件与提高Kafka性能并没有关系，所以选择怎样的删除策略应该考虑磁盘以及具体的需求。</p></li><li><p>点对点模式 VS 发布订阅模式</p><p>传统的消息系统中，有两种主要的消息传递模式：点对点模式、发布订阅模式。</p><p>①点对点模式 </p><p>生产者发送消息到queue中，queue支持存在多个消费者，但是对一个消息而言，只可以被一个消费者消费，并且在点对点模式中，已经消费过的消息会从queue中删除不再存储。</p><p>②发布订阅模式</p><p>生产者将消息发布到topic中，topic可以被多个消费者订阅，且发布到topic的消息会被所有订阅者消费。而kafka就是一种发布订阅模式。</p></li><li><p>消费端 pull 和 push</p><p>① push方式：由消息中间件主动地将消息推送给消费者；</p><p>优点：优点是不需要消费者额外开启线程监控中间件，节省开销。</p><p>缺点：无法适应消费速率不相同的消费者。因为消息的发送速率是broker决定的，而消</p><p>费者的处理速度又不尽相同，所以容易造成部分消费者空闲，部分消费者堆积，造成缓</p><p>冲区溢出。</p><p>② pull方式：由消费者主动向消息中间件拉取消息；</p><p>优点：消费端可以按处理能力进行拉取；</p><p>缺点：消费端需要另开线程监控中间件，有性能开销；</p><p>对于Kafka而言，pull模式更合适。pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式，既可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p></li></ul><p>06</p><p>PART</p><p>kafka和rabbitMQ对比</p><table><tbody><tr><td>&nbsp;</td><td><p>RabbitMQ</p></td><td><p>Kafka</p></td></tr><tr><td><p>开发语言</p></td><td><p>erlang</p></td><td><p>scala，Java</p></td></tr><tr><td><p>架构模型</p></td><td><p>① 遵循AMQP；</p><p>② 生产者、消费者、broker。</p><p>③ broker由exchange、binding、queue组成；</p><p>④ consumer消费位置由broker通过确认机制保存；</p></td><td><p>① 不遵循AMQP；</p><p>② 生产者、消费者、kafka集群、zookeeper集群；</p><p>③ kafka集群由多个broker节点组成，消息按照topic分类，每个topic又划分为多个partition；</p><p>④ broker无状态，offset由消费者指定；</p></td></tr><tr><td><p>可靠性</p></td><td>&nbsp;</td><td><p>RabbitMQ可靠性更好，支持事务，支持消息确认机制</p></td></tr><tr><td><p>高可用</p></td><td><p>采用镜像队列，即主从模式，数据是异步同步的，当消息过来，主从全部写完后，回ack，这样保障了数据的一致性。</p></td><td><p>每个分区都有一个或多个副本，这些副本保存在不同的broker上，其中有且仅有一个分区副本作为leader，其余的作为follower，当leader不可用时，会选举follower作为新leader继续提供服务。</p><p>只有leader提供读写服务，follower从leader同步拉取数据然后备份。</p></td></tr><tr><td><p>吞吐量</p></td><td><p>kafka更高</p></td><td>&nbsp;</td></tr><tr><td><p>是否支持事务</p></td><td><p>支持</p></td><td><p>不支持</p></td></tr><tr><td><p>负载均衡</p></td><td><p>需要外部支持才能实现（如：loadbalancer）</p></td><td><p>kafka利用zk和分区机制实现负载均衡</p></td></tr><tr><td><p>是否支持消费者Push</p></td><td><p>不支持</p></td><td><p>支持</p></td></tr><tr><td><p>是否支持消费者Pull</p></td><td><p>支持</p></td><td><p>支持</p></td></tr><tr><td><p>适用场景</p></td><td><p>kafka的优势主要体现在吞吐量上，它主要用在高吞吐量的场景。比如日志采集。</p></td><td><p>具有较高的严谨性，数据丢失的可能性更小，同时具备较高的实时性，用在对实时性、可靠性要求较高的消息传递上。</p></td></tr></tbody></table><p>07</p><p>PART</p><p>kafka吞吐量为什么这么高</p><p>1、顺序读写磁盘</p><p>Kafka是将消息持久化到本地磁盘中的，一般人会认为磁盘读写性能差，可能会对Kafka性能提出质疑。实际上不管是内存还是磁盘，快或慢的关键在于寻址方式，磁盘分为顺序读写与随机读写，内存一样也分为顺序读写与随机读写。基于磁盘的随机读写确实很慢，但基于磁盘的顺序读写性能却很高，一般而言要高出磁盘的随机读写三个数量级，一些情况下磁盘顺序读写性能甚至要高于内存随机读写，这里贴一张著名学术期刊 ACM Queue 上的一张性能对比图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/47f98458333eaae12442f549893fe730.png" alt="Image"></p><p>2、page cache</p><p>为了优化读写性能，Kafka利用了操作系统本身的Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。这样做是因为，</p><p>&gt; JVM中一切皆对象，对象的存储会带来额外的内存消耗；</p><p>&gt; 使用JVM会受到GC的影响，随着数据的增多，垃圾回收也会变得复杂与缓慢，降低吞吐量；</p><p>另外操作系统本身对page cache做了大量优化，通过操作系统的Page Cache，Kafka的读写操作基本上是基于系统内存的，读写性能也得到了极大的提升。</p><p>3、零拷贝</p><p>零拷贝是指Kafka利用 linux 操作系统的 “zero-copy” 机制在消费端做的优化。首先来看一下消费端在消费数据时，数据从broker磁盘通过网络传输到消费端的整个过程：</p><p>&gt; 操作系统从磁盘读取数据到内核空间（kernel space）的page cache；</p><p>&gt; 应用程序读取page cache的数据到用户空间（user space）的缓冲区；</p><p>&gt; 应用程序将用户空间缓冲区的数据写回内核空间的socket缓冲区（socket buffer）；</p><p>&gt; 操作系统将数据从socket缓冲区复制到硬件（如网卡）缓冲区；</p><p><img src="https://img-blog.csdnimg.cn/img_convert/213fe78a0275018b10c86ea46bbf8b08.png" alt="Image"></p><p>整个过程如上图所示，这个过程包含4次copy操作和2次系统上下文切换，而上下文切换是CPU密集型的工作，数据拷贝是I&#x2F;O密集型的工作，性能其实非常低效。</p><p>零拷贝就是使用了一个名为sendfile()的系统调用方法，将数据从page cache直接发送到Socket缓冲区，避免了系统上下文的切换，消除了从内核空间到用户空间的来回复制。从上图可以看出，”零拷贝”并不是说整个过程完全不发生拷贝，而是站在内核的角度来说的，避免了内核空间到用户空间的来回拷贝。</p><p>4、分区分段</p><p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。这也非常符合分布式系统分区分桶的设计思想。</p><p>通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p><p>总之，Kafka采用顺序读写、Page Cache、零拷贝以及分区分段等这些设计，再加上在索引方面做的优化，另外Kafka数据读写也是批量的而不是单条的，使得Kafka具有了高性能、高吞吐、低延时的特点。</p><p>Scan to Follow</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一致性hash算法详解</title>
    <link href="/2020/12/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/12/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一致性hash算法详解"><a href="#一致性hash算法详解" class="headerlink" title="一致性hash算法详解"></a>一致性hash算法详解</h2><p>最新推荐文章于 2024-01-06 13:51:23 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-06 13:51:23 发布</p><p>目前正在维护公司的分布式任务调度平台，在任务节点的分配上使用到了一致性hash算法，特此记录，那么在后面的博文中会给出基于java实现的一致性hash算法的代码，以及分布式调度平台的一些设计思路。</p><h3 id="1-hash算法"><a href="#1-hash算法" class="headerlink" title="1.hash算法"></a>1.hash算法</h3><p>那么什么是hash算法呢，百度百科的定义如下：</p><p>哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。</p><p><strong>普通的hash算法在分布式应用中的不足：</strong></p><p><strong>比如，在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。</strong></p><p>接下来我们来了解，一致性hash算法是怎么解决这个问题的。</p><h3 id="2-一致性hash算法"><a href="#2-一致性hash算法" class="headerlink" title="2.一致性hash算法"></a>2.一致性hash算法</h3><p>一致性哈希提出了在动态变化的Cache环境中，哈希算法应该满足的4个适应条件(from 百度百科)：</p><h4 id="均衡性-Balance"><a href="#均衡性-Balance" class="headerlink" title="均衡性(Balance)"></a>均衡性(Balance)</h4><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><h4 id="单调性-Monotonicity"><a href="#单调性-Monotonicity" class="headerlink" title="单调性(Monotonicity)"></a>单调性(Monotonicity)</h4><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。（这段翻译信息有负面价值的，当缓冲区大小变化时一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区。）</p><h4 id="分散性-Spread"><a href="#分散性-Spread" class="headerlink" title="分散性(Spread)"></a>分散性(Spread)</h4><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p><h4 id="负载-Load"><a href="#负载-Load" class="headerlink" title="负载(Load)"></a>负载(Load)</h4><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p><p>接下来说一下具体的设计：</p><h4 id="2-1环形hash空间"><a href="#2-1环形hash空间" class="headerlink" title="2.1环形hash空间"></a>2.1环形hash空间</h4><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。</p><p><strong>NOTE:<strong>当然，节点的个数可以自定义，</strong>整个hash环我们可以用TreeMap来实现，因为treeMap是排序的，我们刚好可以利用上</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e116caac05ee8718ae499652d5371c16.png"></p><h4 id="2-2映射服务器节点"><a href="#2-2映射服务器节点" class="headerlink" title="2.2映射服务器节点"></a>2.2映射服务器节点</h4><p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假设我们将四台服务器使用ip地址哈希后在环空间的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/77247578bc606dcd10613d8ea8f2b9e4.png"></p><h4 id="2-3映射数据"><a href="#2-3映射数据" class="headerlink" title="2.3映射数据"></a>2.3映射数据</h4><p>现在我们将objectA、objectB、objectC、objectD四个对象通过特定的Hash函数计算出对应的key值，<strong>然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e73adab0e5d0b65b5798337cc1045b9e.png"></p><h4 id="2-4服务器的删除与添加"><a href="#2-4服务器的删除与添加" class="headerlink" title="2.4服务器的删除与添加"></a>2.4服务器的删除与添加</h4><p><strong>2.4.1如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化</strong></p><p><strong>2.4.2如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c5c5780cb28e08f36dae84bc4ce9c758.png"></p><h4 id="2-5-虚拟节点"><a href="#2-5-虚拟节点" class="headerlink" title="2.5.虚拟节点"></a>2.5.虚拟节点</h4><p>到目前为止一致性hash也可以算做完成了，但是有一个问题还需要解决，那就是<strong>平衡性</strong>。从下图我们可以看出，当服务器节点比较少的时候，<strong>会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/97cdd5bc93cabecf2241caa6a048f17e.png"></p><p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/551d603b3eb2619933d57dce7a14b4bf.png"></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。<strong>这样就解决了服务节点少时数据倾斜的问题。每个物理节点关联的虚拟节点数量就根据具体的生产环境情况在确定。</strong></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器介绍以及布隆过滤器的实现</title>
    <link href="/2020/12/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/12/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器介绍以及布隆过滤器的实现"><a href="#布隆过滤器介绍以及布隆过滤器的实现" class="headerlink" title="布隆过滤器介绍以及布隆过滤器的实现"></a>布隆过滤器介绍以及布隆过滤器的实现</h2><p>最新推荐文章于 2023-07-26 00:15:00 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-07-26 00:15:00 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h3 id="一·简介"><a href="#一·简介" class="headerlink" title="一·简介"></a><strong>一·简介</strong></h3><p>       布隆过滤器（Bloom Filter）实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p><h3 id="二·原理"><a href="#二·原理" class="headerlink" title="二·原理"></a><strong>二·原理</strong></h3><p>1·刚开始是一个全部位为0的 bit 向量或者说 bit 数组</p><p>2.往过滤器增加”Bloom”</p><p><img src="https://img-blog.csdnimg.cn/20201204111442414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160113831-543587792.png?version=1&modificationDate=1606372166000&api=v2"></p><p>3.往过滤器增加”Filter”</p><p><img src="https://img-blog.csdnimg.cn/20201204111519559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160126506-1020676650.png?version=1&modificationDate=1606372198000&api=v2"></p><p>4.在过滤器中查询“Hash”，5的位置是0，说明“Hash”一定不存在</p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160139140-362048813.png?version=1&modificationDate=1606372206000&api=v2"></p><p><img src="https://img-blog.csdnimg.cn/20201204111611969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>5.可能存在误判情况（布隆过滤器可能会误判，如果它说不存在那肯定不存在，如果它说存在，那数据有可能实际不存在；）</p><p><img src="https://img-blog.csdnimg.cn/20201204111645641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160155384-464445682.png?version=1&modificationDate=1606372206000&api=v2"></p><p>Redis的bitmap 支持2^32大小，对应到内存也就是512MB，误判率万分之一，可以放下2亿左右的数据，性能高，空间占用率及小，省去了大量无效的数据库连接。</p><h3 id="三·使用场景"><a href="#三·使用场景" class="headerlink" title="三·使用场景"></a><strong>三·使用场景</strong></h3><ul><li><strong>防止缓存穿透</strong></li><li><strong>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</strong></li><li><strong>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</strong></li><li><strong>Google Chrome 使用布隆过滤器识别恶意 URL；</strong></li><li><strong>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</strong></li><li><strong>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。</strong></li></ul><h3 id="四·实战使用"><a href="#四·实战使用" class="headerlink" title="四·实战使用"></a><strong>四·实战使用</strong></h3><h4 id="1-Java-Guava实现"><a href="#1-Java-Guava实现" class="headerlink" title="1.Java Guava实现"></a><strong>1.Java Guava实现</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>19.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-11-26 11:31:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterTest</span> &#123;<br>    <span class="hljs-comment">//预计要插入多少数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><br>    <span class="hljs-comment">//期望的误判率</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.001</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//插入数据 1-1000000</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000000</span>; i++) &#123;<br>            bloomFilter.put(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断 1000001-2000000 因为肯定是不存在的，所以如果是true的话那肯定就是误判</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000001</span>; i &lt;= <span class="hljs-number">2000000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bloomFilter.mightContain(i)) &#123;<br>                count++;<br>                System.out.println(i + <span class="hljs-string">&quot;误判了&quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;一共的误判数:&quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以查看输出结果并计算得知误判率994&#x2F;1000000&#x3D;0.000994 跟期望误判率大致相等</p><p><img src="https://img-blog.csdnimg.cn/20201204114608959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="2-Redis实现"><a href="#2-Redis实现" class="headerlink" title="2.Redis实现"></a>2.Redis实现</h4><p>1、安装Redis官方插件 RedisBloom并在Redis配置文件中添加插件</p><p><a href="https://github.com/RedisLabsModules/redisbloom/"><em>https://github.com/RedisLabsModules/redisbloom/</em></a></p><p>[root@redis]# vim redis.conf</p><p>#####################MODULES####################                                                                                                                      </p><p># Load modules at startup. If the server is not able to load modules<br># it will abort. It is possible to use multiple loadmodule directives.<br>loadmodule &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redisbloom-1.1.1&#x2F;<a href="http://rebloom.so/">rebloom.so</a></p><p>2、使用布隆过滤</p><p>  增加到布隆过滤器</p><p>  bf.add myfilter  123</p><p>从布隆过滤器中查询，判断是否存在</p><p>  bf.exists myfilter  123   #返回  1 ，说明可能存在值</p><p>  bf.exists myfilter  321   #返回  0， 说明不存在该值</p><p>3、准确率</p><p>  Redis中有一个命令可以来设置布隆过滤器的准确率：</p><p>  bf.reserve myfilter  0.01 100</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态修改LOGGER级别—— Arthas</title>
    <link href="/2020/12/04/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9LOGGER%E7%BA%A7%E5%88%AB%E2%80%94%E2%80%94%20Arthas/"/>
    <url>/2020/12/04/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9LOGGER%E7%BA%A7%E5%88%AB%E2%80%94%E2%80%94%20Arthas/</url>
    
    <content type="html"><![CDATA[<h2 id="动态修改LOGGER级别——-Arthas"><a href="#动态修改LOGGER级别——-Arthas" class="headerlink" title="动态修改LOGGER级别—— Arthas"></a>动态修改LOGGER级别—— Arthas</h2><p>最新推荐文章于 2023-05-30 13:48:41 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-05-30 13:48:41 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h3 id="一·背景"><a href="#一·背景" class="headerlink" title="一·背景"></a><strong>一·背景</strong></h3><p>记得前阵子，我在工作中就遇到过一个生产环境数据的排查，但是大多数情况下，我们的项目在部署的时候就已经定义了LOGGER级别，用来控制输出的信息范围。</p><p>一般生产环境上我们的日志级别会设置成info级别因为，过多的输出会影响输出和查看日志的效率，另一方面，过少的日志让问题定位变得困难。</p><p>所以当生产出现问题时，线上容器通常定义在info级别，发生一些疑难问题时，光靠info级别的日志很难定位问题。</p><h3 id="二·Arthas介绍"><a href="#二·Arthas介绍" class="headerlink" title="二·Arthas介绍"></a><strong>二·Arthas介绍</strong></h3><p>Arthas是阿里开源的Java诊断工具。</p><p><img src="https://img-blog.csdnimg.cn/2020120411055538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>官方网站：<a href="https://arthas.aliyun.com/zh-cn/">https://arthas.aliyun.com/zh-cn/</a></p><h3 id="三·如何使用-Arthas进行日志级别动态修改"><a href="#三·如何使用-Arthas进行日志级别动态修改" class="headerlink" title="三·如何使用****Arthas进行日志级别动态修改"></a><strong>三·如何使用****Arthas进行日志级别动态修改</strong></h3><h4 id="1-下载并运行Arthas"><a href="#1-下载并运行Arthas" class="headerlink" title="1.下载并运行Arthas"></a><strong>1.下载并运行Arthas</strong></h4><p><strong>java -jar arthas-boot.jar</strong></p><p><img src="https://img-blog.csdnimg.cn/20201204110722314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="2-选取要查看的java应用，输入编号"><a href="#2-选取要查看的java应用，输入编号" class="headerlink" title="2.选取要查看的java应用，输入编号"></a><strong>2.选取要查看的java应用，输入编号</strong></h4><p><img src="https://img-blog.csdnimg.cn/20201204110749784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="3-运行logger命令查看应用当前日志级别"><a href="#3-运行logger命令查看应用当前日志级别" class="headerlink" title="3.运行logger命令查看应用当前日志级别"></a><strong>3.运行logger命令查看应用当前日志级别</strong></h4><p><img src="https://img-blog.csdnimg.cn/20201204110811304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="4-logger-–name-ROOT-–level-info-把ROOT的日志级别修改为info"><a href="#4-logger-–name-ROOT-–level-info-把ROOT的日志级别修改为info" class="headerlink" title="4.logger –name ROOT –level info 把ROOT的日志级别修改为info"></a>4.logger –name ROOT –level info 把ROOT的日志级别修改为info</h4><p><img src="https://img-blog.csdnimg.cn/2020120411092018.png"></p><h4 id="5-logger-–name-ROOT-–level-debug-记得排查完以后把日志级别修改回debug"><a href="#5-logger-–name-ROOT-–level-debug-记得排查完以后把日志级别修改回debug" class="headerlink" title="5.logger –name ROOT –level debug 记得排查完以后把日志级别修改回debug"></a>5.logger –name ROOT –level debug 记得排查完以后把日志级别修改回debug</h4>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现一次遍历单链表删除指定节点 剑指Offer18</title>
    <link href="/2020/11/18/Java%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%20%E5%89%91%E6%8C%87Offer18/"/>
    <url>/2020/11/18/Java%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%20%E5%89%91%E6%8C%87Offer18/</url>
    
    <content type="html"><![CDATA[<h2 id="Java实现一次遍历单链表删除指定节点-剑指Offer18"><a href="#Java实现一次遍历单链表删除指定节点-剑指Offer18" class="headerlink" title="Java实现一次遍历单链表删除指定节点 剑指Offer18"></a>Java实现一次遍历单链表删除指定节点 剑指Offer18</h2><p>最新推荐文章于 2024-01-03 17:56:19 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p>置顶 <a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-03 17:56:19 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天刷leetcode的时候做到了一条单链表的经典题目，我做的题解运行速度和所占空间都不错所以分享给大家一下我的题解和思路。</p><p>循例先上一下题目和运行结果：</p><p><strong>题目：</strong></p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.   </p><p>说明：</p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>运行结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201118160534840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><strong>题解思路：</strong></p><p><strong>首先处理头节点的两种特殊情况1.头节点为空 2.头节点就是要删除的节点</strong></p><p><strong>然后创建两个引用记录现在“位置” 和 前一个listNode的位置</strong></p><p><strong>必须要记录上一个listnode的“位置” 否则无法一次遍历就删除</strong></p><p><strong>遍历判断相等是否相等 并 移动两个引用到下一个listnode</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sword18</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword18</span>().test();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">9</span>);<br>        node4.next = node5;<br>        node5.next = node1;<br>        node1.next = node9;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword18</span>().deleteNode(node4, <span class="hljs-number">5</span>));<br>    &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">//处理头节点的两种特殊情况</span><br>        <span class="hljs-comment">//1.头节点为空</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.头节点就是要删除的节点</span><br>        <span class="hljs-keyword">if</span>(head.val==val)&#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<br>        <span class="hljs-comment">//当前位置的ListNode引用</span><br>        ListNode now;<br>        <span class="hljs-comment">//上一个位置的ListNode引用</span><br>        ListNode pre;<br>        now = head.next;<br>        pre = head;<br>        <span class="hljs-keyword">while</span>(now!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(now.val==val)&#123;<br>                <span class="hljs-comment">//删除</span><br>                pre.next = now.next;<br>            &#125;<br>            <span class="hljs-comment">//两个引用移动到下一个位置</span><br>            now = now.next;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode(<span class="hljs-type">int</span> x) &#123;<br>            val = x;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ListNode&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;val=&quot;</span> + val +<br>                    <span class="hljs-string">&quot;, next=&quot;</span> + next +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 05 替换空格 ，用时0ms，超过100%用户的Java解法</title>
    <link href="/2020/11/12/%E5%89%91%E6%8C%87%20Offer%2005%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%20%EF%BC%8C%E7%94%A8%E6%97%B60ms%EF%BC%8C%E8%B6%85%E8%BF%87100%25%E7%94%A8%E6%88%B7%E7%9A%84Java%E8%A7%A3%E6%B3%95/"/>
    <url>/2020/11/12/%E5%89%91%E6%8C%87%20Offer%2005%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%20%EF%BC%8C%E7%94%A8%E6%97%B60ms%EF%BC%8C%E8%B6%85%E8%BF%87100%25%E7%94%A8%E6%88%B7%E7%9A%84Java%E8%A7%A3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-05-替换空格-，用时0ms，超过100-用户的Java解法"><a href="#剑指-Offer-05-替换空格-，用时0ms，超过100-用户的Java解法" class="headerlink" title="剑指 Offer 05 替换空格 ，用时0ms，超过100%用户的Java解法"></a>剑指 Offer 05 替换空格 ，用时0ms，超过100%用户的Java解法</h2><p>最新推荐文章于 2024-01-06 14:29:50 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-06 14:29:50 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p><strong>题目：</strong></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”   </p><p>限制：</p><p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>然后再上一下我的提交结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201112193057780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><strong>我的解题思路：</strong></p><h3 id="1-首先遍历记录下空格字符的数目，原字符数组大小-空格字符的数目-（替换后的字符串-1）得出新数组的大小"><a href="#1-首先遍历记录下空格字符的数目，原字符数组大小-空格字符的数目-（替换后的字符串-1）得出新数组的大小" class="headerlink" title="1.首先遍历记录下空格字符的数目，原字符数组大小+空格字符的数目*（替换后的字符串-1）得出新数组的大小"></a>1.首先遍历记录下空格字符的数目，原字符数组大小+空格字符的数目*（替换后的字符串-1）得出新数组的大小</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>2.遍历字符串的原字符数组遇到空格字符的话  新数组i位置以及后面的元素为 %20还有 修改i的位置 直至遍历完成</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>3.最后返回新数组组成的字符串</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的快速失败与安全失败与遍历修改</title>
    <link href="/2020/10/21/Java%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5%E4%B8%8E%E9%81%8D%E5%8E%86%E4%BF%AE%E6%94%B9/"/>
    <url>/2020/10/21/Java%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5%E4%B8%8E%E9%81%8D%E5%8E%86%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="Java的快速失败与安全失败与遍历修改"><a href="#Java的快速失败与安全失败与遍历修改" class="headerlink" title="Java的快速失败与安全失败与遍历修改"></a>Java的快速失败与安全失败与遍历修改</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 于 2020-10-21 10:48:43 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h4 id="一、快速失败（fail—fast）"><a href="#一、快速失败（fail—fast）" class="headerlink" title="一、快速失败（fail—fast）"></a>一、快速失败（fail—fast）</h4><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。</p><p><strong>原理：</strong>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()&#x2F;next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>注意：</strong>这里异常的抛出条件是检测到 <strong>modCount !&#x3D; expectedmodCount</strong> 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。</p><p><strong>场景：</strong>java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><p><strong>方法1:</strong></p><p>在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码：</p><p><strong>方法2:</strong></p><p>使用java并发包(java.util.concurrent)中的类来代替 ArrayList 和hashMap。</p><p>比如使用 CopyOnWriterArrayList代替 ArrayList， CopyOnWriterArrayList在是使用上跟 ArrayList几乎一样， CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于 CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。</p><p>对于HashMap，可以使用ConcurrentHashMap， ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生fail-fast，但不保证获取的是最新的数据。</p><h4 id="二、安全失败（fail—safe）"><a href="#二、安全失败（fail—safe）" class="headerlink" title="二、安全失败（fail—safe）"></a>二、安全失败（fail—safe）</h4><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p><strong>原理：</strong>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</p><p>&gt;缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p><strong>场景：</strong>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><p>参考自：<a href="https://www.runoob.com/w3cnote/java-fail-ast-fail-safe.html">https://www.runoob.com/w3cnote/java-fail-ast-fail-safe.html</a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次阿里巴巴面试的经历</title>
    <link href="/2020/08/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <url>/2020/08/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>       今天我下班的时候接到了昨晚阿里巴巴面试我的技术面试官的电话，他问我昨晚的编程题是提交了全部的代码吗，我那时候正在地铁刚下班也有点迷糊，而且我想着昨晚的题也基本完成了90%应该没问题，于是我就说了：”应该是的“，然后说了一些昨晚没全部完成的理由。后面我们的通话就结束了，但是当我挂了以后我就十分后悔，我感觉这很有可能是面试官给我的最后一个机会，我想回拨回去，可是奈何这是虚拟电话，根本没有用。于是回到家中我十分懊恼，也用了一会就把昨晚的题完全做出来了，可是当我打开邮箱的时候却收到这样一封邮件：<img src="https://img-blog.csdnimg.cn/20200820201307994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>瞬间，我觉得这可能是我离阿里最远但是又是最近的一次，最近是因为从8.11日我收到了阿里的简历内推成功进入面试的通知，我很兴奋而且我感觉前面回答面试官的技术问题都回答的不错的，编程题也基本做出来了，最远又是因为这个结果已经很明确了——FAILED！后面我实在忍不住哭了，向我女朋友倾诉了，其实我这么想进去大厂，很大的一个缘故也是因为想快点赚多点钱跟她买房子，娶她。</p><p>        写到这里，我心情稍微平复，我告诉自己我得振作，总结经验：这次我感觉主要就是我的心态问题。面对阿里这样的大厂我不应该抱着完成90%就可以的心态，90%就是相当于没完成，昨晚到今天时间这么长我就应该抽出时间100%完成，这样说不定还有机会进入下一步，今天我在这里记录这个经历就当给自己的一个激励，后面我必须继续提升自己，严谨的做事，最后奉上我完成的代码和刚刚输出的符合面试官的编程题要求的输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-19 19:40:59</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wayleung/work/test.txt&quot;</span>);<br>        List&lt;Tree&gt; list = parseFile(file);<br>        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> buildTree(list);<br><span class="hljs-comment">//        System.out.println(tree);</span><br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;平谷区&quot;</span>, <span class="hljs-literal">null</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;天河区&quot;</span>, <span class="hljs-literal">null</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;天河区&quot;</span>, <span class="hljs-string">&quot;武强县&quot;</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;河北省&quot;</span>, <span class="hljs-string">&quot;衡水市&quot;</span>, <span class="hljs-string">&quot;武强县&quot;</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;河北省&quot;</span>, <span class="hljs-string">&quot;衡水市&quot;</span>, <span class="hljs-string">&quot;武强县1&quot;</span>));<br>        System.out.println(isValid(tree, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>));<br><span class="hljs-comment">//        System.out.println();</span><br>        printTree(tree);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Tree&gt; <span class="hljs-title function_">parseFile</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;Tree&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        BufferedReader br= <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(read);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> parseString(line);<br>                result.add(tree);<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            br.close();<br>            read.close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析每行字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">parseString</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>();<br>        String[] split = str.split(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">if</span>(split.length&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">parentStr</span> <span class="hljs-operator">=</span> split[<span class="hljs-number">0</span>];<br>            String[] parentStrArray = parentStr.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-keyword">if</span>(parentStrArray.length&gt;<span class="hljs-number">0</span>)&#123;<br>                tree.setParent(Integer.valueOf(parentStrArray[<span class="hljs-number">0</span>]));<br>                tree.setParentArea(parentStrArray[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">childStr</span> <span class="hljs-operator">=</span> split[<span class="hljs-number">1</span>];<br>            String[] childStrArray = childStr.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-keyword">if</span>(childStrArray.length&gt;<span class="hljs-number">0</span>)&#123;<br>                tree.setData(Integer.valueOf(childStrArray[<span class="hljs-number">0</span>]));<br>                tree.setArea(childStrArray[<span class="hljs-number">1</span>]);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> tree;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">buildTree</span><span class="hljs-params">(List&lt;Tree&gt; trees)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * groupingby 二级code 获取一个已经groupby的 二级-三级关系的map</span><br><span class="hljs-comment">         */</span><br>        Map&lt;Integer, List&lt;Tree&gt;&gt; tempChildrenMap = sortMap(trees.stream().filter(tree -&gt; tree.getParent() != <span class="hljs-number">0</span>).sorted(Comparator.comparing(Tree::getData)).collect(Collectors.groupingBy(tree -&gt; tree.getParent())));<br>        <span class="hljs-comment">//todo 可优化</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取map key所有二级关系的code</span><br><span class="hljs-comment">         */</span><br>        Set&lt;Integer&gt; keys = tempChildrenMap.keySet();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * key所有二级关系的code构建一级-二级关系 零级-一级关系的Tree 其实应该先构建了Tree的List再转map</span><br><span class="hljs-comment">         */</span><br>        List&lt;Tree&gt; allTrees = getSecondAndOne(keys,trees);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * groupingby 二级code 获取一个已经groupby的 二级-三级关系的map 完整数据</span><br><span class="hljs-comment">         */</span><br>        Map&lt;Integer, List&lt;Tree&gt;&gt; childrenMap = sortMap(allTrees.stream().filter(tree -&gt; tree.getParent() != <span class="hljs-number">0</span>).sorted(Comparator.comparing(Tree::getData)).collect(Collectors.groupingBy(tree -&gt; tree.getParent())));<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历 把所有的节点的children都关联上 引用类型 自然会一一关联</span><br><span class="hljs-comment">         */</span><br>        allTrees.forEach(tree -&gt; tree.setChildren(childrenMap.get(tree.getData())));<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 最后获取根节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> allTrees.stream().filter(tree -&gt; tree.getParent() == <span class="hljs-number">0</span>).collect(Collectors.toList()).get(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title function_">sortMap</span><span class="hljs-params">(Map&lt;Integer, List&lt;Tree&gt;&gt; childrenMap)</span> &#123;<br>        <span class="hljs-keyword">return</span> childrenMap.entrySet().stream()<br>                .sorted(Map.Entry.comparingByKey())<br>                .collect(<br>                        Collectors.toMap(<br>                                Map.Entry::getKey,<br>                                Map.Entry::getValue,<br>                                (oldVal, newVal) -&gt; oldVal,<br>                                LinkedHashMap::<span class="hljs-keyword">new</span><br>                        )<br>                );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * key为二层节点 构建一二层节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Tree&gt; <span class="hljs-title function_">getSecondAndOne</span><span class="hljs-params">(Set&lt;Integer&gt; keys,List&lt;Tree&gt; trees)</span>&#123;<br>        keys.forEach(key-&gt;&#123;<br>            <span class="hljs-type">Tree</span> <span class="hljs-variable">tempTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>();<br>            tempTree.setParent(<span class="hljs-number">1</span>);<br>            tempTree.setData(key);<br>            <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> getTree(trees, key);<br>            tempTree.setArea(tree.getParentArea());<br>            trees.add(tempTree);<br>        &#125;);<br>        trees.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;中国&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>));<br>        <span class="hljs-keyword">return</span> trees;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据data查找对应Tree</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">getTree</span><span class="hljs-params">(List&lt;Tree&gt; trees, Integer data)</span>&#123;<br>        <span class="hljs-keyword">for</span>(Tree tree:trees) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">dataTemp</span> <span class="hljs-operator">=</span> tree.getParent();<br>            <span class="hljs-keyword">if</span>(dataTemp.equals(data))&#123;<br>                <span class="hljs-keyword">return</span> tree;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Integer, List&lt;Tree&gt;&gt; <span class="hljs-title function_">buildTreeMap</span><span class="hljs-params">(List&lt;Tree&gt; trees)</span> &#123;<br>        <span class="hljs-keyword">return</span> trees.stream().filter(tree -&gt; tree.getParent() != <span class="hljs-number">1</span>).collect(Collectors.groupingBy(tree -&gt; tree.getParent()));<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否有孩子节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHasChild</span><span class="hljs-params">(Tree tree)</span>&#123;<br>        <span class="hljs-keyword">if</span>(tree.getChildren()!=<span class="hljs-literal">null</span>&amp;&amp;tree.getChildren().size()&gt;<span class="hljs-number">0</span>&amp;&amp;tree.getChildren().get(<span class="hljs-number">0</span>).getData()!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 集合是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(List list)</span>&#123;<br>        <span class="hljs-keyword">if</span>(list!=<span class="hljs-literal">null</span>&amp;&amp;list.size()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断地址是否合法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lv1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lv2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lv3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(Tree tree,String lv1,String lv2,String lv3)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!isHasChild(tree))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(lv1!=<span class="hljs-literal">null</span>&amp;&amp;!lv1.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>                List&lt;Tree&gt; children = tree.getChildren();<br>                <span class="hljs-type">Tree</span> <span class="hljs-variable">tree1</span> <span class="hljs-operator">=</span> ifHasData(children, lv1);<br>                <span class="hljs-keyword">if</span>(tree1!=<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(lv2!=<span class="hljs-literal">null</span>&amp;&amp;!lv2.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>                        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree2</span> <span class="hljs-operator">=</span> ifHasData(tree1.getChildren(), lv2);<br>                        <span class="hljs-keyword">if</span>(tree2!=<span class="hljs-literal">null</span>)&#123;<br>                            <span class="hljs-keyword">if</span>(lv3!=<span class="hljs-literal">null</span>&amp;&amp;!lv3.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>                                <span class="hljs-type">Tree</span> <span class="hljs-variable">tree3</span> <span class="hljs-operator">=</span> ifHasData(tree2.getChildren(), lv3);<br>                                <span class="hljs-keyword">if</span>(tree3!=<span class="hljs-literal">null</span>)&#123;<br>                                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                                &#125;<span class="hljs-keyword">else</span>&#123;<br>                                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;<span class="hljs-keyword">else</span>&#123;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 寻找是否有该节点 有的话返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> area</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">ifHasData</span><span class="hljs-params">(List&lt;Tree&gt; trees,String area)</span>&#123;<br>        <span class="hljs-keyword">for</span>(Tree tree:trees)&#123;<br>            <span class="hljs-keyword">if</span>(tree.getArea().equals(area))&#123;<br>                <span class="hljs-keyword">return</span> tree;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">lv</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">(Tree tree)</span>&#123;<br>        <span class="hljs-keyword">if</span>(tree!=<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(printBlank(lv)+<span class="hljs-string">&quot;-&quot;</span> + tree.getData() + <span class="hljs-string">&quot;:&quot;</span> + tree.getArea());<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isHasChild(tree))&#123;<br>            lv++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tree.getChildren().size(); i++) &#123;<br>                printTree(tree.getChildren().get(i));<br>            &#125;<br>            lv--;<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">printBlank</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">blank</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            blank = blank+<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> blank;<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 地区树实体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span>&#123;<br>    <span class="hljs-keyword">private</span> Integer parent;<br>    <span class="hljs-keyword">private</span> Integer data;<br>    <span class="hljs-keyword">private</span> String area;<br>    <span class="hljs-keyword">private</span> String parentArea;<br>    <span class="hljs-keyword">private</span> List&lt;Tree&gt; children;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getParentArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> parentArea;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParentArea</span><span class="hljs-params">(String parentArea)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parentArea = parentArea;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArea</span><span class="hljs-params">(String area)</span> &#123;<br>        <span class="hljs-built_in">this</span>.area = area;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">(Integer parent, Integer data, List&lt;Tree&gt; children)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.children = children;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">(Integer parent, Integer data,String area,String parentArea, List&lt;Tree&gt; children)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>        <span class="hljs-built_in">this</span>.parentArea = parentArea;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.children = children;<br>        <span class="hljs-built_in">this</span>.area = area;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> parent;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(Integer parent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Tree&gt; <span class="hljs-title function_">getChildren</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> children;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setChildren</span><span class="hljs-params">(List&lt;Tree&gt; children)</span> &#123;<br>        <span class="hljs-built_in">this</span>.children = children;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        return &quot;-&quot;+data+&quot;:&quot;+area+children;</span><br><br><span class="hljs-comment">//        return &quot;\n-&quot;+data+&quot;:&quot;+area+children;</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;-&quot;</span>+data+<span class="hljs-string">&quot;:&quot;</span>+area;<br>        <span class="hljs-keyword">if</span>(children!=<span class="hljs-literal">null</span>)&#123;<br>            result = result + <span class="hljs-string">&quot;\n   &quot;</span>+children.toString();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200820202923154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper集群与Leader选举</title>
    <link href="/2020/08/18/Zookeeper%E9%9B%86%E7%BE%A4%E4%B8%8ELeader%E9%80%89%E4%B8%BE/"/>
    <url>/2020/08/18/Zookeeper%E9%9B%86%E7%BE%A4%E4%B8%8ELeader%E9%80%89%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>ZooKeeper是一个开源分布式协调服务、分布式数据一致性解决方案。可基于ZooKeeper实现命名服务、集群管理、Master选举、分布式锁等功能。</p><p><strong>高可用</strong></p><p>为了保证ZooKeeper的可用性，在生产环境中我们使用ZooKeeper集群模式对外提供服务，并且集群规模至少由3个ZooKeeper节点组成。</p><p>集群至少由3个节点组成</p><p>ZooKeeper其实2个节点也可以组成集群并对外提供服务，但我们使用集群主要目的是为了高可用。如果2个节点组成集群，其中1个节点挂了，另外ZooKeeper节点不能正常对外提供服务。因此也失去了集群的意义。</p><p>如果3个节点组成集群，其中1个节点挂掉后，根据ZooKeeper的Leader选举机制是可以从另外2个节点选出一个作为Leader的，集群可以继续对外提供服务。</p><p>并非节点越多越好</p><ul><li>节点越多，使用的资源越多</li><li>节点越多，ZooKeeper节点间花费的通讯成本越高，节点间互连的Socket也越多。影响ZooKeeper集群事务处理</li><li>节点越多，造成脑裂的可能性越大</li></ul><p>集群规模为奇数</p><p>集群规模除了考虑自身成本和资源外还要结合ZooKeeper特性考虑：</p><ul><li>节省资源<br>3节点集群和4节点集群，我们选择使用3节点集群；5节点集群和6节点集群，我们选择使用5节点集群。以此类推。因为生产环境为了保证高可用，3节点集群最多只允许挂1台，4节点集群最多也只允许挂1台(过半原则中解释了原因)。同理5节点集群最多允许挂2台，6节点集群最多也只允许挂2台。<br>出于对资源节省的考虑，我们应该使用奇数节点来满足相同的高可用性。</li><li>集群可用性<br>当集群中节点间网络通讯出现问题时奇数和偶数对集群的影响</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi1iYmYyNGY3ZTA1N2FlZWUyOWRkMDY4MjE4ZGUyY2U5OF83MjB3LmpwZw?x-oss-process=image/format,png"></p><p>集群配置</p><p>ZooKeeper集群配置至少需要2处变更：</p><p><strong>1、增加集群配置</strong></p><p>在{ZK_HOME}&#x2F;conf&#x2F;zoo.cfg中增加集群的配置，结构以server.id&#x3D;ip:port1:port2为标准。</p><p>比如下面配置文件中表示由3个ZooKeeper组成的集群：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br></code></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi03NDhlM2NlMTU2NzZlZGU1MzM2ODE2MmVkYzMyYmJiMF83MjB3LnBuZw?x-oss-process=image/format,png"></p><p><strong>2、配置节点id</strong></p><p>zoo.cfg中配置集群时需要指定server.id，这个id需要在dataDir（zoo.cfg中配置）指定的目录中创建myid文件，文件内容就是当前ZooKeeper节点的id。</p><p><strong>集群角色</strong></p><p>ZooKeeper没有使用Master&#x2F;Slave的概念，而是将集群中的节点分为了3类角色：</p><ul><li><p>Leader</p><p>在一个ZooKeeper集群中，只能存在一个Leader，这个Leader是集群中事务请求唯一的调度者和处理者，所谓事务请求是指会改变集群状态的请求；Leader根据事务ID可以保证事务处理的顺序性。<br>如果一个集群中存在多个Leader，这种现象称为「脑裂」。试想一下，一个集群中存在多个Leader会产生什么影响？<br>相当于原本一个大集群，裂出多个小集群，他们之间的数据是不会相互同步的。「脑裂」后集群中的数据会变得非常混乱。</p></li><li><p>Follower<br>Follower角色的ZooKeeper服务只能处理非事务请求；如果接收到客户端事务请求会将请求转发给Leader服务器；参与Leader选举；参与Leader事务处理投票处理。<br>Follower发现集群中Leader不可用时会变更自身状态，并发起Leader选举投票，最终集群中的某个Follower会被选为Leader。</p></li><li><p>Observer<br>Observer与Follower很像，可以处理非事务请求；将事务请求转发给Leader服务器。<br>与Follower不同的是，Observer不会参与Leader选举；不会参与Leader事务处理投票。<br>Observer用于不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p></li></ul><p><strong>Leader选举</strong></p><p>Leader在集群中是非常重要的一个角色，负责了整个事务的处理和调度，保证分布式数据一致性的关键所在。既然Leader在ZooKeeper集群中这么重要所以一定要保证集群在任何时候都有且仅有一个Leader存在。</p><p>如果集群中Leader不可用了，需要有一个机制来保证能从集群中找出一个最优的服务晋升为Leader继续处理事务和调度等一系列职责。这个过程称为Leader选举。</p><p>选举机制</p><p>ZooKeeper选举Leader依赖下列原则并遵循优先顺序：</p><p><strong>1、选举投票必须在同一轮次中进行</strong></p><p>如果Follower服务选举轮次不同，不会采纳投票。</p><p><strong>2、数据最新的节点优先成为Leader</strong></p><p>数据的新旧使用事务ID判定，事务ID越大认为节点数据约接近Leader的数据，自然应该成为Leader。</p><p><strong>3、比较server.id，id值大的优先成为Leader</strong></p><p>如果每个参与竞选节点事务ID一样，再使用server.id做比较。server.id是节点在集群中唯一的id，myid文件中配置。</p><p>不管是在集群启动时选举Leader还是集群运行中重新选举Leader。集群中每个Follower角色服务都是以上面的条件作为基础推选出合适的Leader，一旦出现某个节点被过半推选，那么该节点晋升为Leader。</p><p>过半原则</p><p>ZooKeeper集群会有很多类型投票。Leader选举投票；事务提议投票；这些投票依赖过半原则。就是说ZooKeeper认为投票结果超过了集群总数的一半，便可以安全的处理后续事务。</p><ul><li><strong>事务提议投票</strong><br>假设有3个节点组成ZooKeeper集群，客户端请求添加一个节点。Leader接到该事务请求后给所有Follower发起「创建节点」的提议投票。如果Leader收到了超过集群一半数量的反馈，继续给所有Follower发起commit。此时Leader认为集群过半了，就算自己挂了集群也是安全可靠的。</li><li><strong>Leader选举投票</strong><br>假设有3个节点组成ZooKeeper集群，这时Leader挂了，需要投票选举Leader。当相同投票结果过半后Leader选出。</li><li><strong>集群可用节点</strong><br>ZooKeeper集群中每个节点有自己的角色，对于集群可用性来说必须满足过半原则。这个过半是指Leader角色 + Follower角色可用数大于集群中Leader角色 + Follower角色总数。<br>假设有5个节点组成ZooKeeper集群，一个Leader、两个Follower、两个Observer。当挂掉两个Follower或挂掉一个Leader和一个Follower时集群将不可用。因为Observer角色不参与任何形式的投票。</li></ul><p>所谓过半原则算法是说票数 &gt; 集群总节点数&#x2F;2。其中集群总节点数&#x2F;2的计算结果会向下取整。</p><p>在ZooKeeper源代码QuorumMaj.java中实现了这个算法。下面代码片段有所缩减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs auto">public boolean containsQuorum(HashSet&lt;Long&gt; set) &#123;<br>  /** n是指集群总数 */<br>  int half = n / 2;<br>  return (set.size() &gt; half);<br>&#125;<br></code></pre></td></tr></table></figure><p>回过头我们看一下奇数和偶数集群在Leader选举的结果</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi03OWExZTRmYzU1OTdmODg3ZGMwNGZlNWJlNDljNWUxMV83MjB3LnBuZw?x-oss-process=image/format,png"></p><p>所以3节点和4节点组成的集群在ZooKeeper过半原则下都最多只能挂1节点，但是4比3要多浪费一个节点资源。</p><p><strong>场景实战</strong></p><p>我们以两个场景来了解集群不可用时Leader重新选举的过程。</p><p>3节点集群重选Leader</p><p>假设有3节点组成的集群，分别是server.1（Follower）、server.2（Leader）、server.3（Follower）。此时server.2不可用了。集群会产生以下变化：</p><p><strong>1、集群不可用</strong></p><p>因为Leader挂了，集群不可用于事务请求了。</p><p><strong>2、状态变更</strong></p><p>所有Follower节点变更自身状态为LOOKING，并且变更自身投票。投票内容就是自己节点的事务ID和server.id。我们以(事务ID, server.id)表示。</p><p>假设server.1的事务id是10，变更的自身投票就是（10, 1）；server.3的事务id是8，变更的自身投票就是（8, 3）。</p><p><strong>3、首轮投票</strong></p><p>将变更的投票发给集群中所有的Follower节点。server.1将（10, 1）发给集群中所有Follower，包括它自己。server.3也一样，将（8, 3）发给所有Follower。</p><p>所以server.1将收到（10, 1）和（8, 3）两个投票，server.3将收到（8, 3）和（10, 1）两个投票。</p><p><strong>4、投票PK</strong></p><p>每个Follower节点除了发起投票外，还接其他Follower发来的投票，并与自己的投票PK(比较两个提议的事务ID以及server.id)，PK结果决定是否要变更自身状态并再次投票。</p><p>对于server.1来说收到（10, 1）和（8, 3）两个投票，与自己变更的投票比较后没有一个比自身投票（10, 1）要大的，所以server.1维持自身投票不变。</p><p>对于server.3来说收到（10, 1）和（8, 3）两个投票，与自身变更的投票比较后认为server.1发来的投票要比自身的投票大，所以server.3会变更自身投票并将变更后的投票发给集群中所有Follower。</p><p><strong>5、第二轮投票</strong></p><p>server.3将自身投票变更为（10, 1）后再次将投票发给集群中所有Follower。</p><p>对于server.1来说在第二轮收到了（10, 1）投票，server.1经过PK后继续维持不变。</p><p>对于server.3来说在第二轮收到了（10, 1）投票，因为server.3自身已变更为（10,1）投票，所以本次也维持不变。</p><p>此时server.1和server.3在投票上达成一致。</p><p><strong>6、投票接收桶</strong></p><p>节点接收的投票存储在一个接收桶里，每个Follower的投票结果在桶内只记录一次。ZooKeeper源码中接收桶用Map实现。</p><p>下面代码片段是ZooKeeper定义的接收桶，以及向桶内写入数据。Map.Key是Long类型，用来存储投票来源节点的server.id，Vote则是对应节点的投票信息。节点收到投票后会更新这个接收桶，也就是说桶里存储了所有Follower节点的投票并且仅存最后一次的投票结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs auto">HashMap&lt;Long, Vote&gt; recvset = new HashMap&lt;Long, Vote&gt;();<br>recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));<br></code></pre></td></tr></table></figure><p><strong>7、统计投票</strong></p><p>接收到投票后每次都会尝试统计投票，投票统计过半后选举成功。</p><p>投票统计的数据来源于投票接收桶里的投票数据，我们从头描述这个场景，来看一下接收桶里的数据变化情况。</p><p>server.2挂了后，server.1和server.3发起第一轮投票。</p><p>server.1接收到来自server.1的（10, 1）投票和来自server.3的（8, 3）投票。</p><p>server.3同样接收到来自server.1的（10, 1）投票和来自server.3的（8, 3）投票。此时server.1和server.3接收桶里的数据是这样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0yZjJjYzIzMDJiNDgxNzc2OTJhYzM1MGQ3YzFiNmMwMV83MjB3LmpwZw?x-oss-process=image/format,png"></p><p>server.3经过PK后认为server.1的选票比自己要大，所以变更了自己的投票并重新发起投票。</p><p>server.1收到了来自server.3的（10, 1）投票;server.3收到了来自sever.3的（10, 1）投票。此时server.1和server.3接收桶里的数据变成了这样：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0xNDVkNTlhMjcxZDliYTkxMGIwMWM1ZDg4ZDYxZDg0ZV83MjB3LmpwZw?x-oss-process=image/format,png"></p><p>基于ZooKeeper过半原则：桶内投票选举server.1作为Leader出现2次，满足了过半 2 &gt; 3&#x2F;2 即 2&gt;1。</p><p>最后sever.1节点晋升为Leader，server.3变更为Follower。</p><h4 id="集群扩容Leader启动时机"><a href="#集群扩容Leader启动时机" class="headerlink" title="集群扩容Leader启动时机"></a><strong>集群扩容Leader启动时机</strong></h4><p>ZooKeeper集群扩容需要在zoo.cfg配置文件中加入新节点。扩容流程在ZooKeeper扩容中介绍。这里我们以3节点扩容到5节点时，Leader启动时机做一个讨论。</p><p>假设目前有3个节点组成集群，分别是server.1（Follower）、server.2（Leader）、server.3（Follower），假设集群中节点事务ID相同。配置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br></code></pre></td></tr></table></figure><p><strong>1、新节点加入集群</strong></p><p>集群中新增server.4和server.5两个节点，首先修改server.4和server.5的zoo.cfg配置并启动。节点4和5在启动后会变更自身投票状态，发起一轮Leader选举投票。server.1、server.2、server.3收到投票后由于集群中已有选定Leader，所以会直接反馈server.4和server.5投票结果：server.2是Leader。server.4和server.5收到投票后基于过半原则认定server.2是Leader，自身便切换为Follower。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs auto">#节点server.1、server.2、server.3配置<br>server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br><br>#节点server.4、server.5配置<br>server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br>server.4=localhost:2884:3884<br>server.5=localhost:2885:3885<br></code></pre></td></tr></table></figure><p><strong>2、停止Leader</strong></p><p>server.4和server.5的加入需要修改集群server.1、server.2、server.3的zoo.cfg配置并重启。但是Leader节点何时重启是有讲究的，因为Leader重启会导致集群中Follower发起Leader重新选举。在server.4和server.5两个新节点正常加入后，集群不会因为新节点加入变更Leader，所以目前server.2依然是Leader。</p><p>我们以一个错误的顺序启动，看一下集群会发生什么样的变化。修改server.2zoo.cfg配置文件，增加server.4和server.5的配置并停止server.2服务。停止server.2后，Leader不存在了，集群中所有Follower会发起投票。当server.1和server.3发起投票时并不会将投票发给server.4和server.5，因为在server.1和server.3的集群配置中不包含server.4和server.5节点。相反，server.4和server.5会把选票发给集群中所有节点。也就是说对于server.1和server.3他们认为集群中只有3个节点。对于server.4和server.5他们认为集群中有5个节点。</p><p>根据过半原则，server.1和server.3很快会选出一个新Leader，我们这里假设server.3晋级成为了新Leader。但是我们没有启动server.2的情况下，因为投票不满足过半原则，server.4和server.5会一直做投票选举Leader的动作。截止到现在集群中节点状态是这样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1jN2E5N2M0OThlMTEwOGEyOTFjY2FjNmI2NmNmYWQ2N183MjB3LnBuZw?x-oss-process=image/format,png"></p><p><strong>3、启动Leader</strong></p><p>现在，我们启动server.2。因为server.2zoo.cfg已经是server.1到serverv.5的全量配置，在server.2启动后会发起选举投票，同时serverv.4和serverv.5也在不断的发起选举投票。当server.2的选举轮次和serverv.4与serverv.5选举轮次对齐后，最终server.2会变更自己的状态，认定server.5是Leaader。</p><p>意想不到的事情发生了，出现两个Leader：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0yM2NhMTJmNDk4YzMyYjI3MGYwN2Y2N2Q3NjVkNjkwMl83MjB3LnBuZw?x-oss-process=image/format,png"></p><p>ZooKeeper集群扩容时，如果Leader节点最后启动就可以避免这类问题发生，因为在Leader节点重启前，所有的Follower节点zoo.cfg配置已经是相同的，他们基于同一个集群配置两两互联，做投票选举。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CP和AP有是什么？有什么区别？</title>
    <link href="/2020/08/18/CP%E5%92%8CAP%E6%9C%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2020/08/18/CP%E5%92%8CAP%E6%9C%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="CP和AP有是什么？有什么区别？"><a href="#CP和AP有是什么？有什么区别？" class="headerlink" title="CP和AP有是什么？有什么区别？"></a>CP和AP有是什么？有什么区别？</h2><p>最新推荐文章于 2024-01-06 16:53:14 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-06 16:53:14 发布</p><p>最近有时间研究分布式架构，因为公司使用的Zookeeper，并没有使用Spring Cloud Eureka，所以想探究一下他们之间的区别，于是看到简书里的文章：<a href="https://www.jianshu.com/p/e47c027a9aeb">Spring Cloud Eureka简介及与Zookeeper对比</a>，明显的区别可能就是Zookeeper为CP设计，而Eureka为AP设计，但是对CAP&#x2F;AP&#x2F;CP很不理解，于是查阅资料，做一个简单的了解。</p><blockquote><p>Eureka服务治理机制与Dubbo服务治理机制的比较</p><table><thead><tr><th>Feature</th><th>Eureka</th><th>Zookeeper</th></tr></thead><tbody><tr><td>服务健康检查</td><td>可配支持</td><td>(弱)长连接，keepalive</td></tr><tr><td>CAP</td><td>AP</td><td>CP</td></tr><tr><td>watch支持（客户端观察到服务提供者变化）</td><td>支持 long polling&#x2F;大部分增量</td><td>支持</td></tr><tr><td>自我保护</td><td>支持</td><td>-</td></tr><tr><td>客户端缓存</td><td>支持</td><td>-</td></tr><tr><td>自身集群的监控</td><td>metrics</td><td>-</td></tr></tbody></table><p>Eureka支持健康检查，自我保护等</p><p>Zookeeper为CP设计，Eureka为AP设计。作为服务发现产品，可用性优先级较高，一致性的特点并不重要，宁可返回错误的数据，也比不反回结果要好得多。</p><p>服务列表变更Zookeeper服务端会有通知，Eureka则通过长轮询来实现，Eureka未来会实现watch机制</p></blockquote><p>CAP理论提出就是针对分布式数据库环境的，所以，P这个属性是必须具备的。<br>P就是在分布式环境中，由于网络的问题可能导致某个节点和其它节点失去联系，这时候就形成了P(partition)，也就是由于网络问题，将系统的成员隔离成了2个区域，互相无法知道对方的状态，这在分布式环境下是非常常见的。<br>因为P是必须的，那么我们需要选择的就是A和C。<br>大家知道，在分布式环境下，为了保证系统可用性，通常都采取了复制的方式，避免一个节点损坏，导致系统不可用。那么就出现了每个节点上的数据出现了很多个副本的情况，而数据从一个节点复制到另外的节点时需要时间和要求网络畅通的，所以，当P发生时，也就是无法向某个节点复制数据时，这时候你有两个选择：<br>选择可用性 A(Availability)，此时，那个失去联系的节点依然可以向系统提供服务，不过它的数据就不能保证是同步的了（失去了C属性）。<br>选择一致性C(Consistency)，为了保证数据库的一致性，我们必须等待失去联系的节点恢复过来，在这个过程中，那个节点是不允许对外提供服务的，这时候系统处于不可用状态(失去了A属性)。</p><p>最常见的例子是读写分离，某个节点负责写入数据，然后将数据同步到其它节点，其它节点提供读取的服务，当两个节点出现通信问题时，你就面临着选择A（继续提供服务，但是数据不保证准确），C（用户处于等待状态，一直等到数据同步完成）。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hystrix熔断机制原理剖析</title>
    <link href="/2020/08/14/Hystrix%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/2020/08/14/Hystrix%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Hystrix熔断机制原理剖析"><a href="#Hystrix熔断机制原理剖析" class="headerlink" title="Hystrix熔断机制原理剖析"></a>Hystrix熔断机制原理剖析</h2><p>最新推荐文章于 2024-01-02 12:13:54 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-02 12:13:54 发布</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在分布式系统架构中多个系统之间通常是通过远程RPC调用进行通信，也就是 A 系统调用 B 系统服务，B 系统调用 C 系统的服务。当尾部应用 C 发生故障而系统 B 没有服务降级时候可能会导致 B，甚至系统 A 瘫痪，这种现象被称为雪崩现象。所以在系统设计时候要使用一定的降级策略，来保证当服务提供方服务不可用时候，服务调用方可以切换到降级后的策略进行执行。</p><h2 id="二、Hystrix-中基于自反馈调节熔断状态的算法原理"><a href="#二、Hystrix-中基于自反馈调节熔断状态的算法原理" class="headerlink" title="二、Hystrix 中基于自反馈调节熔断状态的算法原理"></a>二、Hystrix 中基于自反馈调节熔断状态的算法原理</h2><p>我们可以把熔断器想象为一个保险丝，在电路系统中，一般在所有的家电系统连接外部供电的线路中间都会加一个保险丝，当外部电压过高，达到保险丝的熔点时候，保险丝就会被熔断，从而可以切断家电系统与外部电路的联通，进而保障家电系统不会因为电压过高而损坏。</p><p>Hystrix提供的熔断器就有类似功能，当在一定时间段内服务调用方调用服务提供方的服务的次数达到设定的阈值，并且出错的次数也达到设置的出错阈值，就会进行服务降级，让服务调用方之间执行本地设置的降级策略，而不再发起远程调用。但是Hystrix提供的熔断器具有自我反馈，自我恢复的功能，Hystrix会根据调用接口的情况，让熔断器在closed,open,half-open三种状态之间自动切换。</p><p>open状态说明打开熔断，也就是服务调用方执行本地降级策略，不进行远程调用。<br>closed状态说明关闭了熔断，这时候服务调用方直接发起远程调用。<br>half-open状态，则是一个中间状态，当熔断器处于这种状态时候，直接发起远程调用。</p><p>三种状态的转换：</p><ul><li><p>closed-&gt;open:正常情况下熔断器为closed状态，当访问同一个接口次数超过设定阈值并且错误比例超过设置错误阈值时候，就会打开熔断机制，这时候熔断器状态从closed-&gt;open。</p></li><li><p>open-&gt;half-open:当服务接口对应的熔断器状态为open状态时候，所有服务调用方调用该服务方法时候都是执行本地降级方法，那么什么时候才会恢复到远程调用那？Hystrix提供了一种测试策略，也就是设置了一个时间窗口，从熔断器状态变为open状态开始的一个时间窗口内，调用该服务接口时候都委托服务降级方法进行执行。如果时间超过了时间窗口，则把熔断状态从open-&gt;half-open,这时候服务调用方调用服务接口时候，就可以发起远程调用而不再使用本地降级接口，如果发起远程调用还是失败，则重新设置熔断器状态为open状态，从新记录时间窗口开始时间。</p></li><li><p>half-open-&gt;closed: 当熔断器状态为half-open,这时候服务调用方调用服务接口时候，就可以发起远程调用而不再使用本地降级接口，如果发起远程调用成功，则重新设置熔断器状态为closed状态。</p></li></ul><p>那么有一个问题，用来判断熔断器从closed-&gt;open转换的数据是哪里来的那？其实这个是HystrixCommandMetrics对象来做的，该对象用来存在HystrixCommand的一些指标数据，比如接口调用次数，调用接口失败的次数等等，后面我们会讲解。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>系统设计时候要使用一定的降级策略，来保证当服务提供方服务不可用时候，服务调用方可以切换到降级后的策略进行执行，Hystrix作为熔断器组件使用范围还是很广泛的.</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈服务限流算法的几种实现</title>
    <link href="/2020/08/13/%E8%B0%88%E8%B0%88%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/08/13/%E8%B0%88%E8%B0%88%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。今天和大家谈谈限流算法的几种实现方式，本文所说的限流并非是Nginx层面的限流，而是业务代码中的逻辑限流。</p><h4 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h4><p>按照服务的调用方，可以分为以下几种类型服务</p><p>1、与用户打交道的服务</p><p>比如web服务、对外API，这种类型的服务有以下几种可能导致机器被拖垮：</p><ul><li><p>用户增长过快（这是好事）</p></li><li><p>因为某个热点事件（微博热搜）</p></li><li><p>竞争对象爬虫</p></li><li><p>恶意的刷单</p></li></ul><p>这些情况都是无法预知的，不知道什么时候会有10倍甚至20倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的（弹性扩容都是虚谈，一秒钟你给我扩一下试试）</p><p>2、对内的RPC服务</p><p>一个服务A的接口可能被BCDE多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对CDE也无法提供服务。 这种情况时有发生，解决方案有两种： 1、每个调用方采用线程池进行资源隔离 2、使用限流手段对每个调用方进行限流</p><h4 id="限流算法实现"><a href="#限流算法实现" class="headerlink" title="限流算法实现"></a>限流算法实现</h4><p>常见的限流算法有：计数器、令牌桶、漏桶。</p><p>1、计数器算法</p><p>采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。</p><p>具体的实现可以是这样的：对于每次服务调用，可以通过 <code>AtomicLong#incrementAndGet()</code>方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。</p><p>这种实现方式，相信大家都知道有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”</p><p>2、漏桶算法</p><p>为了消除”突刺现象”，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。</p><p>不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p><p><img src="https://img-blog.csdn.net/20180722161419529?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。</p><p>这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p><p>3、令牌桶算法</p><p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。</p><p>在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p><p>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p><p><img src="https://img-blog.csdn.net/20180722161357369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。</p><p>幸运的是，通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>18.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过RateLimiter类的create方法，创建限流器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterMain</span> &#123;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>       <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">10</span>);<br> <br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br> <br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br> <br>               <span class="hljs-meta">@Override</span><br> <br>               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <br>                   rateLimiter.acquire()<br> <br>                   System.out.println(<span class="hljs-string">&quot;pass&quot;</span>);<br> <br>               &#125;<br> <br>           &#125;).start();<br> <br>       &#125;<br> <br>   &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>其实Guava提供了多种create方法，方便创建适合各种需求的限流器。在上述例子中，创建了一个每秒生成10个令牌的限流器，即100ms生成一个，并最多保存10个令牌，多余的会被丢弃。</p><p>rateLimiter提供了acquire()和tryAcquire()接口 1、使用acquire()方法，如果没有可用令牌，会一直阻塞直到有足够的令牌。 2、使用tryAcquire()方法，如果没有可用令牌，就直接返回false。 3、使用tryAcquire()带超时时间的方法，如果没有可用令牌，就会判断在超时时间内是否可以等到令牌，如果不能，就返回false，如果可以，就阻塞等待。</p><p>集群限流</p><p>前面讨论的几种算法都属于单机限流的范畴，但是业务需求五花八门，简单的单机限流，根本无法满足他们。</p><p>比如为了限制某个资源被每个用户或者商户的访问次数，5s只能访问2次，或者一天只能调用1000次，这种需求，单机限流是无法实现的，这时就需要通过集群限流进行实现。</p><p><strong>如何实现？</strong>为了控制访问次数，肯定需要一个计数器，而且这个计数器只能保存在第三方服务，比如redis。</p><p>大概思路：每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问&#x2F;index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用4种限流算法介绍及比较</title>
    <link href="/2020/08/13/%E5%B8%B8%E7%94%A84%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
    <url>/2020/08/13/%E5%B8%B8%E7%94%A84%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="常用4种限流算法介绍及比较"><a href="#常用4种限流算法介绍及比较" class="headerlink" title="常用4种限流算法介绍及比较"></a>常用4种限流算法介绍及比较</h2><p>最新推荐文章于 2023-03-30 00:22:18 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-03-30 00:22:18 发布</p><p><strong>1****、计数器（固定窗口）算法</strong><br>计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。</p><p>此算法在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性和线程安全即可轻松实现。</p><p><img src="https://img-blog.csdnimg.cn/20190716091143141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p>这个算法通常用于QPS限流和统计总访问量，对于秒级以上的时间周期来说，会存在一个非常严重的问题，那就是临界问题，如下图：<br><img src="https://img-blog.csdnimg.cn/20190716091413825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p>假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端。</p><p><strong>2****、滑动窗口算法</strong><br>滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。</p><p>如下图，假设时间周期为1min，将1min再分为2个小周期，统计每个小周期的访问数量，则可以看到，第一个时间周期内，访问数量为75，第二个时间周期内，访问数量为100，超过100的访问则被限流掉了   </p><p><img src="https://img-blog.csdnimg.cn/20190716091612718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p>由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p>此算法可以很好的解决固定窗口算法的临界问题。</p><p><strong>3****、漏桶算法</strong></p><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。</p><p><img src="https://img-blog.csdnimg.cn/20190716090944456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p><strong>4****、令牌桶算法</strong><br>令牌桶算法是程序以r（r&#x3D;时间周期&#x2F;限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略</p><p><img src="https://img-blog.csdnimg.cn/20190716090944463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p><strong>各个算法比较</strong></p><table><tbody><tr><td><p>算法</p></td><td><p>确定参数</p></td><td><p>空间复杂度</p></td><td><p>时间复杂度</p></td><td><p>限制突发流量</p></td><td><p>平滑限流</p></td><td><p>分布式环境下实现难度</p></td></tr><tr><td><p>固定窗口</p></td><td><p>计数周期T、</p><p>周期内最大访问数N</p></td><td><p>低O(1)</p><p>（记录周期内访问次数及周期开始时间）</p></td><td><p>低O(1)</p></td><td><p>否</p></td><td><p>否</p></td><td><p>低</p></td></tr><tr><td><p>滑动窗口</p></td><td><p>计数周期T、</p><p>周期内最大访问数N</p></td><td><p>高O(N)</p><p>（记录每个小周期中的访问数量）</p></td><td><p>中O(N)</p></td><td><p>是</p></td><td><p>相对实现。滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑</p></td><td><p>中</p></td></tr><tr><td><p>漏桶</p></td><td><p>漏桶流出速度r、漏桶容量N</p></td><td><p>低O(1)</p><p>（记录当前漏桶中容量）</p></td><td><p>高O(N)</p></td><td><p>是</p></td><td><p>是</p></td><td><p>高</p></td></tr><tr><td><p>令牌桶</p></td><td><p>令牌产生速度r、令牌桶容量N</p></td><td><p>低O(1)</p><p>（记录当前令牌桶中令牌数）</p></td><td><p>高O(N)</p></td><td><p>是</p></td><td><p>是</p></td><td><p>高</p></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限流算法</title>
    <link href="/2020/08/13/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <url>/2020/08/13/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。今天和大家谈谈限流算法的几种实现方式，本文所说的限流并非是Nginx层面的限流，而是业务代码中的逻辑限流。</p><h4 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h4><p>按照服务的调用方，可以分为以下几种类型服务</p><p>1、与用户打交道的服务</p><p>比如web服务、对外API，这种类型的服务有以下几种可能导致机器被拖垮：</p><ul><li><p>用户增长过快（这是好事）</p></li><li><p>因为某个热点事件（微博热搜）</p></li><li><p>竞争对象爬虫</p></li><li><p>恶意的刷单</p></li></ul><p>这些情况都是无法预知的，不知道什么时候会有10倍甚至20倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的（弹性扩容都是虚谈，一秒钟你给我扩一下试试）</p><p>2、对内的RPC服务</p><p>一个服务A的接口可能被BCDE多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对CDE也无法提供服务。 这种情况时有发生，解决方案有两种： 1、每个调用方采用线程池进行资源隔离 2、使用限流手段对每个调用方进行限流</p><h4 id="限流算法实现"><a href="#限流算法实现" class="headerlink" title="限流算法实现"></a>限流算法实现</h4><p>常见的限流算法有：计数器、令牌桶、漏桶。</p><p>1、计数器算法</p><p>采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。</p><p>具体的实现可以是这样的：对于每次服务调用，可以通过 <code>AtomicLong#incrementAndGet()</code>方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。</p><p>这种实现方式，相信大家都知道有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”</p><p>2、漏桶算法</p><p>为了消除”突刺现象”，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。</p><p>不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p><p><img src="https://img-blog.csdn.net/20180722161419529?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。</p><p>这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p><p>3、令牌桶算法</p><p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。</p><p>在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p><p>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p><p><img src="https://img-blog.csdn.net/20180722161357369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。</p><p>幸运的是，通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>18.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">通过RateLimiter类的create方法，创建限流器。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterMain</span> &#123;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>       <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">10</span>);<br> <br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br> <br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br> <br>               <span class="hljs-meta">@Override</span><br> <br>               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <br>                   rateLimiter.acquire()<br> <br>                   System.out.println(<span class="hljs-string">&quot;pass&quot;</span>);<br> <br>               &#125;<br> <br>           &#125;).start();<br> <br>       &#125;<br> <br>   &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>其实Guava提供了多种create方法，方便创建适合各种需求的限流器。在上述例子中，创建了一个每秒生成10个令牌的限流器，即100ms生成一个，并最多保存10个令牌，多余的会被丢弃。</p><p>rateLimiter提供了acquire()和tryAcquire()接口 1、使用acquire()方法，如果没有可用令牌，会一直阻塞直到有足够的令牌。 2、使用tryAcquire()方法，如果没有可用令牌，就直接返回false。 3、使用tryAcquire()带超时时间的方法，如果没有可用令牌，就会判断在超时时间内是否可以等到令牌，如果不能，就返回false，如果可以，就阻塞等待。</p><p>集群限流</p><p>前面讨论的几种算法都属于单机限流的范畴，但是业务需求五花八门，简单的单机限流，根本无法满足他们。</p><p>比如为了限制某个资源被每个用户或者商户的访问次数，5s只能访问2次，或者一天只能调用1000次，这种需求，单机限流是无法实现的，这时就需要通过集群限流进行实现。</p><p><strong>如何实现？</strong>为了控制访问次数，肯定需要一个计数器，而且这个计数器只能保存在第三方服务，比如redis。</p><p>大概思路：每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问&#x2F;index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式中静态代理、jdk动态代理、cglib动态代理有什么不同？</title>
    <link href="/2020/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <url>/2020/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h3><p>首先，写一个要实现的目标的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:42:20</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TargetInterface</span> &#123;<br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再写一个目标实现类，也就是需要被代理（增强）的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:43:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TargetInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name;<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是代理类的编写，<strong>此处的核心是把被代理类进行注入并调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:44:47</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TargetInterface</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TargetInterface targetInterface;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(TargetInterface targetInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.targetInterface = targetInterface;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理前做点东西&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> targetInterface.sayHello(name);<br>        System.out.println(<span class="hljs-string">&quot;代理后做点东西&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:41:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TargetInterface</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br>        <span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target);<br>        proxy.sayHello(<span class="hljs-string">&quot;way&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重"><a href="#静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重" class="headerlink" title="静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重"></a><strong>静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重</strong></h4><h3 id="2-Jdk动态代理"><a href="#2-Jdk动态代理" class="headerlink" title="2.Jdk动态代理"></a><strong>2.Jdk动态代理</strong></h3><h4 id="静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现"><a href="#静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现" class="headerlink" title="静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现"></a><strong>静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现</strong></h4><p>Proxy和Target、TargetInterface可以共用上面的代码，我就不重复了</p><p>Jdk动态代理主要就是用了Java 反射包下的Proxy.newInstance这个方法，而这个方法里的参数又需要一个InvocationHandler的实现类，所以首先实现InvocationHandler接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 10:10:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理前做点东西&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;代理后做点东西&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:53:07</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TargetInterface</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">dynamicProxyInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>(target);<br>        <span class="hljs-type">TargetInterface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), dynamicProxyInvocationHandler);<br>        System.out.println(proxy.getClass().getName());<br>        proxy.sayHello(<span class="hljs-string">&quot;way&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）-为什么呢？通过上面的输出可以看到-com-sun-proxy-Proxy0-，proxy是一个代理对象，通过反编译源码可以得知-Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。"><a href="#Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）-为什么呢？通过上面的输出可以看到-com-sun-proxy-Proxy0-，proxy是一个代理对象，通过反编译源码可以得知-Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。" class="headerlink" title="Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）,为什么呢？通过上面的输出可以看到 com.sun.proxy.$Proxy0 ，proxy是一个代理对象，通过反编译源码可以得知$Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。"></a><strong>Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）,为什么呢？通过上面的输出可以看到 com.sun.proxy.$Proxy0 ，proxy是一个代理对象，通过反编译源码可以得知$Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。</strong>而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。</h4><h3 id="3-Cglib动态代理"><a href="#3-Cglib动态代理" class="headerlink" title="3.Cglib动态代理"></a><strong>3.Cglib动态代理</strong></h3><p>首先，引入相关依赖：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这次，为了对比，我们建一个没有实现接口的被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:43:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetNoInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name;<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是类似Jdk动态代理的实现相关api：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 10:38:32</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object target, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理前做点东西&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(target, args);<br>        System.out.println(<span class="hljs-string">&quot;代理后做点东西&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是去使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 10:37:19</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibDynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setClassLoader(TargetNoInterface.class.getClassLoader());<br>        enhancer.setSuperclass(TargetNoInterface.class);<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMethodInterceptor</span>());<br>        <span class="hljs-type">TargetNoInterface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (TargetNoInterface) enhancer.create();<br>        System.out.println(proxy.getClass().getName());<br>        proxy.sayHello(<span class="hljs-string">&quot;way&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib-动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为-final-类型的类和方法，假如被代理类是final类，那么运行时报错："><a href="#通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib-动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为-final-类型的类和方法，假如被代理类是final类，那么运行时报错：" class="headerlink" title="通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib 动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法，假如被代理类是final类，那么运行时报错："></a>通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib 动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法，假如被代理类是final类，那么运行时报错：</h4><p><img src="https://img-blog.csdnimg.cn/202008121134593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）："><a href="#假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）：" class="headerlink" title="假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）："></a>假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）：</h4><p><img src="https://img-blog.csdnimg.cn/20200812113649327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发之AQS详解</title>
    <link href="/2020/07/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/07/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Java并发之AQS详解"><a href="#Java并发之AQS详解" class="headerlink" title="Java并发之AQS详解"></a><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></h2><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>　　谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！</p><p>　　类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…。</p><p>　　以下是本文的目录大纲：</p><ol><li><ol><li>概述</li><li>框架</li><li>源码详解</li><li>简单应用</li></ol></li></ol><p>　　若有不正之处，请谅解和批评指正，不胜感激。</p><p>　　请尊重作者劳动成果，转载请标明原文链接（原文持续更新，建议阅读原文）：<a href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p><h2 id="二、框架"><a href="#二、框架" class="headerlink" title="二、框架"></a>二、框架</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTcwNS83MjEwNzAtMjAxNzA1MDQxMTAyNDYyMTEtMTA2ODQ0ODUucG5n?x-oss-process=image/format,png"></p><p>　　它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p>　　AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p><p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="三、源码详解"><a href="#三、源码详解" class="headerlink" title="三、源码详解"></a>三、源码详解</h2><p>　　本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。</p><h3 id="3-0-结点状态waitStatus"><a href="#3-0-结点状态waitStatus" class="headerlink" title="3.0 结点状态waitStatus"></a>3.0 结点状态waitStatus</h3><p>      这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p><ul><li><p><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</p></li><li><p><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</p></li><li><p><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</p></li><li><p><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</p></li><li><p><strong>0</strong>：新结点入队时的默认状态。</p></li></ul><p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p><h3 id="3-1-acquire-int"><a href="#3-1-acquire-int" class="headerlink" title="3.1 acquire(int)"></a>3.1 acquire(int)</h3><p>　　此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p><p>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }</p><p>　　函数流程如下：</p><ol><li><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol></li></ol><p>　　这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。就像《大话西游》里唐僧说的：等你明白了舍生取义的道理，你自然会回来和我唱这首歌的。</p><h4 id="3-1-1-tryAcquire-int"><a href="#3-1-1-tryAcquire-int" class="headerlink" title="3.1.1 tryAcquire(int)"></a>3.1.1 tryAcquire(int)</h4><p>　　此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p><p>1     protected boolean tryAcquire(int arg) {<br>2         throw new UnsupportedOperationException();<br>3     }</p><p>　　什么？直接throw异常？说好的功能呢？好吧，<strong>还记得概述里讲的AQS只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现吗？</strong>就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get&#x2F;set&#x2F;CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><p>　　这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</p><h4 id="3-1-2-addWaiter-Node"><a href="#3-1-2-addWaiter-Node" class="headerlink" title="3.1.2 addWaiter(Node)"></a>3.1.2 addWaiter(Node)</h4><p>　　此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private Node addWaiter(Node mode) {<br> 2     &#x2F;&#x2F;以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）<br> 3     Node node &#x3D; new Node(Thread.currentThread(), mode);<br> 4<br> 5     &#x2F;&#x2F;尝试快速方式直接放到队尾。<br> 6     Node pred &#x3D; tail;<br> 7     if (pred !&#x3D; null) {<br> 8         node.prev &#x3D; pred;<br> 9         if (compareAndSetTail(pred, node)) {<br>10             pred.next &#x3D; node;<br>11             return node;<br>12         }<br>13     }<br>14<br>15     &#x2F;&#x2F;上一步失败则通过enq入队。<br>16     enq(node);<br>17     return node;<br>18 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 不用再说了，直接看注释吧。</p><p>3.1.2.1 enq(Node)</p><p> 　　此方法用于将node加入队尾。源码如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private Node enq(final Node node) {<br> 2     &#x2F;&#x2F;CAS”自旋”，直到成功加入队尾<br> 3     for (;;) {<br> 4         Node t &#x3D; tail;<br> 5         if (t &#x3D;&#x3D; null) { &#x2F;&#x2F; 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。<br> 6             if (compareAndSetHead(new Node()))<br> 7                 tail &#x3D; head;<br> 8         } else {&#x2F;&#x2F;正常流程，放入队尾<br> 9             node.prev &#x3D; t;<br>10             if (compareAndSetTail(t, node)) {<br>11                 t.next &#x3D; node;<br>12                 return t;<br>13             }<br>14         }<br>15     }<br>16 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。<strong>CAS自旋volatile变量</strong>，是一种很经典的用法。还不太了解的，自己去百度一下吧。</p><h4 id="3-1-3-acquireQueued-Node-int"><a href="#3-1-3-acquireQueued-Node-int" class="headerlink" title="3.1.3 acquireQueued(Node, int)"></a>3.1.3 acquireQueued(Node, int)</h4><p>　　OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。这个函数非常关键，还是上源码吧：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 final boolean acquireQueued(final Node node, int arg) {<br> 2     boolean failed &#x3D; true;&#x2F;&#x2F;标记是否成功拿到资源<br> 3     try {<br> 4         boolean interrupted &#x3D; false;&#x2F;&#x2F;标记等待过程中是否被中断过<br> 5<br> 6         &#x2F;&#x2F;又是一个“自旋”！<br> 7         for (;;) {<br> 8             final Node p &#x3D; node.predecessor();&#x2F;&#x2F;拿到前驱<br> 9             &#x2F;&#x2F;如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。<br>10             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) {<br>11                 setHead(node);&#x2F;&#x2F;拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。<br>12                 p.next &#x3D; null; &#x2F;&#x2F; setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！<br>13                 failed &#x3D; false; &#x2F;&#x2F; 成功获取资源<br>14                 return interrupted;&#x2F;&#x2F;返回等待过程中是否被中断过<br>15             }<br>16<br>17             &#x2F;&#x2F;如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。<br>18             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>19                 parkAndCheckInterrupt())<br>20                 interrupted &#x3D; true;&#x2F;&#x2F;如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true<br>21         }<br>22     } finally {<br>23         if (failed) &#x2F;&#x2F; 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。<br>24             cancelAcquire(node);<br>25     }<br>26 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</p><p>3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)</p><p>　　此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html">Thread详解</a>），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br> 2     int ws &#x3D; pred.waitStatus;&#x2F;&#x2F;拿到前驱的状态<br> 3     if (ws &#x3D;&#x3D; Node.SIGNAL)<br> 4         &#x2F;&#x2F;如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了<br> 5         return true;<br> 6     if (ws &gt; 0) {<br> 7         &#x2F;*<br> 8          * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。<br> 9          * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！<br>10          *&#x2F;<br>11         do {<br>12             node.prev &#x3D; pred &#x3D; pred.prev;<br>13         } while (pred.waitStatus &gt; 0);<br>14         pred.next &#x3D; node;<br>15     } else {<br>16          &#x2F;&#x2F;如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！<br>17         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>18     }<br>19     return false;<br>20 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><p>3.1.3.2 parkAndCheckInterrupt()</p><p>　　如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p><p>1 private final boolean parkAndCheckInterrupt() {<br>2     LockSupport.park(this);&#x2F;&#x2F;调用park()使线程进入waiting状态<br>3     return Thread.interrupted();&#x2F;&#x2F;如果被唤醒，查看自己是不是被中断的。<br>4 }</p><p> 　　park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html">Thread详解</a>）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p><p>3.1.3.3 小结</p><p>　　OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</p><ol><li>结点进入队尾后，检查状态，找到安全休息点；</li><li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li><li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li></ol><h4 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h4><p>　　OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</p><p>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }</p><p>再来总结下它的流程吧：</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p>由于此函数是重中之重，我再用流程图总结一下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTUxMS83MjEwNzAtMjAxNTExMDIxNDU3NDM0NjEtNjIzNzk0MzI2LnBuZw?x-oss-process=image/format,png"></p><p>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</p><h3 id="3-2-release-int"><a href="#3-2-release-int" class="headerlink" title="3.2 release(int)"></a>3.2 release(int)</h3><p> 　　上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>1 public final boolean release(int arg) {<br>2     if (tryRelease(arg)) {<br>3         Node h &#x3D; head;&#x2F;&#x2F;找到头结点<br>4         if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)<br>5             unparkSuccessor(h);&#x2F;&#x2F;唤醒等待队列里的下一个线程<br>6         return true;<br>7     }<br>8     return false;<br>9 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，<strong>它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</strong></p><h4 id="3-2-1-tryRelease-int"><a href="#3-2-1-tryRelease-int" class="headerlink" title="3.2.1 tryRelease(int)"></a>3.2.1 tryRelease(int)</h4><p>　　此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p><p>1 protected boolean tryRelease(int arg) {<br>2     throw new UnsupportedOperationException();<br>3 }</p><p>　　跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-&#x3D;arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state&#x3D;0)，要返回true，否则返回false。</p><h4 id="3-2-2-unparkSuccessor-Node"><a href="#3-2-2-unparkSuccessor-Node" class="headerlink" title="3.2.2 unparkSuccessor(Node)"></a>3.2.2 unparkSuccessor(Node)</h4><p>　　此方法用于唤醒等待队列中下一个线程。下面是源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void unparkSuccessor(Node node) {<br> 2     &#x2F;&#x2F;这里，node一般为当前线程所在的结点。<br> 3     int ws &#x3D; node.waitStatus;<br> 4     if (ws &lt; 0)&#x2F;&#x2F;置零当前线程所在的结点状态，允许失败。<br> 5         compareAndSetWaitStatus(node, ws, 0);<br> 6<br> 7     Node s &#x3D; node.next;&#x2F;&#x2F;找到下一个需要唤醒的结点s<br> 8     if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) {&#x2F;&#x2F;如果为空或已取消<br> 9         s &#x3D; null;<br>10         for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev) &#x2F;&#x2F; 从后向前找。<br>11             if (t.waitStatus &lt;&#x3D; 0)&#x2F;&#x2F;从这里可以看出，&lt;&#x3D;0的结点，都是还有效的结点。<br>12                 s &#x3D; t;<br>13     }<br>14     if (s !&#x3D; null)<br>15         LockSupport.unpark(s.thread);&#x2F;&#x2F;唤醒<br>16 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　这个函数并不复杂。一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg))的判断（即使p!&#x3D;head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p&#x3D;&#x3D;head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p><h4 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h4><p>　　release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源。</p><p>      74楼的朋友提了一个非常有趣的问题：如果获取锁的线程在release时异常了，没有unpark队列中的其他结点，这时队列中的其他结点会怎么办？是不是没法再被唤醒了？</p><p>      答案是<strong>YES</strong>（测试程序详见76楼）！！！这时，队列中等待锁的线程将永远处于park状态，无法再被唤醒！！！但是我们再回头想想，获取锁的线程在什么情形下会release抛出异常呢？？</p><ol><li>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</li><li>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</li><li>release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。<strong>除非自己写的tryRelease()有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了</strong>。</li></ol><h3 id="3-3-acquireShared-int"><a href="#3-3-acquireShared-int" class="headerlink" title="3.3 acquireShared(int)"></a>3.3 acquireShared(int)</h3><p>　　此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p><p>1 public final void acquireShared(int arg) {<br>2     if (tryAcquireShared(arg) &lt; 0)<br>3         doAcquireShared(arg);<br>4 }</p><p>　　这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><ol><li><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol></li></ol><h4 id="3-3-1-doAcquireShared-int"><a href="#3-3-1-doAcquireShared-int" class="headerlink" title="3.3.1 doAcquireShared(int)"></a>3.3.1 doAcquireShared(int)</h4><p>　　此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void doAcquireShared(int arg) {<br> 2     final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;加入队列尾部<br> 3     boolean failed &#x3D; true;&#x2F;&#x2F;是否成功标志<br> 4     try {<br> 5         boolean interrupted &#x3D; false;&#x2F;&#x2F;等待过程中是否被中断过的标志<br> 6         for (;;) {<br> 7             final Node p &#x3D; node.predecessor();&#x2F;&#x2F;前驱<br> 8             if (p &#x3D;&#x3D; head) {&#x2F;&#x2F;如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的<br> 9                 int r &#x3D; tryAcquireShared(arg);&#x2F;&#x2F;尝试获取资源<br>10                 if (r &gt;&#x3D; 0) {&#x2F;&#x2F;成功<br>11                     setHeadAndPropagate(node, r);&#x2F;&#x2F;将head指向自己，还有剩余资源可以再唤醒之后的线程<br>12                     p.next &#x3D; null; &#x2F;&#x2F; help GC<br>13                     if (interrupted)&#x2F;&#x2F;如果等待过程中被打断过，此时将中断补上。<br>14                         selfInterrupt();<br>15                     failed &#x3D; false;<br>16                     return;<br>17                 }<br>18             }<br>19<br>20             &#x2F;&#x2F;判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()<br>21             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>22                 parkAndCheckInterrupt())<br>23                 interrupted &#x3D; true;<br>24         }<br>25     } finally {<br>26         if (failed)<br>27             cancelAcquire(node);<br>28     }<br>29 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</p><p>　　跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p><p>3.3.1.1 setHeadAndPropagate(Node, int)</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void setHeadAndPropagate(Node node, int propagate) {<br> 2     Node h &#x3D; head;<br> 3     setHead(node);&#x2F;&#x2F;head指向自己<br> 4      &#x2F;&#x2F;如果还有剩余量，继续唤醒下一个邻居线程<br> 5     if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0) {<br> 6         Node s &#x3D; node.next;<br> 7         if (s &#x3D;&#x3D; null || s.isShared())<br> 8             doReleaseShared();<br> 9     }<br>10 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p><p>　　doReleaseShared()我们留着下一小节的releaseShared()里来讲。</p><h4 id="3-3-2-小结"><a href="#3-3-2-小结" class="headerlink" title="3.3.2 小结"></a>3.3.2 小结</h4><p>　　OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</p><ol><li><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()&#x2F;interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol></li></ol><p>　　其实跟acquire()的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p><h3 id="3-4-releaseShared"><a href="#3-4-releaseShared" class="headerlink" title="3.4 releaseShared()"></a>3.4 releaseShared()</h3><p>　　上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>1 public final boolean releaseShared(int arg) {<br>2     if (tryReleaseShared(arg)) {&#x2F;&#x2F;尝试释放资源<br>3         doReleaseShared();&#x2F;&#x2F;唤醒后继结点<br>4         return true;<br>5     }<br>6     return false;<br>7 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state&#x3D;0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state&#x3D;0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h4 id="3-4-1-doReleaseShared"><a href="#3-4-1-doReleaseShared" class="headerlink" title="3.4.1 doReleaseShared()"></a>3.4.1 doReleaseShared()</h4><p>　　此方法主要用于唤醒后继。下面是它的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void doReleaseShared() {<br> 2     for (;;) {<br> 3         Node h &#x3D; head;<br> 4         if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) {<br> 5             int ws &#x3D; h.waitStatus;<br> 6             if (ws &#x3D;&#x3D; Node.SIGNAL) {<br> 7                 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br> 8                     continue;<br> 9                 unparkSuccessor(h);&#x2F;&#x2F;唤醒后继<br>10             }<br>11             else if (ws &#x3D;&#x3D; 0 &amp;&amp;<br>12                      !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))<br>13                 continue;<br>14         }<br>15         if (h &#x3D;&#x3D; head)&#x2F;&#x2F; head发生变化<br>16             break;<br>17     }<br>18 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>　　本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()&#x2F;acquireSharedInterruptibly()即是，相应的源码跟acquire()和acquireShared()差不多，这里就不再详解了。</p><h2 id="四、简单应用"><a href="#四、简单应用" class="headerlink" title="四、简单应用"></a>四、简单应用</h2><p>　　通过前边几个章节的学习，相信大家已经基本理解AQS的原理了。这里再将“框架”一节中的一段话复制过来：</p><p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>　　OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。</p><h3 id="4-1-Mutex（互斥锁）"><a href="#4-1-Mutex（互斥锁）" class="headerlink" title="4.1 Mutex（互斥锁）"></a>4.1 Mutex（互斥锁）</h3><p>　　Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 class Mutex implements Lock, java.io.Serializable {<br> 2     &#x2F;&#x2F; 自定义同步器<br> 3     private static class Sync extends AbstractQueuedSynchronizer {<br> 4         &#x2F;&#x2F; 判断是否锁定状态<br> 5         protected boolean isHeldExclusively() {<br> 6             return getState() &#x3D;&#x3D; 1;<br> 7         }<br> 8<br> 9         &#x2F;&#x2F; 尝试获取资源，立即返回。成功则返回true，否则false。<br>10         public boolean tryAcquire(int acquires) {<br>11             assert acquires &#x3D;&#x3D; 1; &#x2F;&#x2F; 这里限定只能为1个量<br>12             if (compareAndSetState(0, 1)) {&#x2F;&#x2F;state为0才设置为1，不可重入！<br>13                 setExclusiveOwnerThread(Thread.currentThread());&#x2F;&#x2F;设置为当前线程独占资源<br>14                 return true;<br>15             }<br>16             return false;<br>17         }<br>18<br>19         &#x2F;&#x2F; 尝试释放资源，立即返回。成功则为true，否则false。<br>20         protected boolean tryRelease(int releases) {<br>21             assert releases &#x3D;&#x3D; 1; &#x2F;&#x2F; 限定为1个量<br>22             if (getState() &#x3D;&#x3D; 0)&#x2F;&#x2F;既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！<br>23                 throw new IllegalMonitorStateException();<br>24             setExclusiveOwnerThread(null);<br>25             setState(0);&#x2F;&#x2F;释放资源，放弃占有状态<br>26             return true;<br>27         }<br>28     }<br>29<br>30     &#x2F;&#x2F; 真正同步类的实现都依赖继承于AQS的自定义同步器！<br>31     private final Sync sync &#x3D; new Sync();<br>32<br>33     &#x2F;&#x2F;lock&lt;–&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。<br>34     public void lock() {<br>35         sync.acquire(1);<br>36     }<br>37<br>38     &#x2F;&#x2F;tryLock&lt;–&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。<br>39     public boolean tryLock() {<br>40         return sync.tryAcquire(1);<br>41     }<br>42<br>43     &#x2F;&#x2F;unlock&lt;–&gt;release。两者语文一样：释放资源。<br>44     public void unlock() {<br>45         sync.release(1);<br>46     }<br>47<br>48     &#x2F;&#x2F;锁是否占有状态<br>49     public boolean isLocked() {<br>50         return sync.isHeldExclusively();<br>51     }<br>52 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</p><p>　　除了Mutex，ReentrantLock&#x2F;CountDownLatch&#x2F;Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</p><p>　　OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</p><ul><li>作者：<a href="http://www.cnblogs.com/waterystone">水岩</a></li><li>出处：<a href="http://www.cnblogs.com/waterystone">http://www.cnblogs.com/waterystone</a></li><li>本博客中未标明转载的文章归作者<a href="http://www.cnblogs.com/waterystone/">水岩</a>和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</li></ul>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>看完这篇ThreadLocal的详解，你也能用得这么溜</title>
    <link href="/2020/07/29/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87ThreadLocal%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%83%BD%E7%94%A8%E5%BE%97%E8%BF%99%E4%B9%88%E6%BA%9C/"/>
    <url>/2020/07/29/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87ThreadLocal%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%83%BD%E7%94%A8%E5%BE%97%E8%BF%99%E4%B9%88%E6%BA%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>张三最近天气很热心情不是很好，所以他决定出去面试跟面试官聊聊天排解一下，结果刚投递简历就有人约了面试。</p><p>我丢，什么情况怎么刚投递出去就有人约我面试了？诶。。。真烦啊，哥已经不在江湖这么久了，江湖还是有哥的传说，我还是这么抢手的么？太烦恼了，帅无罪。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRoc2pyOXI0ajMwNzMwNzNhYTEuanBn?x-oss-process=image/format,png"></p><p>暗自窃喜的张三来到了某东现场面试的办公室，我丢，这面试官？不是吧，这满是划痕的Mac，这发量，难道就是传说中的架构师？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRodXl1bWRhajMwZ28wOGMzeXkuanBn?x-oss-process=image/format,png"></p><p>张三的心态一下子就崩了，出来第一场面试就遇到一个顶级面试官，这谁顶得住啊。</p><p>你好，我是你的面试官Tony，看我的发型应该你能猜到我的身份了，我也话不说，我们直接开始好不好？看你简历写了多线程，来你跟我聊一下ThreadLocal吧，我很久没写代码不太熟悉了，你帮我回忆一下。</p><p>我丢？这TM是人话？这是什么逻辑啊，说是问多线程然后一上来就来个这么冷门的ThreadLocal？心态崩了呀，再说你TM自己忘了不知道下去看看书么，来我这里找答案是什么鬼啊…</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRodnF3M3A5ajMwOGMwOGNteWYuanBn?x-oss-process=image/format,png"></p><p>尽管十分不情愿，但是张三还是高速运转他的小脑袋，回忆起了ThreadLocal的种种细节…</p><p>面试官说实话我在实际开发过程中用到ThreadLocal的地方不是很多，我在写这个文章的时候还刻意去把我电脑上几十个项目打开之后去全局搜索ThreadLocal发现除了系统源码的使用，很少在项目中用到，不过也还是有的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRjc3FkZDcyajMweDIwYWxhYmsuanBn?x-oss-process=image/format,png"></p><p>ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，如何防止自己的变量被其它线程篡改。</p><h4 id="你能跟我说说它隔离有什么用，会用在什么场景么？"><a href="#你能跟我说说它隔离有什么用，会用在什么场景么？" class="headerlink" title="你能跟我说说它隔离有什么用，会用在什么场景么？"></a>你能跟我说说它隔离有什么用，会用在什么场景么？</h4><p>这，我都说了我很少用了，还问我，难受了呀，哦哦哦，有了想起来了，事务隔离级别。</p><p>面试官你好，其实我第一时间想到的就是Spring实现事务隔离级别的源码，这还是当时我大学被女朋友甩了，一个人在图书馆哭泣的时候无意间发现的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRoeTByZXh6ajMwNHgwNTN0OWUuanBn?x-oss-process=image/format,png"></p><p>Spring采用Threadlocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。</p><p>Spring框架里面就是用的ThreadLocal来实现这种隔离，主要是在<code>TransactionSynchronizationManager</code>这个类里面，代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">private static final Log logger = LogFactory.getLog(TransactionSynchronizationManager.class);<br><br>private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =<br>new NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;);<br><br>private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =<br>new NamedThreadLocal&lt;&gt;(&quot;Transaction synchronizations&quot;);<br><br>private static final ThreadLocal&lt;String&gt; currentTransactionName =<br>new NamedThreadLocal&lt;&gt;(&quot;Current transaction name&quot;);<br><br>  ……<br></code></pre></td></tr></table></figure><p>Spring的事务主要是ThreadLocal和AOP去做实现的，我这里提一下，大家知道每个线程自己的链接是靠ThreadLocal保存的就好了，继续的细节我会在Spring章节细说的，暖么？</p><p>除了源码里面使用到ThreadLocal的场景，你自己有使用他的场景么？一般你会怎么用呢？</p><p>来了来了，加分项来了，这个我还真遇到过，装B的机会终于来了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRoenV3cW96ajMwODcwNjRxMnguanBn?x-oss-process=image/format,png"></p><p>有的有的面试官，这个我会！！！</p><p>之前我们上线后发现部分用户的日期居然不对了，排查下来是<code>SimpleDataFormat</code>的锅，当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()，如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。</p><p>其实要解决这个问题很简单，让每个线程都new 一个自己的 <code>SimpleDataFormat</code>就好了，但是1000个线程难道new1000个<code>SimpleDataFormat</code>？</p><p>所以当时我们使用了线程池加上ThreadLocal包装<code>SimpleDataFormat</code>，再调用initialValue让每个线程有一个<code>SimpleDataFormat</code>的副本，从而解决了线程安全的问题，也提高了性能。</p><h4 id="那……"><a href="#那……" class="headerlink" title="那……"></a>那……</h4><p>还有还有，我还有，您别着急问下一个，让我再加点分，拖延一下面试时间。</p><p>我在项目中存在一个线程经常遇到横跨若干方法调用，需要传递的对象，也就是上下文（Context），它是一种状态，经常就是是用户身份、任务信息等，就会存在过渡传参的问题。</p><p>使用到类似责任链模式，给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，对象参数就传不进去了，所以我使用到了ThreadLocal去做了一下改造，这样只需要在调用前在ThreadLocal中设置参数，其他地方get一下就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs auto">before<br>  <br>void work(User user) &#123;<br>    getInfo(user);<br>    checkInfo(user);<br>    setSomeThing(user);<br>    log(user);<br>&#125;<br><br>then<br>  <br>void work(User user) &#123;<br>try&#123;<br>  threadLocalUser.set(user);<br>  // 他们内部  User u = threadLocalUser.get(); 就好了<br>    getInfo();<br>    checkInfo();<br>    setSomeThing();<br>    log();<br>    &#125; finally &#123;<br>     threadLocalUser.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我看了一下很多场景的cookie，session等数据隔离都是通过ThreadLocal去做实现的。</li></ul><p>对了我面试官允许我再秀一下知识广度，在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();<br>private static void prepare(boolean quitAllowed) &#123;<br>    if (sThreadLocal.get() != null) &#123;<br>        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);<br>    &#125;<br>    sThreadLocal.set(new Looper(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>面试官：我丢，这货怎么知道这么多场景？还把Android都扯了出来，不是吧阿sir，下面我要考考他原理了。</p><p>嗯嗯，你回答得很好，那你能跟我说说他底层实现的原理么？</p><p>好的面试官，我先说一下他的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadLocal&lt;String&gt; localName = new ThreadLocal();<br>localName.set(&quot;张三&quot;);<br>String name = localName.get();<br>localName.remove();<br></code></pre></td></tr></table></figure><p>其实使用真的很简单，线程进来之后初始化一个可以泛型的ThreadLocal对象，之后这个线程只要在remove之前去get，都能拿到之前set的值，注意这里我说的是remove之前。</p><p>他是能做到线程间数据隔离的，所以别的线程使用get（）方法是没办法拿到其他线程的值的，但是有办法可以做到，我后面会说。</p><p>我们先看看他set的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs auto">public void set(T value) &#123;<br>    Thread t = Thread.currentThread();// 获取当前线程<br>    ThreadLocalMap map = getMap(t);// 获取ThreadLocalMap对象<br>    if (map != null) // 校验对象是否为空<br>        map.set(this, value); // 不为空set<br>    else<br>        createMap(t, value); // 为空创建一个map对象<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可以发现set的源码很简单，主要就是ThreadLocalMap我们需要关注一下，而ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadLocalMap getMap(Thread t) &#123;<br>        return t.threadLocals;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class Thread implements Runnable &#123;<br>      ……<br><br>    /* ThreadLocal values pertaining to this thread. This map is maintained<br>     * by the ThreadLocal class. */<br>    ThreadLocal.ThreadLocalMap threadLocals = null;<br><br>    /*<br>     * InheritableThreadLocal values pertaining to this thread. This map is<br>     * maintained by the InheritableThreadLocal class.<br>     */<br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;<br>  <br>     ……<br></code></pre></td></tr></table></figure><p>这里我们基本上可以找到ThreadLocal数据隔离的真相了，每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。</p><h4 id="ThreadLocalMap底层结构是怎么样子的呢？"><a href="#ThreadLocalMap底层结构是怎么样子的呢？" class="headerlink" title="ThreadLocalMap底层结构是怎么样子的呢？"></a>ThreadLocalMap底层结构是怎么样子的呢？</h4><p>面试官这个问题问得好啊，内心暗骂，让我歇一会不行么？</p><p>张三笑着回答道，既然有个Map那他的数据结构其实是很像HashMap的，但是看源码可以发现，它并未实现Map接口，而且他的Entry是继承WeakReference（弱引用）的，也没有看到HashMap中的next，所以不存在链表了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">static class ThreadLocalMap &#123;<br><br>        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            /** The value associated with this ThreadLocal. */<br>            Object value;<br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                super(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>        ……<br>    &#125;    <br></code></pre></td></tr></table></figure><p>结构大概长这样：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRmeTZndncwajMwdzAwOTNqc3UuanBn?x-oss-process=image/format,png"></p><h4 id="稍等，我有两个疑问你可以解答一下么？"><a href="#稍等，我有两个疑问你可以解答一下么？" class="headerlink" title="稍等，我有两个疑问你可以解答一下么？"></a>稍等，我有两个疑问你可以解答一下么？</h4><p>好呀，面试官你说。</p><h4 id="为什么需要数组呢？没有了链表怎么解决Hash冲突呢？"><a href="#为什么需要数组呢？没有了链表怎么解决Hash冲突呢？" class="headerlink" title="为什么需要数组呢？没有了链表怎么解决Hash冲突呢？"></a>为什么需要数组呢？没有了链表怎么解决Hash冲突呢？</h4><p>用数组是因为，我们开发过程中可以一个线程可以有多个TreadLocal来存放不同类型的对象的，但是他们都将放到你当前线程的ThreadLocalMap里，所以肯定要数组来存。</p><p>至于Hash冲突，我们先看一下源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs auto">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;<br>           Entry[] tab = table;<br>            int len = tab.length;<br>            int i = key.threadLocalHashCode &amp; (len-1);<br>            for (Entry e = tab[i];<br>                 e != null;<br>                 e = tab[i = nextIndex(i, len)]) &#123;<br>                ThreadLocal&lt;?&gt; k = e.get();<br><br>                if (k == key) &#123;<br>                    e.value = value;<br>                    return;<br>                &#125;<br>                if (k == null) &#123;<br>                    replaceStaleEntry(key, value, i);<br>                    return;<br>                &#125;<br>            &#125;<br>            tab[i] = new Entry(key, value);<br>            int sz = ++size;<br>            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>                rehash();<br>        &#125;<br></code></pre></td></tr></table></figure><p>我从源码里面看到ThreadLocalMap在存储的时候会给每一个ThreadLocal对象一个threadLocalHashCode，在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，**int i &#x3D; key.threadLocalHashCode &amp; (len-1)**。</p><p>然后会判断一下：如果当前位置是空的，就初始化一个Entry对象放在位置i上；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">if (k == null) &#123;<br>    replaceStaleEntry(key, value, i);<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果位置i不为空，如果这个Entry对象的key正好是即将设置的key，那么就刷新Entry中的value；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">if (k == key) &#123;<br>    e.value = value;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果位置i的不为空，而且key不等于entry，那就找下一个空位置，直到为空为止。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRpcGM4MGhmajMwdzEwaHVnbzUuanBn?x-oss-process=image/format,png"></p><p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置，set和get如果冲突严重的话，效率还是很低的。</p><p>以下是get的源码，是不是就感觉很好懂了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs auto"> private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;<br>            int i = key.threadLocalHashCode &amp; (table.length - 1);<br>            Entry e = table[i];<br>            if (e != null &amp;&amp; e.get() == key)<br>                return e;<br>            else<br>                return getEntryAfterMiss(key, i, e);<br>        &#125;<br><br> private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;<br>            Entry[] tab = table;<br>            int len = tab.length;<br>// get的时候一样是根据ThreadLocal获取到table的i值，然后查找数据拿到后会对比key是否相等  if (e != null &amp;&amp; e.get() == key)。<br>            while (e != null) &#123;<br>                ThreadLocal&lt;?&gt; k = e.get();<br>              // 相等就直接返回，不相等就继续查找，找到相等位置。<br>                if (k == key)<br>                    return e;<br>                if (k == null)<br>                    expungeStaleEntry(i);<br>                else<br>                    i = nextIndex(i, len);<br>                e = tab[i];<br>            &#125;<br>            return null;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="能跟我说一下对象存放在哪里么？"><a href="#能跟我说一下对象存放在哪里么？" class="headerlink" title="能跟我说一下对象存放在哪里么？"></a>能跟我说一下对象存放在哪里么？</h4><p>在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，而堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。</p><h4 id="那么是不是说ThreadLocal的实例以及其值存放在栈上呢？"><a href="#那么是不是说ThreadLocal的实例以及其值存放在栈上呢？" class="headerlink" title="那么是不是说ThreadLocal的实例以及其值存放在栈上呢？"></a>那么是不是说ThreadLocal的实例以及其值存放在栈上呢？</h4><p>其实不是的，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有），而ThreadLocal的值其实也是被线程实例持有，它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</p><h4 id="如果我想共享线程的ThreadLocal数据怎么办？"><a href="#如果我想共享线程的ThreadLocal数据怎么办？" class="headerlink" title="如果我想共享线程的ThreadLocal数据怎么办？"></a>如果我想共享线程的ThreadLocal数据怎么办？</h4><p>使用<code>InheritableThreadLocal</code>可以实现多个线程访问ThreadLocal的值，我们在主线程中创建一个<code>InheritableThreadLocal</code>的实例，然后在子线程中得到这个<code>InheritableThreadLocal</code>实例设置的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">private void test() &#123;    <br>final ThreadLocal threadLocal = new InheritableThreadLocal();       <br>threadLocal.set(&quot;帅得一匹&quot;);    <br>Thread t = new Thread() &#123;        <br>    @Override        <br>    public void run() &#123;            <br>      super.run();            <br>      Log.i( &quot;张三帅么 =&quot; + threadLocal.get());        <br>    &#125;    <br>  &#125;;          <br>  t.start(); <br>&#125; <br></code></pre></td></tr></table></figure><p>在子线程中我是能够正常输出那一行日志的，这也是我之前面试视频提到过的父子线程数据传递的问题。</p><h4 id="怎么传递的呀？"><a href="#怎么传递的呀？" class="headerlink" title="怎么传递的呀？"></a>怎么传递的呀？</h4><p>传递的逻辑很简单，我在开头Thread代码提到threadLocals的时候，你们再往下看看我刻意放了另外一个变量：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRncnE5YnhxajMwb28wYmNxNG4uanBn?x-oss-process=image/format,png"></p><p>Thread源码中，我们看看Thread.init初始化创建的时候做了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class Thread implements Runnable &#123;<br>  ……<br>   if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)<br>      this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br>  ……<br>&#125;<br></code></pre></td></tr></table></figure><p>我就截取了部分代码，如果线程的<code>inheritThreadLocals</code>变量不为空，比如我们上面的例子，而且父线程的<code>inheritThreadLocals</code>也存在，那么我就把父线程的<code>inheritThreadLocals</code>给当前线程的<code>inheritThreadLocals</code>。</p><p>是不是很有意思？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRrcjV1NjQ5ajMwNHcwNThteGUuanBn?x-oss-process=image/format,png"></p><p>小伙子你懂的确实很多，那你算是一个深度的ThreadLocal用户了，你发现ThreadLocal的问题了么？</p><p>你是说内存泄露么？</p><p>我丢，这小子为啥知道我要问什么？嗯嗯对的，你说一下。</p><p>这个问题确实会存在的，我跟大家说一下为什么，还记得我上面的代码么？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRta3g4dXBqajMwanowNm03NHUuanBn?x-oss-process=image/format,png"></p><p>ThreadLocal在保存的时候会把自己当做Key存在ThreadLocalMap中，正常情况应该是key和value都应该被外界强引用才对，但是现在key被设计成WeakReference弱引用了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRuaDh2M2hhajMwdzEwYmJhYnIuanBn?x-oss-process=image/format,png"></p><p>我先给大家介绍一下弱引用：</p><blockquote><p>只具有弱引用的对象拥有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><p>不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote><p>这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p>就比如线程池里面的线程，线程都是复用的，那么之前的线程实例处理完之后，出于复用的目的线程依然存活，所以，ThreadLocal设定的value值被持有，导致内存泄露。</p><p>按照道理一个线程使用完，ThreadLocalMap是应该要被清空的，但是现在线程被复用了。</p><h4 id="那怎么解决？"><a href="#那怎么解决？" class="headerlink" title="那怎么解决？"></a>那怎么解决？</h4><p>在代码的最后使用remove就好了，我们只要记得在使用的最后用remove把值清空就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadLocal&lt;String&gt; localName = new ThreadLocal();<br>try &#123;<br>    localName.set(&quot;张三&quot;);<br>    ……<br>&#125; finally &#123;<br>    localName.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>remove的源码很简单，找到对应的值全部置空，这样在垃圾回收器回收的时候，会自动把他们回收掉。</p><h4 id="那为什么ThreadLocalMap的key要设计成弱引用？"><a href="#那为什么ThreadLocalMap的key要设计成弱引用？" class="headerlink" title="那为什么ThreadLocalMap的key要设计成弱引用？"></a>那为什么ThreadLocalMap的key要设计成弱引用？</h4><p>key不设置成弱引用的话就会造成和entry中value一样内存泄漏的场景。</p><p>补充一点：ThreadLocal的不足，我觉得可以通过看看netty的fastThreadLocal来弥补，大家有兴趣可以康康。</p><p>好了，你不仅把我问的都回答了，我不知道的你甚至都说了，ThreadLocal你过关了，不过JUC的面试才刚刚开始，希望你以后越战越勇，最后拿个好offer哟。</p><p>什么鬼，突然这么煽情，不是很为难我的么?难道是为了锻炼我？难为大师这样为我着想，我还一直心里暗骂他，不说了回去好好学了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实ThreadLocal用法很简单，里面的方法就那几个，算上注释源码都没多少行，我用了十多分钟就过了一遍了，但是在我深挖每一个方法背后逻辑的时候，也让我不得不感慨Josh Bloch 和 Doug Lea的厉害之处。</p><p>在细节设计的处理其实往往就是我们和大神的区别，我认为很多不合理的点，在Google和自己不断深入了解之后才发现这才是合理，真的不服不行。</p><p>ThreadLocal是多线程里面比较冷门的一个类，使用频率比不上别的方法和类，但是通过我这篇文章，不知道你是否有新的认知呢？</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized四种锁状态的升级</title>
    <link href="/2020/07/10/synchronized%E5%9B%9B%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%87%E7%BA%A7/"/>
    <url>/2020/07/10/synchronized%E5%9B%9B%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%87%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>在 Java 语言中，使用 Synchronized 是能够实现线程同步的，即<strong>加锁</strong>。并且实现的是<strong>悲观锁</strong>，在操作同步资源的时候直接先加锁。</p><p>加锁可以使一段代码在同一时间只有一个线程可以访问，在增加安全性的同时，牺牲掉的是程序的执行性能，所以为了在一定程度上减少获得锁和释放锁带来的性能消耗，在 jdk6 之后便引入了“偏向锁”和“轻量级锁”，所以总共有4种锁状态，级别由低到高依次为：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>。这几个状态会随着竞争情况逐渐升级。</p><p>注意：锁可以升级但不能降级。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjUzODk1Mi04OTVmMDE1Yjc2YzJlNjA0LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93LzEwMjQvZm9ybWF0L3dlYnA?x-oss-process=image/format,png"></p><p>锁状态说明及升级图示</p><p>当然了，在谈这四种状态之前，我们还是有必要再简单了解下 synchronized 的原理。</p><p>在使用 synchronized 来同步代码块的时候，经编译后，会在代码块的起始位置插入 <strong>monitorenter指令</strong>，在结束或异常处插入 <strong>monitorexit指令。</strong>当执行到 monitorenter 指令时，将会尝试获取对象所对应的 **monitor **的所有权，即尝试获得对象的锁。而 synchronized 用的锁是存放在 <strong>Java对象头</strong> 中的。</p><p>所以引出了两个关键词：“Java 对象头” 和 “Monitor”。</p><h3 id="二、Java-对象头和-Monitor"><a href="#二、Java-对象头和-Monitor" class="headerlink" title="二、Java 对象头和 Monitor"></a>二、Java 对象头和 Monitor</h3><p>1、Java 对象头</p><p>我们以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>2、Monitor</p><p>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。</p><p>Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><h3 id="三、无锁"><a href="#三、无锁" class="headerlink" title="三、无锁"></a>三、无锁</h3><p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><h3 id="四、偏向锁"><a href="#四、偏向锁" class="headerlink" title="四、偏向锁"></a>四、偏向锁</h3><p>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p>关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p><p>偏向锁在 JDK 6 及之后版本的 JVM 里是默认启用的。可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false，关闭之后程序默认会进入轻量级锁状态。</p><h3 id="五、轻量级锁"><a href="#五、轻量级锁" class="headerlink" title="五、轻量级锁"></a>五、轻量级锁</h3><p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。</p><p>轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机将首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后将对象头中的 Mark Word 复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p><p>另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p><h3 id="六、重量级锁"><a href="#六、重量级锁" class="headerlink" title="六、重量级锁"></a>六、重量级锁</h3><p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</p><p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。</p><h3 id="七、关于自旋"><a href="#七、关于自旋" class="headerlink" title="七、关于自旋"></a>七、关于自旋</h3><p>关于自旋，简言之就是让线程喝杯咖啡小憩一下，用代码解释就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">do  &#123;<br>    // do something<br>&#125;  while  (自旋的规则，或者说自旋的次数)<br></code></pre></td></tr></table></figure><p>引入自旋这一规则的原因其实也很简单，因为阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。并且在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，这部分操作的开销其实是得不偿失的。</p><p>所以，在物理机器有多个处理器的情况下，当两个或以上的线程同时并行执行时，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋。如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。</p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</p><p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用 -XX:PreBlockSpin 来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>偏向锁通过对比 Mark Word 解决加锁问题，避免执行CAS操作。</p><p>轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</p><p>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch怎么使用？一个简单的Demo与使用注意事项</title>
    <link href="/2020/07/09/CountDownLatch%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Demo%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2020/07/09/CountDownLatch%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Demo%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch怎么使用？一个简单的Demo与使用注意事项"><a href="#CountDownLatch怎么使用？一个简单的Demo与使用注意事项" class="headerlink" title="CountDownLatch怎么使用？一个简单的Demo与使用注意事项"></a>CountDownLatch怎么使用？一个简单的Demo与使用注意事项</h2><p>最新推荐文章于 2023-06-18 15:11:40 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p>置顶 <a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-06-18 15:11:40 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在工作中，大家应该比较少用到CountDownLatch，但是CountDownLatch在面试中或者多线程的相关知识点面试中还是经常被问到，所以这次跟大家复习一下CountDownLatch的简单使用。</p><h3 id="什么是CountDownLatch-线程计数器"><a href="#什么是CountDownLatch-线程计数器" class="headerlink" title="什么是CountDownLatch(线程计数器 )"></a>什么是CountDownLatch(线程计数器 )</h3><p>CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有</p><p>一个任务 A，它要等待其他 2 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch</p><p>来实现这种功能了。</p><h3 id="怎么使用CountDownLatch"><a href="#怎么使用CountDownLatch" class="headerlink" title="怎么使用CountDownLatch"></a>怎么使用CountDownLatch</h3><h4 id="以下讲解我会先放上正确的使用Demo，后面再讲一些理解的地方和错误的使用："><a href="#以下讲解我会先放上正确的使用Demo，后面再讲一些理解的地方和错误的使用：" class="headerlink" title="以下讲解我会先放上正确的使用Demo，后面再讲一些理解的地方和错误的使用："></a>以下讲解我会先放上正确的使用Demo，后面再讲一些理解的地方和错误的使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;main方法开始&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(n);<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool(Executors.defaultThreadFactory());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;启动了&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;搞定了&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125;<br><br>            ;<br>        &#125;.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;启动了&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;搞定了&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125;<br><br>            ;<br>        &#125;.start();<br>        <span class="hljs-comment">//注意加上这句 否则你这个CountDownLatch相当于没用 等待n个线程执行完毕 加入没有达到n个就会堵塞</span><br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;main方法继续&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="执行结果是"><a href="#执行结果是" class="headerlink" title="执行结果是"></a>执行结果是</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/20200709155555143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></h4><h4 id="首先，主方法中的这句countDownLatch-await-很多人会漏掉，这句方法的底层代码是调用了Unsafe类的park（）方法，也就是说调用了操作系统的线程挂起方法："><a href="#首先，主方法中的这句countDownLatch-await-很多人会漏掉，这句方法的底层代码是调用了Unsafe类的park（）方法，也就是说调用了操作系统的线程挂起方法：" class="headerlink" title="首先，主方法中的这句countDownLatch.await(); 很多人会漏掉，这句方法的底层代码是调用了Unsafe类的park（）方法，也就是说调用了操作系统的线程挂起方法："></a>首先，主方法中的这句countDownLatch.await(); 很多人会漏掉，这句方法的底层代码是调用了Unsafe类的park（）方法，也就是说调用了操作系统的线程挂起方法：</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/20200709154456534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></h4><h4 id="当你把countDownLatch-await-注释后，你会观察到执行结果是："><a href="#当你把countDownLatch-await-注释后，你会观察到执行结果是：" class="headerlink" title="当你把countDownLatch.await(); 注释后，你会观察到执行结果是："></a>当你把countDownLatch.await(); 注释后，你会观察到执行结果是：</h4><p><img src="https://img-blog.csdnimg.cn/20200709155627212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h3 id="从执行结果可以得出，在子线程执行完之前主线程已经在继续执行，所以CountDowLatch并没有起效，这个就是普通的多线程执行结果，并没有出现主线程等待到n个子线程执行完毕才继续执行的结果"><a href="#从执行结果可以得出，在子线程执行完之前主线程已经在继续执行，所以CountDowLatch并没有起效，这个就是普通的多线程执行结果，并没有出现主线程等待到n个子线程执行完毕才继续执行的结果" class="headerlink" title="从执行结果可以得出，在子线程执行完之前主线程已经在继续执行，所以CountDowLatch并没有起效，这个就是普通的多线程执行结果，并没有出现主线程等待到n个子线程执行完毕才继续执行的结果"></a>从执行结果可以得出，在子线程执行完之前主线程已经在继续执行，所以CountDowLatch并没有起效，这个就是普通的多线程执行结果，并没有出现主线程等待到n个子线程执行完毕才继续执行的结果</h3><h3 id="第二个容易忽略的地方就是CountDownLatch的计数器数量，也就是代码中构造函数中的n的值，假如你的代码中子线程的总数并没有达到这个值或者没有执行countDownLatch-countDown-这条语句，那么你的主线程将一直等待，（原本他在等待n个子线程执行完毕，可是并没有n个子线程）"><a href="#第二个容易忽略的地方就是CountDownLatch的计数器数量，也就是代码中构造函数中的n的值，假如你的代码中子线程的总数并没有达到这个值或者没有执行countDownLatch-countDown-这条语句，那么你的主线程将一直等待，（原本他在等待n个子线程执行完毕，可是并没有n个子线程）" class="headerlink" title="第二个容易忽略的地方就是CountDownLatch的计数器数量，也就是代码中构造函数中的n的值，假如你的代码中子线程的总数并没有达到这个值或者没有执行countDownLatch.countDown();这条语句，那么你的主线程将一直等待，（原本他在等待n个子线程执行完毕，可是并没有n个子线程）"></a>第二个容易忽略的地方就是CountDownLatch的计数器数量，也就是代码中构造函数中的n的值，假如你的代码中子线程的总数并没有达到这个值或者没有执行countDownLatch.countDown();这条语句，那么你的主线程将一直等待，（原本他在等待n个子线程执行完毕，可是并没有n个子线程）</h3><h3 id="当把第二个线程注释掉："><a href="#当把第二个线程注释掉：" class="headerlink" title="当把第二个线程注释掉："></a>当把第二个线程注释掉：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;main方法开始&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(n);<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool(Executors.defaultThreadFactory());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;启动了&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;搞定了&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125;<br><br>            ;<br>        &#125;.start();<br><span class="hljs-comment">//        new Thread() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void run() &#123;</span><br><span class="hljs-comment">//                System.out.println(Thread.currentThread().getName() + &quot;启动了&quot;);</span><br><span class="hljs-comment">//                try &#123;</span><br><span class="hljs-comment">//                    Thread.sleep(1000);</span><br><span class="hljs-comment">//                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                    e.printStackTrace();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                System.out.println(Thread.currentThread().getName() + &quot;搞定了&quot;);</span><br>                countDownLatch.countDown();<br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//            ;</span><br><span class="hljs-comment">//        &#125;.start();</span><br>        <span class="hljs-comment">//注意加上这句 否则你这个CountDownLatch相当于没用 等待n个线程执行完毕 加入没有达到n个就会堵塞</span><br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;main方法继续&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200709160746896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h3 id="从执行结果可以得出，主线程一直在等待，System-out-println-“main方法继续”-并没有执行，说明程序并没有结束。"><a href="#从执行结果可以得出，主线程一直在等待，System-out-println-“main方法继续”-并没有执行，说明程序并没有结束。" class="headerlink" title="从执行结果可以得出，主线程一直在等待，System.out.println(“main方法继续”);并没有执行，说明程序并没有结束。"></a>从执行结果可以得出，主线程一直在等待，System.out.println(“main方法继续”);并没有执行，说明程序并没有结束。</h3><h3 id="第二种情况，我们只注释-countDownLatch-countDown"><a href="#第二种情况，我们只注释-countDownLatch-countDown" class="headerlink" title="第二种情况，我们只注释 countDownLatch.countDown();"></a>第二种情况，我们只注释 countDownLatch.countDown();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;main方法开始&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(n);<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool(Executors.defaultThreadFactory());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;启动了&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;搞定了&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125;<br><br>            ;<br>        &#125;.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;启动了&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;搞定了&quot;</span>);<br><span class="hljs-comment">//                countDownLatch.countDown();</span><br>            &#125;;<br>        &#125;.start();<br>        <span class="hljs-comment">//注意加上这句 否则你这个CountDownLatch相当于没用 等待n个线程执行完毕 加入没有达到n个就会堵塞</span><br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;main方法继续&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h4><p><img src="https://img-blog.csdnimg.cn/20200709161151646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="执行结果跟上面一样，主线程一直在等待，System-out-println-“main方法继续”-并没有执行，说明程序并没有结束。"><a href="#执行结果跟上面一样，主线程一直在等待，System-out-println-“main方法继续”-并没有执行，说明程序并没有结束。" class="headerlink" title="执行结果跟上面一样，主线程一直在等待，System.out.println(“main方法继续”);并没有执行，说明程序并没有结束。"></a>执行结果跟上面一样，主线程一直在等待，System.out.println(“main方法继续”);并没有执行，说明程序并没有结束。</h4><h4 id="下次我将介绍一个与他相似的“兄弟”——CyclicBarrier"><a href="#下次我将介绍一个与他相似的“兄弟”——CyclicBarrier" class="headerlink" title="下次我将介绍一个与他相似的“兄弟”——CyclicBarrier"></a>下次我将介绍一个与他相似的“兄弟”——CyclicBarrier</h4>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！</title>
    <link href="/2020/07/09/HashMap%EF%BC%9FConcurrentHashMap%EF%BC%9F%E7%9B%B8%E4%BF%A1%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%B2%A1%E4%BA%BA%E8%83%BD%E9%9A%BE%E4%BD%8F%E4%BD%A0%EF%BC%81/"/>
    <url>/2020/07/09/HashMap%EF%BC%9FConcurrentHashMap%EF%BC%9F%E7%9B%B8%E4%BF%A1%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%B2%A1%E4%BA%BA%E8%83%BD%E9%9A%BE%E4%BD%8F%E4%BD%A0%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p><p>本篇主要想讨论 ConcurrentHashMap 这样一个并发容器，在正式开始之前我觉得有必要谈谈 HashMap，没有它就不会有后面的 ConcurrentHashMap。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>众所周知 HashMap 底层是基于 <code>数组 + 链表</code> 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><h4 id="Base-1-7"><a href="#Base-1-7" class="headerlink" title="Base 1.7"></a>Base 1.7</h4><p>1.7 中的数据结构图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJtWVl0ZjBYREJNalFUNTVaV1I2Z0tuZVZjdThEVGJFdTlOcGZzMEVGMkhCWjc3UWliSEtsd1lBLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png" alt="640?wx_fmt=jpeg"></p><p>先来看看 1.7 中的实现。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJDWUphUlJjNjhOcHQ4M0lOZjZ4VEJkRGt4UTVxT2VrUUtYMGZEb2ZxMjJoa21wZjBaMXpNNEEvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？</p><ol><li><p>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</p></li><li><p>桶最大值。</p></li><li><p>默认的负载因子（0.75）</p></li><li><p><code>table</code> 真正存放数据的数组。</p></li><li><p><code>Map</code> 存放数量的大小。</p></li><li><p>桶大小，可在初始化时显式指定。</p></li><li><p>负载因子，可在初始化时显式指定。</p></li></ol><p>重点解释下负载因子：</p><p>由于给定的 HashMap 的容量大小是固定的，比如默认初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    public HashMap() &#123;<br> 2        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);<br> 3    &#125;<br> 4<br> 5    public HashMap(int initialCapacity, float loadFactor) &#123;<br> 6        if (initialCapacity &lt; 0)<br> 7            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +<br> 8                                               initialCapacity);<br> 9        if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>10            initialCapacity = MAXIMUM_CAPACITY;<br>11        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))<br>12            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +<br>13                                               loadFactor);<br>14<br>15        this.loadFactor = loadFactor;<br>16        threshold = initialCapacity;<br>17        init();<br>18    &#125;<br></code></pre></td></tr></table></figure><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 <code>16 * 0.75 = 12</code> 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><p>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。</p><p>根据代码可以看到其实真正存放数据的是</p><p><code>transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code></p><p>这个数组，那么它又是如何定义的呢？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJIY21LR2ViU21KTnJNUG96NUlzd1N1b2RySEVHeGU3c2dhYWVlVDhxMktFOE1BT1A4bmljcm5BLzY0MD93eF9mbXQ9cG5n?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p><ul><li><p>key 就是写入时的键。</p></li><li><p>value 自然就是值。</p></li><li><p>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。</p></li><li><p>hash 存放的是当前 key 的 hashcode。</p></li></ul><p>知晓了基本结构，那来看看其中重要的写入、获取函数：</p><p>put 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    public V put(K key, V value) &#123;<br> 2        if (table == EMPTY_TABLE) &#123;<br> 3            inflateTable(threshold);<br> 4        &#125;<br> 5        if (key == null)<br> 6            return putForNullKey(value);<br> 7        int hash = hash(key);<br> 8        int i = indexFor(hash, table.length);<br> 9        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;<br>10            Object k;<br>11            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>12                V oldValue = e.value;<br>13                e.value = value;<br>14                e.recordAccess(this);<br>15                return oldValue;<br>16            &#125;<br>17        &#125;<br>18<br>19        modCount++;<br>20        addEntry(hash, key, value, i);<br>21        return null;<br>22    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>判断当前数组是否需要初始化。</p></li><li><p>如果 key 为空，则 put 一个空值进去。</p></li><li><p>根据 key 计算出 hashcode。</p></li><li><p>根据计算出的 hashcode 定位出所在桶。</p></li><li><p>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</p></li><li><p>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    void addEntry(int hash, K key, V value, int bucketIndex) &#123;<br> 2        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;<br> 3            resize(2 * table.length);<br> 4            hash = (null != key) ? hash(key) : 0;<br> 5            bucketIndex = indexFor(hash, table.length);<br> 6        &#125;<br> 7<br> 8        createEntry(hash, key, value, bucketIndex);<br> 9    &#125;<br>10<br>11    void createEntry(int hash, K key, V value, int bucketIndex) &#123;<br>12        Entry&lt;K,V&gt; e = table[bucketIndex];<br>13        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);<br>14        size++;<br>15    &#125;<br></code></pre></td></tr></table></figure><p>当调用 addEntry 写入 Entry 时需要判断是否需要扩容。</p><p>如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。</p><p>而在 <code>createEntry</code> 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。</p><p>get 方法</p><p>再来看看 get 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    public V get(Object key) &#123;<br> 2        if (key == null)<br> 3            return getForNullKey();<br> 4        Entry&lt;K,V&gt; entry = getEntry(key);<br> 5<br> 6        return null == entry ? null : entry.getValue();<br> 7    &#125;<br> 8<br> 9    final Entry&lt;K,V&gt; getEntry(Object key) &#123;<br>10        if (size == 0) &#123;<br>11            return null;<br>12        &#125;<br>13<br>14        int hash = (key == null) ? 0 : hash(key);<br>15        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];<br>16             e != null;<br>17             e = e.next) &#123;<br>18            Object k;<br>19            if (e.hash == hash &amp;&amp;<br>20                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>21                return e;<br>22        &#125;<br>23        return null;<br>24    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。</p></li><li><p>判断该位置是否为链表。</p></li><li><p>不是链表就根据 <code>key、key 的 hashcode</code> 是否相等来返回值。</p></li><li><p>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。</p></li><li><p>啥都没取到就直接返回 null 。</p></li></ul><h4 id="Base-1-8"><a href="#Base-1-8" class="headerlink" title="Base 1.8"></a>Base 1.8</h4><p>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是：</p><blockquote><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p></blockquote><p>因此 1.8 中重点优化了这个查询效率。</p><p>1.8 HashMap 结构图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJjODF0ZkFzRGIwRmRqekhrQlJ1NGpYUmdMY28wYURQWFFYT3FUaWFtRkw5ZU90QzBnNVJ1d1l3LzY0MD93eF9mbXQ9cG5n?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>先来看看几个核心的成员变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16<br> 2<br> 3    /**<br> 4     * The maximum capacity, used if a higher value is implicitly specified<br> 5     * by either of the constructors with arguments.<br> 6     * MUST be a power of two &lt;= 1&lt;&lt;30.<br> 7     */<br> 8    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;<br> 9<br>10    /**<br>11     * The load factor used when none specified in constructor.<br>12     */<br>13    static final float DEFAULT_LOAD_FACTOR = 0.75f;<br>14<br>15    static final int TREEIFY_THRESHOLD = 8;<br>16<br>17    transient Node&lt;K,V&gt;[] table;<br>18<br>19    /**<br>20     * Holds cached entrySet(). Note that AbstractMap fields are used<br>21     * for keySet() and values().<br>22     */<br>23    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br>24<br>25    /**<br>26     * The number of key-value mappings contained in this map.<br>27     */<br>28    transient int size;<br></code></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><ul><li><p><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</p></li><li><p>HashEntry 修改为 Node。</p></li></ul><p>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p><p>再来看看核心方法。</p><p>put 方法</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJQcXVnVXJYb3pkdFpmOGRzTkFtZE1FcEV1dmxzaWIweW5xdWhGWDI3MURvd2R6T3kwRnNpYWlhaWJnLzY0MD93eF9mbXQ9cG5n?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>看似要比 1.7 的复杂，我们一步步拆解：</p><ol><li><p>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</p></li><li><p>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</p></li><li><p>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 <code>key、key 的 hashcode</code> 与写入的 key 是否相等，相等就赋值给 <code>e</code>,在第 8 步的时候会统一进行赋值及返回。</p></li><li><p>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</p></li><li><p>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</p></li><li><p>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</p></li><li><p>如果在遍历过程中找到 key 相同时直接退出遍历。</p></li><li><p>如果 <code>e != null</code> 就相当于存在相同的 key,那就需要将值覆盖。</p></li><li><p>最后判断是否需要进行扩容。</p></li></ol><p>get 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    public V get(Object key) &#123;<br> 2        Node&lt;K,V&gt; e;<br> 3        return (e = getNode(hash(key), key)) == null ? null : e.value;<br> 4    &#125;<br> 5<br> 6    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;<br> 7        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;<br> 8        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;<br> 9            (first = tab[(n - 1) &amp; hash]) != null) &#123;<br>10            if (first.hash == hash &amp;&amp; // always check first node<br>11                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))<br>12                return first;<br>13            if ((e = first.next) != null) &#123;<br>14                if (first instanceof TreeNode)<br>15                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>16                do &#123;<br>17                    if (e.hash == hash &amp;&amp;<br>18                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>19                        return e;<br>20                &#125; while ((e = e.next) != null);<br>21            &#125;<br>22        &#125;<br>23        return null;<br>24    &#125;<br></code></pre></td></tr></table></figure><p>get 方法看起来就要简单许多了。</p><ul><li><p>首先将 key hash 之后取得所定位的桶。</p></li><li><p>如果桶为空则直接返回 null 。</p></li><li><p>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</p></li><li><p>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</p></li><li><p>红黑树就按照树的查找方式返回值。</p></li><li><p>不然就按照链表的方式遍历匹配返回值。</p></li></ul><p>从这两个核心方法（get&#x2F;put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs auto">1final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<br>2for (int i = 0; i &lt; 1000; i++) &#123;<br>3    new Thread(new Runnable() &#123;<br>4        @Override<br>5        public void run() &#123;<br>6            map.put(UUID.randomUUID().toString(), &quot;&quot;);<br>7        &#125;<br>8    &#125;).start();<br>9&#125;<br></code></pre></td></tr></table></figure><p>但是为什么呢？简单分析下。</p><p>看过上文的还记得在 HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p><p>如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJwV20xQmFoTVNXcGYzaDJzM005aWMyMjRqMURUdktZU0tGVDFUaDZqRHJpYlpiZW9mb1ZMYUg3Zy82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJwV20xQmFoTVNXcGYzaDJzM005aWMyMjRqMURUdktZU0tGVDFUaDZqRHJpYlpiZW9mb1ZMYUg3Zy82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();<br> 2        while (entryIterator.hasNext()) &#123;<br> 3            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();<br> 4            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());<br> 5        &#125;<br> 6<br> 7Iterator&lt;String&gt; iterator = map.keySet().iterator();<br> 8        while (iterator.hasNext())&#123;<br> 9            String key = iterator.next();<br>10            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));<br>11<br>12        &#125;<br></code></pre></td></tr></table></figure><p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。</p><p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><blockquote><p>简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至出现死循环导致系统不可用。</p></blockquote><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code>java.util.concurrent</code> 包下，专门用于解决并发问题。</p><blockquote><p>坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析。</p></blockquote><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 同样也分为 1.7 、1.8 版，两者在实现上略有不同。</p><h4 id="Base-1-7-1"><a href="#Base-1-7-1" class="headerlink" title="Base 1.7"></a>Base 1.7</h4><p>先来看看 1.7 的实现，下面是他的结构图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJtblRTemliUTZWRUJYVWhpY0JXSEZhZTQ3U2hrTnpDUkI3U1ppYnVVTjZnRG1Ha2ZlQjVzYUFNUVEvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p><p>它的核心成员变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">1    /**<br>2     * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。<br>3     */<br>4    final Segment&lt;K,V&gt;[] segments;<br>5<br>6    transient Set&lt;K&gt; keySet;<br>7    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br></code></pre></td></tr></table></figure><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;<br> 2<br> 3        private static final long serialVersionUID = 2249069246763182397L;<br> 4<br> 5        // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶<br> 6        transient volatile HashEntry&lt;K,V&gt;[] table;<br> 7<br> 8        transient int count;<br> 9<br>10        transient int modCount;<br>11<br>12        transient int threshold;<br>13<br>14        final float loadFactor;<br>15<br>16    &#125;<br></code></pre></td></tr></table></figure><p>看看其中 HashEntry 的组成：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJnZXVGdktTdXlpYUljeVFuSWxqRlpJYzFTUmVWSnhJOFdrTk16cHNSakJlT01RVFNCNDYxaWNwQS82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p><p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><p>下面也来看看核心的 <code>put get</code> 方法。</p><p>put 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    public V put(K key, V value) &#123;<br> 2        Segment&lt;K,V&gt; s;<br> 3        if (value == null)<br> 4            throw new NullPointerException();<br> 5        int hash = hash(key);<br> 6        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br> 7        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck<br> 8             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment<br> 9            s = ensureSegment(j);<br>10        return s.put(key, hash, value, false);<br>11    &#125;<br></code></pre></td></tr></table></figure><p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1        final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;<br> 2            HashEntry&lt;K,V&gt; node = tryLock() ? null :<br> 3                scanAndLockForPut(key, hash, value);<br> 4            V oldValue;<br> 5            try &#123;<br> 6                HashEntry&lt;K,V&gt;[] tab = table;<br> 7                int index = (tab.length - 1) &amp; hash;<br> 8                HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br> 9                for (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>10                    if (e != null) &#123;<br>11                        K k;<br>12                        if ((k = e.key) == key ||<br>13                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>14                            oldValue = e.value;<br>15                            if (!onlyIfAbsent) &#123;<br>16                                e.value = value;<br>17                                ++modCount;<br>18                            &#125;<br>19                            break;<br>20                        &#125;<br>21                        e = e.next;<br>22                    &#125;<br>23                    else &#123;<br>24                        if (node != null)<br>25                            node.setNext(first);<br>26                        else<br>27                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);<br>28                        int c = count + 1;<br>29                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>30                            rehash(node);<br>31                        else<br>32                            setEntryAt(tab, index, node);<br>33                        ++modCount;<br>34                        count = c;<br>35                        oldValue = null;<br>36                        break;<br>37                    &#125;<br>38                &#125;<br>39            &#125; finally &#123;<br>40                unlock();<br>41            &#125;<br>42            return oldValue;<br>43        &#125;<br></code></pre></td></tr></table></figure><p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p><p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXI5WmxrOENadDlCcTJHVUZhNGZSN2RJTkFjaWF6WGN0eHdNTFpQMjNLRW5Fc1hpYlVVQmplaDJydy82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><ol><li><p>尝试自旋获取锁。</p></li><li><p>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</p></li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJzdGZBWDZNVXlPVGNaWGhHcUlLZkhuQnloelVOaWNLM2ljb1dmRnZ0aWFPbzY1aWFkTG1tVjl6aFVnLzY0MD93eF9mbXQ9cG5n?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>再结合图看看 put 的流程。</p><ol><li><p>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</p></li><li><p>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</p></li><li><p>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</p></li><li><p>最后会解除在 1 中所获取当前 Segment 的锁。</p></li></ol><p>get 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs auto"> 1    public V get(Object key) &#123;<br> 2        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead<br> 3        HashEntry&lt;K,V&gt;[] tab;<br> 4        int h = hash(key);<br> 5        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br> 6        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;<br> 7            (tab = s.table) != null) &#123;<br> 8            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br> 9                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>10                 e != null; e = e.next) &#123;<br>11                K k;<br>12                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>13                    return e.value;<br>14            &#125;<br>15        &#125;<br>16        return null;<br>17    &#125;<br></code></pre></td></tr></table></figure><p>get 逻辑比较简单：</p><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p><p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p><h4 id="Base-1-8-1"><a href="#Base-1-8-1" class="headerlink" title="Base 1.8"></a>Base 1.8</h4><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。</p><blockquote><p>那就是查询遍历链表效率太低。</p></blockquote><p>因此 1.8 做了一些数据结构上的调整。</p><p>首先来看下底层的组成结构：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXI2aEFqWGpVQlViZW5COUZROUJLWEdRYVEwTTY0UTdIUDlmVFlTS0JXa3JyWmZtc2liZEVjS0RnLzY0MD93eF9mbXQ9cG5n?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>看起来是不是和 1.8 HashMap 结构类似？</p><p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJBbWljRGxRN1NDN1J4a0JpYmRpYlRneW1OZEFiMVM5ZVptcXJjMERGR0VPVm5QbmoyOGJwa1hBaWN3LzY0MD93eF9mbXQ9cG5n?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p><p>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</p><p>put 方法</p><p>重点来看看 put 函数：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXJHUnYzUEVMaWFNNHI2VUdMVUNib2RzR3ZMUFNyVWM2UG1xRGNqNjRKekxqYWtlSDQzcHNjelhnLzY0MD93eF9mbXQ9cG5n?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><ul><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p></li></ul><p>get 方法</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJUGYxc0RDTjV6Y0RkR3NpYlp3eXp5OXIzdmZoc3NmYUhqRmVXUlZDYU91c2s4amhyaE1HNUZRdzNyaWJ0eGFJam1aRTIxNnZoMm5pYkNody82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png" alt="640?wx_fmt=png"></p><ul><li><p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p></li><li><p>如果是红黑树那就按照树的方式获取值。</p></li><li><p>就不满足那就按照链表的方式遍历获取值。</p></li></ul><blockquote><p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看完了整个 HashMap 和 ConcurrentHashMap 在 1.7 和 1.8 中不同的实现方式相信大家对他们的理解应该会更加到位。</p><p>其实这块也是面试的重点内容，通常的套路是：</p><ol><li><p>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</p></li><li><p>1.8 做了什么优化？</p></li><li><p>是线程安全的嘛？</p></li><li><p>不安全会导致哪些问题？</p></li><li><p>如何解决？有没有线程安全的并发容器？</p></li><li><p>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？</p></li></ol><p>这一串问题相信大家仔细看完都能怼回面试官。</p><p>除了面试会问到之外平时的应用其实也蛮多，像之前谈到的 Guava 中 Cache 的实现就是利用 ConcurrentHashMap 的思想。</p><p>同时也能学习 JDK 作者大牛们的优化思路以及并发解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多线程-线程池ThreadPoolExecutor的拒绝策略</title>
    <link href="/2020/06/22/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/"/>
    <url>/2020/06/22/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>本文是我在一篇转载的<a href="https://www.jianshu.com/p/9fec2424de54">文章</a>上加以解释和修改</p><h2 id="首先-什么是ThreadPoolExecutor的拒绝策略"><a href="#首先-什么是ThreadPoolExecutor的拒绝策略" class="headerlink" title="首先,什么是ThreadPoolExecutor的拒绝策略?"></a>首先,什么是ThreadPoolExecutor的拒绝策略?</h2><p>我认为下面这个图足够说明一切,但是如果你连线程池的概念和作用或者ThreadPoolExecutor ExecutorService之类的类都没听说过的话那么我建议你补一下相关知识.</p><p>ThreadPoolExecutor的拒绝策略的发生跟 两个重要的参数 corePoolSize maximumPoolSize 以及等待队列Queue都有关系</p><p><img src="https://img-blog.csdnimg.cn/20200622100155587.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h2 id="在分析ThreadPoolExecutor的构造参数时，有一个RejectedExecutionHandler参数。"><a href="#在分析ThreadPoolExecutor的构造参数时，有一个RejectedExecutionHandler参数。" class="headerlink" title="在分析ThreadPoolExecutor的构造参数时，有一个RejectedExecutionHandler参数。"></a>在分析ThreadPoolExecutor的构造参数时，有一个RejectedExecutionHandler参数。</h2><p>RejectedExecutionHandler是一个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">public interface RejectedExecutionHandler &#123;<br>    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);<br>&#125;<br></code></pre></td></tr></table></figure><p>里面只有一个方法。当要创建的线程数量大于线程池的最大线程数的时候，新的任务就会被拒绝，就会调用这个接口里的这个方法。</p><p>可以自己实现这个接口，实现对这些超出数量的任务的处理。</p><p>ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是<code>CallerRunsPolicy</code>,<code>AbortPolicy</code>,<code>DiscardPolicy</code>,<code>DiscardOldestPolicy</code></p><p>这四个拒绝策略其实一看实现方法就知道很简单。</p><h2 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h2><p>ThreadPoolExecutor中<strong>默认的拒绝策略就是AbortPolicy</strong>。直接抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs auto">private static final RejectedExecutionHandler defaultHandler =<br>    new AbortPolicy();<br></code></pre></td></tr></table></figure><p>下面是他的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs auto">public static class AbortPolicy implements RejectedExecutionHandler &#123;<br>    public AbortPolicy() &#123; &#125;<br>    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;<br>        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +<br>                                             &quot; rejected from &quot; +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很简单粗暴，直接抛出个RejectedExecutionException异常，也不执行这个任务了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>先自定义一个Runnable,给每个线程起个名字，下面都用这个Runnable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs auto">static class MyThread implements Runnable &#123;<br>        String name;<br>        public MyThread(String name) &#123;<br>            this.name = name;<br>        &#125;<br>        @Override<br>        public void run() &#123;<br>            try &#123;<br>                Thread.sleep(2000);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(&quot;线程:&quot;+Thread.currentThread().getName() +&quot; 执行:&quot;+name +&quot;  run&quot;);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后构造一个核心线程是1，最大线程数是2的线程池。拒绝策略是AbortPolicy, <strong>注意队列的大小是2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 0, <br>        TimeUnit.MICROSECONDS, <br>        new LinkedBlockingDeque&lt;Runnable&gt;(2), <br>        new ThreadPoolExecutor.AbortPolicy());<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs auto">for (int i = 0; i &lt; 6; i++) &#123;<br>    System.out.println(&quot;添加第&quot;+i+&quot;个任务&quot;);<br>    executor.execute(new MyThread(&quot;线程&quot;+i));<br>    Iterator iterator = executor.getQueue().iterator();<br>    while (iterator.hasNext())&#123;<br>        MyThread thread = (MyThread) iterator.next();<br>        System.out.println(&quot;列表：&quot;+thread.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出是：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDYyOTQzLTNlZTczYmY0MTg5OTRiZWUucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png"></p><p>分析一下过程。</p><ol><li>添加第一个任务时，直接执行，任务列表为空。</li><li>添加第二个任务时，因为采用的LinkedBlockingDeque，，并且核心线程正在执行任务，所以会将第二个任务放在队列中，队列中有 线程2.</li><li>添加第三个任务时，也一样会放在队列中，队列中有 线程2，线程3.</li><li>添加第四个任务时，因为核心任务还在运行，而且任务队列已经满了，所以胡直接创建新线程执行第四个任务，。这时线程池中一共就有两个线程在运行了，达到了最大线程数。任务队列中还是有线程2， 线程3.</li><li>添加第五个任务时，再也没有地方能存放和执行这个任务了，就会被线程池拒绝添加，执行拒绝策略的rejectedExecution方法，这里就是执行AbortPolicy的rejectedExecution方法直接抛出异常。</li><li>最终，只有四个线程能完成运行。后面的都被拒绝了。</li></ol><h2 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h2><p>CallerRunsPolicy在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。</p><p>下面说他的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs auto">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;<br>    public CallerRunsPolicy() &#123; &#125;<br>    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;<br>        if (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也很简单，直接run。</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30,<br>        TimeUnit.SECONDS,<br>        new LinkedBlockingDeque&lt;Runnable&gt;(2),<br>        new ThreadPoolExecutor.AbortPolicy());<br></code></pre></td></tr></table></figure><p>按上面的运行，输出</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDYyOTQzLTY4YTQ1YzQzZjQ3ZmQzMTIucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png"></p><p>注意在添加第五个任务，任务5 的时候，同样被线程池拒绝了，因此执行了CallerRunsPolicy的rejectedExecution方法，这个方法直接执行任务的run方法。因此可以看到任务5是在main线程中执行的。</p><p>从中也可以看出，因为第五个任务在主线程中运行，所以主线程就被阻塞了，以至于当第五个任务执行完，添加第六个任务时，前面两个任务已经执行完了，有了空闲线程，因此线程6又可以添加到线程池中执行了。</p><p>这个策略的缺点就是可能会阻塞主线程。</p><h2 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h2><p>这个策略的处理就更简单了，看一下实现就明白了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs auto">public static class DiscardPolicy implements RejectedExecutionHandler &#123;<br>    public DiscardPolicy() &#123; &#125;<br>    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个东西什么都没干。</p><p>因此采用这个拒绝策略，会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。</p><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30,<br>        TimeUnit.SECONDS,<br>        new LinkedBlockingDeque&lt;Runnable&gt;(2),<br>        new ThreadPoolExecutor.DiscardPolicy());<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDYyOTQzLTYwMzk2OWE0OGQxOWViMjkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png"></p><p>可以看到 后面添加的任务5和6根本不会执行，什么反应都没有，直接丢弃。</p><h2 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h2><p>DiscardOldestPolicy策略的作用是，当任务呗拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs auto">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;<br>    public DiscardOldestPolicy() &#123; &#125;<br>    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;<br>        if (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在rejectedExecution先从任务队列总弹出最先加入的任务，空出一个位置，然后再次执行execute方法把任务加入队列。</p><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30,<br>        TimeUnit.SECONDS,<br>        new LinkedBlockingDeque&lt;Runnable&gt;(2),<br>        new ThreadPoolExecutor.DiscardOldestPolicy());<br></code></pre></td></tr></table></figure><p>输出是：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDYyOTQzLWU3OTQyZTJkODc3OGU0NDMucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png"></p><p>可以看到，</p><ol><li>在添加第五个任务时，会被线程池拒绝。这时任务队列中有 任务2，任务3</li><li>这时，拒绝策略会让任务队列中最先加入的任务弹出，也就是任务2.</li><li>然后把被拒绝的任务5添加人任务队列，这时任务队列中就成了 任务3，任务5.</li><li>添加第六个任务时会因为同样的过程，将队列中的任务3抛弃，把任务6加进去，任务队列中就成了 任务5，任务6</li><li>因此，最终能被执行的任务只有1，4，5，6. 任务2和任务3倍抛弃了，不会执行。</li></ol><h2 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h2><p>通过看前面的系统提供的四种拒绝策略可以看出，拒绝策略的实现都非常简单。自己写亦一样</p><p>比如现在想让被拒绝的任务在一个新的线程中执行，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs auto">static class MyRejectedExecutionHandler implements RejectedExecutionHandler &#123;<br>    @Override<br>    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;<br>        new Thread(r,&quot;新线程&quot;+new Random().nextInt(10)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后正常使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30,<br>        TimeUnit.SECONDS,<br>        new LinkedBlockingDeque&lt;Runnable&gt;(2),<br>        new MyRejectedExecutionHandler());<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDYyOTQzLTE4ODk0ZDUxMzE2NjA3YTAucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png"></p><p>发现被拒绝的任务5和任务6都在新线程中执行了。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式详解以及破坏单例模式的方法</title>
    <link href="/2020/06/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/06/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单例模式是 Java 设计模式中最简单的一种，只需要一个类就能实现单例模式，但是，你可不能小看单例模式，虽然从设计上来说它比较简单，但是在实现当中你会遇到非常多的坑，所以，系好安全带，上车。</p><h2 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h2><p>单例模式就是在程序运行中只实例化一次，创建一个全局唯一对象，有点像 Java 的静态变量，但是单例模式要优于静态变量，静态变量在程序启动的时候JVM就会进行加载，如果不使用，会造成大量的资源浪费，单例模式能够实现懒加载，能够在使用实例的时候才去创建实例。开发工具类库中的很多工具类都应用了单例模式，比例线程池、缓存、日志对象等，它们都只需要创建一个对象，如果创建多份实例，可能会带来不可预知的问题，比如资源的浪费、结果处理不一致等问题。</p><h3 id="单例的实现思路"><a href="#单例的实现思路" class="headerlink" title="单例的实现思路"></a>单例的实现思路</h3><ul><li>静态化实例对象</li><li>私有化构造方法，禁止通过构造方法创建实例</li><li>提供一个公共的静态方法，用来返回唯一实例</li></ul><h3 id="单例的好处"><a href="#单例的好处" class="headerlink" title="单例的好处"></a>单例的好处</h3><ul><li><p>只有一个对象，内存开支少、性能好</p></li><li><p>避免对资源的多重占用</p></li><li><p>在系统设置全局访问点，优化和共享资源访问</p></li></ul><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>单例模式的写法有饿汉模式、懒汉模式、双重检查锁模式、静态内部类单例模式、枚举类实现单例模式五种方式，其中懒汉模式、双重检查锁模式两种方式，如果你写法不当，在多线程情况下会存在不是单例或者单例出异常等问题，具体的原因，在后面的对应处会进行说明。我们从最基本的饿汉模式开始我们的单例编写之路。</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>饿汉模式采用一种简单粗暴的形式，在定义静态属性时，直接实例化了对象。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs auto">//在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快<br>public class SingletonObject1 &#123;<br>    // 利用静态变量来存储唯一实例<br>    private static final SingletonObject1 instance = new SingletonObject1();<br><br>    // 私有化构造函数<br>    private SingletonObject1()&#123;<br>        // 里面可能有很多操作<br>    &#125;<br><br>    // 提供公开获取实例接口<br>    public static SingletonObject1 getInstance()&#123;<br>        return instance;<br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="饿汉模式的优缺点"><a href="#饿汉模式的优缺点" class="headerlink" title="饿汉模式的优缺点"></a>饿汉模式的优缺点</h3><p>优点</p><ul><li>由于使用了static关键字，保证了在引用这个变量时，关于这个变量的所以写入操作都完成，所以保证了JVM层面的线程安全</li></ul><p>缺点</p><ul><li>不能实现懒加载，造成空间浪费，如果一个类比较大，我们在初始化的时就加载了这个类，但是我们长时间没有使用这个类，这就导致了内存空间的浪费。</li></ul><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>懒汉模式是一种偷懒的模式，在程序初始化时不会创建实例，只有在使用实例的时候才会创建实例，所以懒汉模式解决了饿汉模式带来的空间浪费问题，同时也引入了其他的问题，我们先来看看下面这个懒汉模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class SingletonObject2 &#123;<br>    // 定义静态变量时，未初始化实例<br>    private static SingletonObject2 instance;<br><br>    // 私有化构造函数<br>    private SingletonObject2()&#123;<br><br>    &#125;<br><br>    public static SingletonObject2 getInstance()&#123;<br>        // 使用时，先判断实例是否为空，如果实例为空，则实例化对象<br>        if (instance == null)<br>            instance = new SingletonObject2();<br>        return instance;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>上面是懒汉模式的实现方式，但是上面这段代码在多线程的情况下是不安全的，因为它不能保证是单例模式，有可能会出现多份实例的情况，出现多份实例的情况是在创建实例对象时候造成的。所以我单独把实例化的代码提出，来分析一下为什么会出现多份实例的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">     1   if (instance == null)<br>     2       instance = new SingletonObject2();<br>复制代码<br></code></pre></td></tr></table></figure><p>假设有两个线程都进入到 1 这个位置，因为没有任何资源保护措施，所以两个线程可以同时判断的<code>instance</code>都为空，都将去执行 2 的实例化代码，所以就会出现多份实例的情况。</p><p>通过上面的分析我们已经知道出现多份实例的原因，如果我们在创建实例的时候进行资源保护，是不是可以解决多份实例的问题？确实如此，我们给<code>getInstance()</code>方法加上<code>synchronized</code>关键字，使得<code>getInstance()</code>方法成为受保护的资源就能够解决多份实例的问题。加上<code>synchronized</code>关键字之后代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class SingletonObject3 &#123;<br>    private static SingletonObject3 instance;<br><br>    private SingletonObject3()&#123;<br><br>    &#125;<br><br>    public synchronized static SingletonObject3 getInstance()&#123;<br>        /**<br>         * 添加class类锁，影响了性能，加锁之后将代码进行了串行化，<br>         * 我们的代码块绝大部分是读操作，在读操作的情况下，代码线程是安全的<br>         *<br>         */<br><br>        if (instance == null)<br>            instance = new SingletonObject3();<br>        return instance;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>经过修改后，我们解决了多份实例的问题，但是因为加入了<code>synchronized</code>关键字，对代码加了锁，就引入了新的问题，加锁之后会使得程序变成串行化，只有抢到锁的线程才能去执行这段代码块，这会使得系统的性能大大下降。</p><h3 id="懒汉模式的优缺点"><a href="#懒汉模式的优缺点" class="headerlink" title="懒汉模式的优缺点"></a>懒汉模式的优缺点</h3><p>优点</p><ul><li>实现了懒加载，节约了内存空间</li></ul><p>缺点</p><ul><li>在不加锁的情况下，线程不安全，可能出现多份实例</li><li>在加锁的情况下，会是程序串行化，使系统有严重的性能问题</li></ul><h3 id="双重检查锁模式"><a href="#双重检查锁模式" class="headerlink" title="双重检查锁模式"></a>双重检查锁模式</h3><p>再来讨论一下懒汉模式中加锁的问题，对于<code>getInstance()</code>方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的问题。由此也产生了一种新的实现模式：<strong>双重检查锁模式</strong>，下面是双重检查锁模式的单例实现代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class SingletonObject4 &#123;<br>    private static SingletonObject4 instance;<br><br>    private SingletonObject4()&#123;<br><br>    &#125;<br><br>    public static SingletonObject4 getInstance()&#123;<br><br>        // 第一次判断，如果这里为空，不进入抢锁阶段，直接返回实例<br>        if (instance == null)<br>            synchronized (SingletonObject4.class)&#123;<br>                // 抢到锁之后再次判断是否为空<br>                if (instance == null)&#123;<br>                    instance = new SingletonObject4();<br>                &#125;<br>            &#125;<br><br>        return instance;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现<strong>空指针问题</strong>，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。什么是指令重排？，看下面这个例子，简单了解一下指令从排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">    private SingletonObject4()&#123;<br>     1   int x = 10;<br>     2   int y = 30;<br>     3  Object o = new Object();<br>                <br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>上面的构造函数<code>SingletonObject4()</code>，我们编写的顺序是1、2、3，JVM 会对它进行指令重排序，所以执行顺序可能是3、1、2，也可能是2、3、1，不管是那种执行顺序，JVM 最后都会保证所以实例都完成实例化。 如果构造函数中操作比较多时，为了提升效率，JVM 会在构造函数里面的属性未全部完成实例化时，就返回对象。双重检测锁出现空指针问题的原因就是出现在这里，当某个线程获取锁进行实例化时，其他线程就直接获取实例使用，由于JVM指令重排序的原因，其他线程获取的对象也许不是一个完整的对象，所以在使用实例的时候就会出现空指针异常问题。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用<code>volatile</code>关键字，<code>volatile</code>关键字严格遵循<code>happens-before</code>原则，即在读操作前，写操作必须全部完成。添加<code>volatile</code>关键字之后的单例模式代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs auto">    // 添加volatile关键字<br>    private static volatile SingletonObject5 instance;<br><br>    private SingletonObject5()&#123;<br><br>    &#125;<br><br>    public static SingletonObject5 getInstance()&#123;<br><br>        if (instance == null)<br>            synchronized (SingletonObject5.class)&#123;<br>                if (instance == null)&#123;<br>                    instance = new SingletonObject5();<br>                &#125;<br>            &#125;<br><br>        return instance;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>添加<code>volatile</code>关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>静态内部类单例模式也称单例持有者模式，实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由<code>static</code>修饰，保证只被实例化一次，并且严格保证实例化顺序。静态内部类单例模式代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class SingletonObject6 &#123;<br><br><br>    private SingletonObject6()&#123;<br><br>    &#125;<br>    // 单例持有者<br>    private static class InstanceHolder&#123;<br>        private  final static SingletonObject6 instance = new SingletonObject6();<br><br>    &#125;<br>    <br>    // <br>    public static SingletonObject6 getInstance()&#123;<br>        // 调用内部类属性<br>        return InstanceHolder.instance;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h3 id="枚举类实现单例模式"><a href="#枚举类实现单例模式" class="headerlink" title="枚举类实现单例模式"></a>枚举类实现单例模式</h3><p>枚举类实现单例模式是 effective java 作者极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class SingletonObject7 &#123;<br><br><br>    private SingletonObject7()&#123;<br><br>    &#125;<br><br>    /**<br>     * 枚举类型是线程安全的，并且只会装载一次<br>     */<br>    private enum Singleton&#123;<br>        INSTANCE;<br><br>        private final SingletonObject7 instance;<br><br>        Singleton()&#123;<br>            instance = new SingletonObject7();<br>        &#125;<br><br>        private SingletonObject7 getInstance()&#123;<br>            return instance;<br>        &#125;<br>    &#125;<br><br>    public static SingletonObject7 getInstance()&#123;<br><br>        return Singleton.INSTANCE.getInstance();<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="破坏单例模式的方法及解决办法"><a href="#破坏单例模式的方法及解决办法" class="headerlink" title="破坏单例模式的方法及解决办法"></a>破坏单例模式的方法及解决办法</h2><p>1、除枚举方式外, 其他方法都会通过反射的方式破坏单例,反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs auto">private SingletonObject1()&#123;<br>    if (instance !=null)&#123;<br>        throw new RuntimeException(&quot;实例已经存在，请通过 getInstance()方法获取&quot;);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>2、如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">public Object readResolve() throws ObjectStreamException &#123;<br>      return instance;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll的简单讲解</title>
    <link href="/2020/06/10/epoll%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3/"/>
    <url>/2020/06/10/epoll%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I&#x2F;O操作的内核对象。</p><p>    不管是文件，还是套接字，还是管道，我们都可以把他们看作流。</p><p>    之后我们来讨论I&#x2F;O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？</p><p>阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</p><p>非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”</p><p>    很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。</p><p>    大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。</p><p>    为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I&#x2F;O事件解释清楚。缓冲区的引入是为了减少频繁I&#x2F;O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。</p><p>假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</p><p>假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</p><p>    但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I&#x2F;O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。</p><p>假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</p><p>    也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</p><p>这四个情形涵盖了四个I&#x2F;O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I&#x2F;O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</p><p>    然后我们来说说阻塞I&#x2F;O的缺点。但是阻塞I&#x2F;O模式下，一个线程只能处理一个流的I&#x2F;O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</p><p>    于是再来考虑非阻塞忙轮询的I&#x2F;O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：</p><p>while true {</p><p>for i in stream[]; {</p><p>if i has data</p><p>read until unavailable</p><p>}</p><p>}</p><p>    我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I&#x2F;O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I&#x2F;O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</p><p>    为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I&#x2F;O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I&#x2F;O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:</p><p>while true {</p><p>select(streams[])</p><p>for i in streams[] {</p><p>if i has data</p><p>read until unavailable</p><p>}</p><p>}</p><p>    于是，如果没有I&#x2F;O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I&#x2F;O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p><p>    但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次</p><p>说了这么多，终于能好好解释epoll了</p><p>    epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I&#x2F;O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p><p>    在讨论epoll的实现细节之前，先把epoll的相关操作列出：</p><p>epoll_create 创建一个epoll对象，一般epollfd &#x3D; epoll_create()</p><p>epoll_ctl （epoll_add&#x2F;epoll_del的合体），往epoll对象中增加&#x2F;删除某一个流的某一个事件</p><p>比如</p><p>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);&#x2F;&#x2F;注册缓冲区非空事件，即有数据流入</p><p>epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);&#x2F;&#x2F;注册缓冲区非满事件，即流可以被写入</p><p>epoll_wait(epollfd,…)等待直到注册的事件发生</p><p>（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write&#x2F;read会返回-1，并设置errno&#x3D;EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。</p><p>一个epoll模式的代码大概的样子是：</p><p>while true {</p><p>active_stream[] &#x3D; epoll_wait(epollfd)</p><p>for i in active_stream[] {</p><p>read or write till</p><p>}</p><p>}</p><p>    限于篇幅，我只说这么多，以揭示原理性的东西，至于epoll的使用细节，请参考man和google，实现细节，请参阅linux kernel source。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见数据库连接池性能分析对比</title>
    <link href="/2020/06/10/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%AF%B9%E6%AF%94/"/>
    <url>/2020/06/10/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h2 id="常见数据库连接池性能分析对比"><a href="#常见数据库连接池性能分析对比" class="headerlink" title="常见数据库连接池性能分析对比"></a>常见数据库连接池性能分析对比</h2><p>最新推荐文章于 2023-04-28 11:42:35 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-04-28 11:42:35 发布</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>对现有的<a href="http://lib.csdn.net/base/14">数据库</a>连接池做调研对比，综合性能，可靠性，稳定性，扩展性等因素选出推荐出最优的数据库连接池 。     </p><p><strong>NOTE: 本文所有测试均是<a href="http://lib.csdn.net/base/14">MySQL</a>库</strong></p><h2 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a><strong>测试结论</strong></h2><p>   1：性能方面 hikariCP&gt;druid&gt;tomcat-jdbc&gt;dbcp&gt;c3p0 。hikariCP的高性能得益于最大限度的避免锁竞争。</p><p>   2：druid功能最为全面，sql拦截等功能，统计数据较为全面，具有良好的扩展性。</p><p>   3：综合性能，扩展性等方面，可考虑使用druid或者hikariCP连接池。</p><p>   4：可开启prepareStatement缓存，对性能会有大概20%的提升。</p><h2 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a><strong>功能对比</strong></h2><table><tbody><tr><td>功能</td><td>dbcp</td><td>druid</td><td>c3p0</td><td>tomcat-jdbc</td><td>HikariCP</td></tr><tr><td>是否支持PSCache</td><td>是</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>监控</td><td>jmx</td><td>jmx/log/http</td><td>jmx,log</td><td>jmx</td><td>jmx</td></tr><tr><td>扩展性</td><td>弱</td><td>好</td><td>弱</td><td>弱</td><td>弱</td></tr><tr><td>sql拦截及解析</td><td>无</td><td>支持</td><td>无</td><td>无</td><td>无</td></tr><tr><td>代码</td><td>简单</td><td>中等</td><td>复杂</td><td>简单</td><td>简单</td></tr><tr><td>更新时间</td><td>2015.8.6</td><td>2015.10.10</td><td>&nbsp;2015.12.09</td><td>&nbsp;</td><td>2015.12.3</td></tr><tr><td>特点</td><td>依赖于common-pool</td><td>阿里开源，功能全面</td><td>历史久远，代码逻辑复杂，且不易维护</td><td>&nbsp;</td><td>优化力度大，功能简单，起源于boneCP</td></tr><tr><td>连接池管理</td><td>LinkedBlockingDeque</td><td>数组</td><td>&nbsp;</td><td>FairBlockingQueue</td><td>threadlocal+CopyOnWriteArrayList</td></tr></tbody></table><ul><li> 由于boneCP被hikariCP替代，并且已经不再更新，boneCP没有进行调研。</li><li>proxool网上有评测说在并发较高的情况下会出错，proxool便没有进行调研。</li><li> druid的功能比较全面，且扩展性较好，比较方便对jdbc接口进行监控跟踪等。</li><li>c3p0历史悠久，代码及其复杂，不利于维护。并且存在deadlock的潜在风险。</li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a><strong>性能测试</strong></h2><p><strong>环境配置：</strong></p><table><tbody><tr><td>CPU</td><td>Intel(R) Xeon(R) CPU E5-2430 v2 @ 2.50GHz，24core</td></tr><tr><td>msyql version</td><td>5.5.46</td></tr><tr><td>tomcat-jdbc version</td><td>8.0.28</td></tr><tr><td>HikariCP version</td><td>2.4.3</td></tr><tr><td>c3p0 Version</td><td>0.9.5-pre8</td></tr><tr><td>dbcpVersion</td><td>2.0.1</td></tr><tr><td>druidVersion</td><td>1.0.5</td></tr></tbody></table><p><strong>1：获取关闭连接性能测试</strong></p><p>       测试说明：</p><ul><li>初始连接和最小连接均为5，最大连接为20。在borrow和return均不心跳检测</li><li>其中打开关闭次数为: 100w次</li><li>测试用例和mysql在同一台机器上面，尽量避免io的影响</li><li>使用mock和连接mysql在不同线程并发下的响应时间</li></ul><p>     图形：</p><p><img src="https://img-blog.csdn.net/20160106104925916"></p><p> <img src="https://img-blog.csdn.net/20160106104944246"></p><p>   mock性能数据 (单位:ms)</p><table><tbody><tr><td>&nbsp;</td><td>5</td><td>20</td><td>50</td><td>100</td></tr><tr><td>tomcat-jdbc</td><td>442</td><td>447</td><td>1,013</td><td>1,264</td></tr><tr><td>c3p0</td><td>4,480</td><td>5,527</td><td>7,449</td><td>10,725</td></tr><tr><td>dbcp</td><td>676</td><td>689</td><td>867</td><td>1,292</td></tr><tr><td>hikari</td><td>38</td><td>33</td><td>38</td><td>30</td></tr><tr><td>druid</td><td>291</td><td>293</td><td>562</td><td>985</td></tr></tbody></table><p>mysql性能数据 (单位:ms)</p><table><tbody><tr><td>&nbsp;</td><td>5</td><td>20</td><td>50</td><td>100</td></tr><tr><td>tomcat-jdbc</td><td>436</td><td>453</td><td>1,033</td><td>1,291</td></tr><tr><td>c3p0</td><td>4,378</td><td>5,726</td><td>7,975</td><td>10,948</td></tr><tr><td>dbcp</td><td>671</td><td>679</td><td>897</td><td>1,380</td></tr><tr><td>hikari</td><td>96</td><td>82</td><td>87</td><td>78</td></tr><tr><td>druid</td><td>304</td><td>424</td><td>690</td><td>1,130</td></tr></tbody></table><p>测试结果：</p><ul><li>mock和mysql连接性能表现差不多，主要是由于初始化的时候建立了连接后期不再建立连接，和使用mock连接逻辑一致。 </li><li>性能表现：hikariCP&gt;druid&gt;tomcat-jdbc&gt;dbcp&gt;c3p0。</li><li> hikariCP 的性能及其优异。hikariCP号称java平台最快的数据库连接池。</li><li> hikariCP在并发较高的情况下，性能基本上没有下降。</li><li> c3p0连接池的性能很差，不建议使用该数据库连接池。</li></ul><pre><code class="hljs"> </code></pre><p>   hikariCP性能分析：</p><ul><li>hikariCP通过优化(concurrentBag，fastStatementList )集合来提高并发的读写效率。</li><li>hikariCP使用threadlocal缓存连接及大量使用CAS的机制，最大限度的避免lock。单可能带来cpu使用率的上升。</li><li>从字节码的维度优化代码。 (default inline threshold for a JVM running the server Hotspot compiler is 35 bytecodes ）让方法尽量在35个字节码一下，来提升jvm的处理效率。</li></ul><p><strong>2：查询一条语句性能测试</strong></p><p>     测试说明：</p><ul><li>初始连接和最小连接均为8，最大连接为8。在borrow和return均不心跳检测</li><li>查询的次数为10w次，查询的语句为 1：打开连接 2：执行 ：select 1 3：关闭连接</li><li>测试用例和mysql在同一台机器上面，尽量避免io的影响</li></ul><p>图形：</p><p><img src="https://img-blog.csdn.net/20160106105001512"></p><p> 测试数据：</p><table><tbody><tr><td>&nbsp;</td><td>5</td><td>8</td><td>20</td><td>50</td><td>100</td></tr><tr><td>tomcat-jdbc</td><td>2,178</td><td>1,495</td><td>1,769</td><td>1,818</td><td>1,858</td></tr><tr><td>c3p0</td><td>3,237</td><td>3,451</td><td>4,488</td><td>5,994</td><td>7,906</td></tr><tr><td>dbcp</td><td>2,816</td><td>1,935</td><td>2,097</td><td>2,243</td><td>2,280</td></tr><tr><td>hikari</td><td>2,299</td><td>1,546</td><td>1,682</td><td>1,751</td><td>1,772</td></tr><tr><td>druid</td><td>2,297</td><td>1,551</td><td>1,800</td><td>1,977</td><td>2,032</td></tr></tbody></table><p>测试结果：</p><ul><li>  在并发比较少的情况下，每个连接池的响应时间差不多。是由于并发少，基本上没有资源竞争。</li><li>  在并发较高的情况下，随着并发的升高，hikariCP响应时间基本上没有变动。</li><li>  c3p0随着并发的提高，性能急剧下降。</li></ul><p><strong>3：pscache性能对比</strong></p><p>   测试说明：</p><ul><li>通过druid进行设置pscache和不设置pscache的性能对比</li><li>初始连接和最小连接均为8，最大连接为8。在borrow和return均不心跳检测。并且执行的并发数为8.</li><li>查询10w次。查询流程为：1：建立连接，2：循环查询preparestatement语句 3：close连接</li><li>测试用例和mysql在同一台机器上面，尽量避免io的影响</li></ul><p>   测试数据：</p><p>  测试结果：</p><ul><li>开启psCache缓存,性能大概有20%幅度的提升。可考虑开启pscache.</li></ul><p>  测试说明：</p><ul><li>psCache是connection私有的，所以不存在线程竞争的问题，开启pscache不会存在竞争的性能损耗。</li><li>psCache的key为prepare执行的sql和catalog等，value对应的为prepareStatement对象。开启缓存主要是减少了解析sql的开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射遍历判断值是否属于枚举类Enum</title>
    <link href="/2020/06/08/Java%E5%8F%8D%E5%B0%84%E9%81%8D%E5%8E%86%E5%88%A4%E6%96%AD%E5%80%BC%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9E%9A%E4%B8%BE%E7%B1%BBEnum/"/>
    <url>/2020/06/08/Java%E5%8F%8D%E5%B0%84%E9%81%8D%E5%8E%86%E5%88%A4%E6%96%AD%E5%80%BC%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9E%9A%E4%B8%BE%E7%B1%BBEnum/</url>
    
    <content type="html"><![CDATA[<h2 id="Java反射遍历判断值是否属于枚举类Enum"><a href="#Java反射遍历判断值是否属于枚举类Enum" class="headerlink" title="Java反射遍历判断值是否属于枚举类Enum"></a>Java反射遍历判断值是否属于枚举类Enum</h2><p>最新推荐文章于 2023-06-23 00:45:40 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-06-23 00:45:40 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天在开发的时候遇到一个判断需求：判断一个值是否属于枚举类。之前写的话都是通过在if里面写上|| 或来连接 或者为每个枚举Enum写一个遍历判断的方法。后来想了一下实在太麻烦了，加入枚举类改变的话业务代码的判断也需要改变比较麻烦，工具类也没找到相关的，于是自己通过反射写了一个循环遍历判断枚举类。</p><p>首先，是一个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">AuditState</span> &#123;<br><br>        TO_BE_AUDIT(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;待审核&quot;</span>),<br>        AUDITED(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;已审核&quot;</span>);<br><br>        <span class="hljs-keyword">private</span> String message;<br>        <span class="hljs-keyword">private</span> Integer code;<br><br>        AuditState(Integer code, String message) &#123;<br>            <span class="hljs-built_in">this</span>.message = message;<br>            <span class="hljs-built_in">this</span>.code = code;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessage</span><span class="hljs-params">(String message)</span> &#123;<br>            <span class="hljs-built_in">this</span>.message = message;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> code;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(Integer code)</span> &#123;<br>            <span class="hljs-built_in">this</span>.code = code;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>然后是一个EnumUtil类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 枚举工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-06-08</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumUtils</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断数值是否属于枚举类的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clzz 枚举类 Enum</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInclude</span><span class="hljs-params">(Class&lt;?&gt; clzz,Integer code)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">include</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(clzz.isEnum())&#123;<br>            Object[] enumConstants = clzz.getEnumConstants();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">getCode</span> <span class="hljs-operator">=</span> clzz.getMethod(<span class="hljs-string">&quot;getCode&quot;</span>);<br>            <span class="hljs-keyword">for</span> (Object enumConstant:enumConstants)&#123;<br>                <span class="hljs-keyword">if</span> (getCode.invoke(enumConstant).equals(code)) &#123;<br>                    include = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> include;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;<br>        System.out.println(isInclude(BusinessGroupBuyEnum.AuditState.class,<span class="hljs-number">0</span>));<br>        System.out.println(isInclude(BusinessGroupBuyEnum.AuditState.class,<span class="hljs-number">1</span>));<br>        System.out.println(isInclude(BusinessGroupBuyEnum.AuditState.class,-<span class="hljs-number">1</span>));<br>        System.out.println(isInclude(BusinessGroupBuyEnum.AuditState.class,<span class="hljs-literal">null</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>返回的结果是：</p><p>true<br>true<br>false<br>false</p><p>通过测试！</p><p><strong>【其实还有最简单的方法不需要反射，****枚举类中有一个静态方法values()，value()方法可以将枚举类转变为一个枚举类型的数组】</strong></p><p>&#x2F;**<br>     *  判断枚举值是否存在<br>     *&#x2F;<br>    public static boolean isExist(Integer value) {<br>        if (value &#x3D;&#x3D; null) {<br>            return false;<br>        }<br>        for (AppIdEnum e : values()) {<br>            if (value.equals(e.getAppId())) {<br>                return true;<br>            }<br>        }<br>        return false;<br>    }</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Html实现带token的文件上传</title>
    <link href="/2020/04/09/Java%20Html%E5%AE%9E%E7%8E%B0%E5%B8%A6token%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2020/04/09/Java%20Html%E5%AE%9E%E7%8E%B0%E5%B8%A6token%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<p>今天要实现一个带token认证的文件上传 参数中既有token 也有文件流</p><p>首先上html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文件上传测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文件上传测试<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/moonstore-app/common/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;token&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;token&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;token&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;upload()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> file = $(<span class="hljs-string">&#x27;#file&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> token = $.<span class="hljs-title function_">trim</span>($(<span class="hljs-string">&#x27;#token&#x27;</span>).<span class="hljs-title function_">val</span>());</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">        formData.<span class="hljs-property">file</span> = file;</span><br><span class="language-javascript">        formData.<span class="hljs-property">token</span> = token;</span><br><span class="language-javascript">        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;file&quot;</span>,$(<span class="hljs-string">&#x27;#file&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]);</span><br><span class="language-javascript">        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;token&quot;</span>, token);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        $.<span class="hljs-title function_">ajax</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/moonstore-app/common/upload&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">async</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: formData,</span><br><span class="language-javascript">            <span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 使数据不做处理</span></span><br><span class="language-javascript">            <span class="hljs-attr">contentType</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不要设置Content-Type请求头</span></span><br><span class="language-javascript">            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);</span><br><span class="language-javascript">                <span class="hljs-keyword">if</span> (data.<span class="hljs-property">responseCode</span> == <span class="hljs-number">200</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;上传成功！&#x27;</span>);</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后是后端的文件上传代码，后端我是用了springboot框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> RestResponse <span class="hljs-title function_">upload</span><span class="hljs-params">(TokenParam tokenParam, <span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile[] file)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(file)) &#123;<br>            <span class="hljs-keyword">return</span> RestResponse.error(ResultCode.FILE_IS_EMPTY);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;FileVo&gt; fileVoList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>            MultipartFile[] files = file;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">fileLength</span> <span class="hljs-operator">=</span> file.length;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fileLength; i++) &#123;<br>                <span class="hljs-type">MultipartFile</span> <span class="hljs-variable">multipartFile</span> <span class="hljs-operator">=</span> files[i];<br>                <span class="hljs-keyword">if</span> (!multipartFile.isEmpty()) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        filePath = UploadUtils.uploadToDfs(multipartFile.getInputStream(), fileName);<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        log.error(<span class="hljs-string">&quot;文件上传异常：&quot;</span>, e);<br>                        <span class="hljs-keyword">return</span> RestResponse.error(ResultCode.FILE_UPLOAD_FAIL);<br>                    &#125;<br>                    <span class="hljs-type">FileVo</span> <span class="hljs-variable">fileVo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileVo</span>();<br>                    fileVo.setFileName(fileName);<br>                    fileVo.setFilePath(filePath);<br>                    fileVoList.add(fileVo);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> RestResponse.ok(fileVoList);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>一些实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileVo</span> &#123;<br>    <span class="hljs-keyword">private</span> String fileName;<br>    <span class="hljs-keyword">private</span> String filePath;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenParam</span> &#123;<br>    <span class="hljs-keyword">private</span> String token;<br><br>    <span class="hljs-keyword">private</span> UserInfo userInfo;<br><br>    <span class="hljs-keyword">private</span> Integer moonStoreId;<br>&#125;<br></code></pre></td></tr></table></figure><p>RestResponse 是统一返回类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestResponse</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResponseBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-meta">@Autowired(</span><br><span class="hljs-meta">        required = false</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-keyword">protected</span> StatusComponent statusComponent;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StatusComponent</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpStatusComponent</span>();<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != <span class="hljs-built_in">this</span>.statusComponent) &#123;<br>            component = <span class="hljs-built_in">this</span>.statusComponent;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RestResponse</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isSuccess, <span class="hljs-type">int</span> responseCode, String responseMsg, Object data)</span> &#123;<br>        <span class="hljs-built_in">super</span>(isSuccess, responseCode, responseMsg, data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RestResponse</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-literal">true</span>, component.getStatus(), ResultCode.OK.getMessage(), (Object)<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RestResponse</span><span class="hljs-params">(T result)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-literal">true</span>, component.getStatus(), ResultCode.OK.getMessage(), result);<br>    &#125;<br><br>    <span class="hljs-meta">@JsonGetter(&quot;isSuccess&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getIsSuccess</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ResultCode.OK.getCode() == <span class="hljs-built_in">super</span>.getResponseCode() || <span class="hljs-built_in">super</span>.getResponseCode() == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">ok</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>.DefaultBuilder()).build();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">ok</span><span class="hljs-params">(T result)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>.DefaultBuilder()).body(result);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(Code code)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>.DefaultBuilder()).status(code);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(SystemRuntimeException e)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>.DefaultBuilder()).status(e);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(String errorMessage)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>.DefaultBuilder()).status(errorMessage);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultBuilder</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">DefaultBuilder</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.body((Object)<span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">body</span><span class="hljs-params">(T body)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>(body);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">status</span><span class="hljs-params">(Code code)</span> &#123;<br>            <span class="hljs-type">RestResponse</span> <span class="hljs-variable">restApiResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>();<br>            restApiResponse.setResponseCode(code.getCode());<br>            restApiResponse.setResponseMsg(code.getMessage());<br>            <span class="hljs-keyword">return</span> restApiResponse;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">status</span><span class="hljs-params">(SystemRuntimeException e)</span> &#123;<br>            <span class="hljs-type">RestResponse</span> <span class="hljs-variable">restApiResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>();<br>            restApiResponse.setResponseCode(e.getCode().getCode());<br>            restApiResponse.setResponseMsg(e.getMessage());<br>            <span class="hljs-keyword">return</span> restApiResponse;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="hljs-title function_">status</span><span class="hljs-params">(String errorMessage)</span> &#123;<br>            <span class="hljs-type">RestResponse</span> <span class="hljs-variable">restApiResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestResponse</span>();<br>            restApiResponse.setResponseCode(ResultCode.INTERNAL_SERVER_ERROR.getCode());<br>            restApiResponse.setResponseMsg(errorMessage);<br>            <span class="hljs-keyword">return</span> restApiResponse;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ResultCode是常量提示返回枚举 这个我就不上了</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis应用中自增安全吗？</title>
    <link href="/2020/03/31/redis%E5%BA%94%E7%94%A8%E4%B8%AD%E8%87%AA%E5%A2%9E%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/"/>
    <url>/2020/03/31/redis%E5%BA%94%E7%94%A8%E4%B8%AD%E8%87%AA%E5%A2%9E%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="redis应用中自增安全吗？"><a href="#redis应用中自增安全吗？" class="headerlink" title="redis应用中自增安全吗？"></a>redis应用中自增安全吗？</h2><p>最新推荐文章于 2023-12-04 20:15:00 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-12-04 20:15:00 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><ol><li><p>redis是单线程运行，所以多个redis命令是一个一个执行，所以是<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">线程安全</a>的</p></li><li><p>但是分开的两个redis命令，对于整个应用来说不是线程安全的，因为这两个redis命令之间会有其他命令，就像多线程环境下，java线程不安全的i++操作，这个两个redis命令没有事务管理</p></li><li><p>可以用RPOPLPUSH或者INCR , 或者lua脚本，实现多个redis操作合为一个命令，这样就对于线程安全了</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么重写equals一定要重写hashcode？</title>
    <link href="/2020/03/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashcode%EF%BC%9F/"/>
    <url>/2020/03/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashcode%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么重写equals一定要重写hashcode？"><a href="#为什么重写equals一定要重写hashcode？" class="headerlink" title="为什么重写equals一定要重写hashcode？"></a>为什么重写equals一定要重写hashcode？</h2><p>最新推荐文章于 2023-03-15 21:28:43 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-03-15 21:28:43 发布</p><p>大家都知道，equals和hashcode是java.lang.Object类的两个重要的方法，在实际应用中常常需要重写这两个方法，但至于为什么重写这两个方法很多人都搞不明白，以下是我的一些个人理解。</p><p><img src="https://img-blog.csdn.net/20180524232711424?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hsXzE4MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>这是Object类关于这两个方法的源码，可以看出，Object类默认的equals比较规则就是比较两个对象的内存地址。而hashcode是本地方法，java的内存是安全的，因此无法根据散列码得到对象的内存地址，但实际上，hashcode是根据对象的内存地址经哈希算法得来的。</p><p><img src="https://img-blog.csdn.net/20180524233427128?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hsXzE4MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>上图展示了Student类的重写后的equals方法和hashcode方法，建议大家用eclipse自动生成，尽量不要自己敲因为很有可能会出错。</p><p>现在有两个Student对象：</p><p>    Student s1&#x3D;new Student(“小明”,18);</p><p>    Student s2&#x3D;new Student(“小明”,18);</p><p>此时s1.equals(s2)一定返回true</p><p>假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!&#x3D;s2,故两者的hashcode不一定相等。</p><p>然而重写了equals，且s1.equals(s2)返回true，根据hashcode的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。</p><p>以下是关于hashcode的一些规定：</p><p>两个对象相等，hashcode一定相等</p><p>两个对象不等，hashcode不一定不等</p><p>hashcode相等，两个对象不一定相等</p><p>hashcode不等，两个对象一定不等</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java关于^的坑</title>
    <link href="/2020/01/02/Java%E5%85%B3%E4%BA%8E%5E%E7%9A%84%E5%9D%91/"/>
    <url>/2020/01/02/Java%E5%85%B3%E4%BA%8E%5E%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="Java关于-的坑"><a href="#Java关于-的坑" class="headerlink" title="Java关于^的坑"></a>Java关于^的坑</h2><p>最新推荐文章于 2022-03-07 16:09:26 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-03-07 16:09:26 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>在平时运算中，大家都习惯^就是“次方运算”，比如10^2 &#x3D; 100,2^3&#x3D;8 。但是这在Java中甚至说在计算机中，^并不是表示“次方运算”，</p><p>而是表示 二进制位数运算中，如果相对应位值相同，则结果为0，否则为1，也就是计算机中异或运算符 “^”，用于逻辑运算</p><table><tbody><tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>如，（60 ^ 13）得到49，即 0011 0001</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java.lang.UnsupportedOperationException解决方法</title>
    <link href="/2019/12/24/java.lang.UnsupportedOperationException%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2019/12/24/java.lang.UnsupportedOperationException%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="java-lang-UnsupportedOperationException解决方法"><a href="#java-lang-UnsupportedOperationException解决方法" class="headerlink" title="java.lang.UnsupportedOperationException解决方法"></a>java.lang.UnsupportedOperationException解决方法</h2><p>最新推荐文章于 2023-01-11 13:47:58 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-01-11 13:47:58 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天做项目的时候遇到一个报错java.lang.UnsupportedOperationException，没看控制台报错的时候以为是空指针报错。可是经过debug发现栈中变量都没发现啥问题，其中报错的代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; supEmailList = Arrays.asList(supEmails);<br><span class="hljs-keyword">if</span> (StringUtils.isNotBlank(user.getMail())) &#123;<br>            supEmailList.add(user.getMail());<br>&#125;<br></code></pre></td></tr></table></figure><p>刚开始我一直没看出有啥问题，但是也确实对supEmailList 这个变量的add方法是否能这样使用存在怀疑，于是我查询了一下资料证实了我的想法：调用Arrays.asList()生产的List的add、remove方法时报异常，这是因为Arrays.asList() 返回的是Arrays的内部类ArrayList， 而不是java.util.ArrayList。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重写了这些方法而Arrays的内部类ArrayList没有重写，所以会抛出异常。解决方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; tempList = Arrays.asList(supEmails);<br>        List&lt;String&gt; supEmailList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tempList);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(user.getMail())) &#123;<br>            supEmailList.add(user.getMail());<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring boot 注解@Async不生效 无效 不起作用</title>
    <link href="/2019/12/20/Spring%20boot%20%E6%B3%A8%E8%A7%A3@Async%E4%B8%8D%E7%94%9F%E6%95%88%20%E6%97%A0%E6%95%88%20%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <url>/2019/12/20/Spring%20boot%20%E6%B3%A8%E8%A7%A3@Async%E4%B8%8D%E7%94%9F%E6%95%88%20%E6%97%A0%E6%95%88%20%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-boot-注解-Async不生效-无效-不起作用"><a href="#Spring-boot-注解-Async不生效-无效-不起作用" class="headerlink" title="Spring boot 注解@Async不生效 无效 不起作用"></a>Spring boot 注解@Async不生效 无效 不起作用</h2><p>最新推荐文章于 2023-10-18 16:34:49 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p>置顶 <a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-10-18 16:34:49 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天在做公司项目时，有一个发邮件的需求。所以写了一个发送邮件的方法后来发现发邮件很慢，导致接口响应也很慢。于是我便想到要使用异步调用去处理这个方法。于是我把注解@Async 加到了自己service类下的一个发邮件的一个方法，后来发现并没有生效。</p><p>调用处代码：</p><p><img src="https://img-blog.csdnimg.cn/20191220101438478.png"></p><p><strong>我在以下两个方法上都试过加上@Async注解 可是都并没有生效</strong></p><p>发送邮件代码：</p><p><img src="https://img-blog.csdnimg.cn/20191220101524587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20191220101649159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>我思考了一下可能应该是因为aop代理的缘故，<strong>被调用方法 和 调用处的代码都处在同一个类，所以只是相当于本类调用，并没有使用代理类 从而@Async并没有产生效果。</strong></p><p>于是我查询了一下资料，证实了我的想法，于是我把@Async 注解放到了工具类 MailService 下</p><p><img src="https://img-blog.csdnimg.cn/2019122010225324.png"></p><p><img src="https://img-blog.csdnimg.cn/20191220102407826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>修改了注解的添加位置后，接口调用明显速度加快了，成功！</p><p>总结：</p><p>失效原因<br>1.@SpringBootApplication启动类当中没有添加@EnableAsync注解。<br>2.异步方法使用注解@Async的返回值只能为void或者Future。<br>3.没有走Spring的代理类。因为@Transactional和@Async注解的实现都是基于Spring的AOP，而AOP的实现是基于动态代理模式实现的。那么注解失效的原因就很明显了，有可能因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器管理。</p><p>解决方法:<br>这里具体说一下第三种情况的解决方法。<br>1.注解的方法必须是public方法。<br>2.方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的。<br>3.如果需要从类的内部调用，需要先获取其代理类。</p><p>扩展阅读：</p><p><a href="https://blog.csdn.net/YoungLee16/article/details/88398045">https://blog.csdn.net/YoungLee16/article/details/88398045</a></p><p><a href="https://blog.csdn.net/QYHuiiQ/article/details/85014983">https://blog.csdn.net/QYHuiiQ/article/details/85014983</a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac如何替换jar包指定的文件</title>
    <link href="/2019/10/23/Mac%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2jar%E5%8C%85%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <url>/2019/10/23/Mac%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2jar%E5%8C%85%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac如何替换jar包指定的文件"><a href="#Mac如何替换jar包指定的文件" class="headerlink" title="Mac如何替换jar包指定的文件"></a>Mac如何替换jar包指定的文件</h2><p>最新推荐文章于 2022-12-24 12:00:05 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-12-24 12:00:05 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天做项目需要把dubbo服务接口更新到公司内中央仓库 但是这个对外提供dubbo服务的的jar跟项目的jar不一样 所以需要把class文件替换之前的jar，上网找了很多方法 ，感觉先解压了再打包jar比较麻烦 而且mac中又不可以像windows那样直接操作打开替换jar文件 上网找了一些资料</p><p>jar uvf demo.jar demo.class</p><p>但是这样会直接把demo.class 直接添加到demo.jar包的<strong>根目录</strong>。</p><p>jar uvf demo.jar com&#x2F;demo&#x2F;demo.class </p><p>这样就可以替换<strong>对应应目录</strong>的class文件了。</p><p>这里值得注意的是  demo.class <strong>必须放在com&#x2F;demo 文件下，要和jar里的的路径对应起来</strong>。不然会提示</p><p>没有这个文件或目录。jar 包 和 com 文件夹的上级在同一个目录。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis的事务是否具有原子性？</title>
    <link href="/2019/09/30/redis%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E5%85%B7%E6%9C%89%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F/"/>
    <url>/2019/09/30/redis%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E5%85%B7%E6%9C%89%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="redis的事务是否具有原子性？"><a href="#redis的事务是否具有原子性？" class="headerlink" title="redis的事务是否具有原子性？"></a>redis的事务是否具有原子性？</h2><p>最新推荐文章于 2023-02-07 20:05:57 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p>置顶 <a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-02-07 20:05:57 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>        众所周知，redis可以通过MULTI EXEC DISCARD等来实现“事务”。但是事务应该具有ACID 四大特性，下面我就来探讨一下redis的事务是否具有A——原子性。</p><p>        首先，我们看第一种情况，语句格式语法错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; hset myhash java 10<br>QUEUED<br>127.0.0.1:6379&gt; hset myhash c 10<br>QUEUED<br>127.0.0.1:6379&gt; hsetmyhash php 3<br>(error) ERR unknown command `hsetmyhash`, with args beginning with: `php`, `3`,<br>127.0.0.1:6379&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; hgetall myhash<br>(empty list or set)<br></code></pre></td></tr></table></figure><p>     可以看到这种情况在最后执行exec命令的时候提示事务错误，而且查看上面的的hash结构并没有设置成功，那么看起来redis的事务是具有原子性，但是真的是这样吗？我们看下面第二种情况吧，语句到运行的时候才产生错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs auto">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; hset myhash java 10<br>QUEUED<br>127.0.0.1:6379&gt; hset myhash c 10<br>QUEUED<br>127.0.0.1:6379&gt; hset myhash php three<br>QUEUED<br>127.0.0.1:6379&gt; hincrby myhash php 1<br>QUEUED<br>127.0.0.1:6379&gt; hset myhash python 7<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (integer) 1<br>2) (integer) 1<br>3) (integer) 1<br>4) (error) ERR hash value is not an integer<br>5) (integer) 1<br>127.0.0.1:6379&gt; hgetall myhash<br>1) &quot;java&quot;<br>2) &quot;10&quot;<br>3) &quot;c&quot;<br>4) &quot;10&quot;<br>5) &quot;php&quot;<br>6) &quot;three&quot;<br>7) &quot;python&quot;<br>8) &quot;7&quot;<br></code></pre></td></tr></table></figure><p>从上面的操作我们可以看出 hincrby myhash php 1 这条语句在执行的时候出现了错误 因为php的value值不是一个整数值所以并不能增加一，但是可以通过后面的提示以及hgetall的验证得知 这条语句前面和后面的正确的语句都执行了，并没有回滚前面以及不执行后面，<strong>所以我们可以看出这并不符合事务的原子性：要么全部不做 要么全做，因此我们其实可以得出结论，redis的事务没有原子性,redis只实现了部分事务。</strong></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单学会配置Nginx反向代理与负载均衡</title>
    <link href="/2019/09/19/%E7%AE%80%E5%8D%95%E5%AD%A6%E4%BC%9A%E9%85%8D%E7%BD%AENginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2019/09/19/%E7%AE%80%E5%8D%95%E5%AD%A6%E4%BC%9A%E9%85%8D%E7%BD%AENginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="简单学会配置Nginx反向代理与负载均衡"><a href="#简单学会配置Nginx反向代理与负载均衡" class="headerlink" title="简单学会配置Nginx反向代理与负载均衡"></a>简单学会配置Nginx反向代理与负载均衡</h2><p>最新推荐文章于 2023-05-25 14:43:59 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-05-25 14:43:59 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p><strong>下面以springboot 项目为例 分别编写了两个简单的配置 我项目一个启动9129端口 另外一个启动为9130端口</strong>  </p><p>nginx</p><p>启动命令 </p><p>后台：brew services start nginx（homebrew是用）</p><p>非后台：nginx </p><p>停止 刷新命令</p><p>Nginx -s stop Nginx -s quit Nginx -s reload</p><p><strong>下面以springboot 项目为例 分别编写了两个简单的配置 适合入门 至于负载均衡另外的几种配置可以自行了解</strong></p><p><strong>首先项目一个启动9129端口 另外一个启动为9130端口</strong>  </p><p><strong>以下配置请修改nginx.conf</strong></p><p><strong>虚拟主机 多主机 反向代理</strong></p><p>代理后的地址为 8090 与 8091</p><p>server {</p><p>        listen       8090;</p><p>        server_name  localhost;</p><p>        location &#x2F; {</p><p>            proxy_pass <a href="http://127.0.0.1:9130/">http://127.0.0.1:9129;</a></p><p>#proxy_pass 填的是项目部署的地址 替换为你的项目部署地址</p><p>        }</p><p>    }</p><p>server {</p><p>        listen       8091;</p><p>        server_name  localhost;</p><p>        location &#x2F; {</p><p>            proxy_pass <a href="http://127.0.0.1:9130/">http://127.0.0.1:9130;</a>  </p><p>#proxy_pass 填的是项目部署的地址 替换为你的项目部署地址</p><p>        }</p><p>    }</p><p><strong>负载均衡 upstream</strong></p><p>负载均衡后的地址为 8090</p><p>    server {</p><p>        listen       8090;</p><p>        server_name  localhost;</p><p>        location &#x2F; {</p><p>            proxy_pass_header Server;</p><p>            proxy_set_header Host $http_host;</p><h1 id="proxy-set-header-Host-http-host-必须加上-否则-参数-json之类的-不能传递"><a href="#proxy-set-header-Host-http-host-必须加上-否则-参数-json之类的-不能传递" class="headerlink" title="proxy_set_header Host $http_host; 必须加上 否则 参数 json之类的 不能传递"></a>proxy_set_header Host $http_host; 必须加上 否则 参数 json之类的 不能传递</h1><p>            proxy_set_header X-Real-IP $remote_addr;</p><p>            proxy_set_header X-Scheme $scheme;</p><p>            proxy_pass <a href="http://suning/_load/_balance">http://suning\_load\_balance</a>;</p><p>#proxy_pass 填的是负载均衡地址 不是项目部署的地址 注意与上面的区别</p><p>        }</p><p>    }</p><p>    upstream suning_load_balance{</p><p>        server localhost:9129;   </p><p>        server localhost:9130;</p><p>#两个项目部署的地址 替换为你的项目部署地址</p><p>    }</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苹果mac电脑的end 键和home键在哪</title>
    <link href="/2019/06/27/%E8%8B%B9%E6%9E%9Cmac%E7%94%B5%E8%84%91%E7%9A%84end%20%E9%94%AE%E5%92%8Chome%E9%94%AE%E5%9C%A8%E5%93%AA/"/>
    <url>/2019/06/27/%E8%8B%B9%E6%9E%9Cmac%E7%94%B5%E8%84%91%E7%9A%84end%20%E9%94%AE%E5%92%8Chome%E9%94%AE%E5%9C%A8%E5%93%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="苹果mac电脑的end-键和home键在哪"><a href="#苹果mac电脑的end-键和home键在哪" class="headerlink" title="苹果mac电脑的end 键和home键在哪"></a>苹果mac电脑的end 键和home键在哪</h2><p>最新推荐文章于 2021-01-13 08:11:36 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2021-01-13 08:11:36 发布</p><p>在苹果Mac电脑的键盘上**没有**Home, End, Page UP, Page DOWN这些键，</p><p>可以通过用Fn键来组合得到同样的功能：</p><ul><li>Home键&#x3D;Fn+左方向、</li><li>End键&#x3D;Fn+右方向、</li><li>PageUP&#x3D;Fn+上方向、</li><li>PageDOWN&#x3D;Fn+下方向、向前</li><li>Delete&#x3D;Fn+delete键。</li></ul><p><strong>苹果笔记本上的Fn键功能很强大。</strong></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Window运行docker容器无法进行端口映射的问题</title>
    <link href="/2019/05/07/%E8%A7%A3%E5%86%B3Window%E8%BF%90%E8%A1%8Cdocker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2019/05/07/%E8%A7%A3%E5%86%B3Window%E8%BF%90%E8%A1%8Cdocker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="解决Window运行docker容器无法进行端口映射的问题"><a href="#解决Window运行docker容器无法进行端口映射的问题" class="headerlink" title="解决Window运行docker容器无法进行端口映射的问题"></a>解决Window运行docker容器无法进行端口映射的问题</h2><p>最新推荐文章于 2024-01-02 11:44:25 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-02 11:44:25 发布</p><p>在安装了一个Windows下安装了docker，并尝试在其中运行Nginx服务，但映射完毕之后，在主机的浏览器中，打开localhost:port无法访问对应的服务。</p><p>原因：docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows。</p><p>找到这个Linux的ip地址，一般情况下这个地址是192.168.99.100（docker-machine ip default 命令查找），然后在Windows的浏览器中，输入这个地址，加上服务的端口即可启用</p><p>如docker run -d -p 8080:80 nginx</p><p>后再windows上访问 <a href="http://192.168.99.100:8080/%E5%8D%B3%E5%8F%AF">http://192.168.99.100:8080/即可</a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分表与分库使用场景以及设计方式</title>
    <link href="/2019/04/29/%E5%88%86%E8%A1%A8%E4%B8%8E%E5%88%86%E5%BA%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/04/29/%E5%88%86%E8%A1%A8%E4%B8%8E%E5%88%86%E5%BA%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>一. 分表</p><p>      场景：对于大型的互联网应用来说，数据库单表的记录行数可能达到千万级甚至是亿级，并且数据库面临着极高的并发访问。采用Master-Slave复制模式的MySQL架构，</p><p>只能够对数据库的读进行扩展，而对数据库的写入操作还是集中在Master上，并且单个Master挂载的Slave也不可能无限制多，Slave的数量受到Master能力和负载的限制。</p><p>因此，需要对数据库的吞吐能力进行进一步的扩展，以满足高并发访问与海量数据存储的需要！</p><p>      对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！</p><p>      在分表之前，首先需要选择适当的分表策略，使得数据能够较为均衡地分不到多张表中，并且不影响正常的查询！</p><p>      对于互联网企业来说，大部分数据都是与用户关联的，因此，用户id是最常用的分表字段。因为大部分查询都需要带上用户id，这样既不影响查询，又能够使数据较为均衡地</p><p>分布到各个表中(当然，有的场景也可能会出现冷热数据分布不均衡的情况)，如下图：</p><p>假设有一张表记录用户购买信息的订单表order，由于order表记录条数太多，将被拆分成256张表。</p><p>拆分的记录根据user_id%256取得对应的表进行存储，前台应用则根据对应的user_id%256，找到对应订单存储的表进行访问。</p><p>这样一来，user_id便成为一个必需的查询条件，否则将会由于无法定位数据存储的表而无法对数据进行访问。</p><p>注：拆分后表的数量一般为2的n次方，就是上面拆分成256张表的由来！</p><p>假设order表结构如下：</p><p>create table order_(<br> order_id bigint(20) primary key auto_increment,<br> user_id bigint(20),<br> user_nick varchar(50),<br> auction_id bigint(20),<br> auction_title bigint(20),<br> price bigint(20),<br> auction_cat varchar(200),<br> seller_id bigint(20),<br> seller_nick varchar(50)<br>)</p><p>那么分表以后，假设user_id &#x3D; 257,并且auction_id &#x3D; 100,需要根据auction_id来查询对应的订单信息，则对应的SQL语句如下：<br>select * from order_1 where user_id&#x3D;257 and auction_id &#x3D; 100;</p><p>其中，order_1是根据257%256计算得出，表示分表之后的第一张order表。</p><p>二. 分库</p><p>   场景：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master</p><p>服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。</p><p>因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!</p><p>    与分表策略相似，分库可以采用通过一个关键字取模的方式，来对数据访问进行路由，如下图所示：</p><p>    还是之前的订单表，假设user_id 字段的值为258，将原有的单库分为256个库，那么应用程序对数据库的访问请求将被路由到第二个库(258%256 &#x3D; 2)。</p><p>三. 分库分表</p><p>    场景：有时数据库可能既面临着高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库既采用分表策略，又采用分库策略，以便同时扩展系统的</p><p>并发处理能力，以及提升单表的查询性能，这就是所谓的分库分表。</p><p>    分库分表的策略比前面的仅分库或者仅分表的策略要更为复杂，一种分库分表的路由策略如下：</p><p>    1. 中间变量 &#x3D; user_id % (分库数量 * 每个库的表数量)</p><p>    2. 库 &#x3D; 取整数 (中间变量 &#x2F; 每个库的表数量)</p><p>    3. 表 &#x3D; 中间变量 % 每个库的表数量</p><p>同样采用user_id作为路由字段，首先使用user_id 对库数量*每个库表的数量取模，得到一个中间变量；然后使用中间变量除以每个库表的数量，取整，便得到</p><p>对应的库；而中间变量对每个库表的数量取模，即得到对应的表。</p><p>分库分表策略详细过程如下：</p><p>假设将原来的单库单表order拆分成256个库，每个库包含1024个表，那么按照前面所提到的路由策略，对于user_id&#x3D;262145 的访问，路由的计算过程如下：</p><p>1.  中间变量 &#x3D; 262145 % (256 * 1024) &#x3D; 1</p><p>2.  库 &#x3D; 取整 (1&#x2F;1024) &#x3D; 0</p><p>3.  表 &#x3D; 1 % 1024 &#x3D; 1</p><p>这就意味着，对于user_id&#x3D;262145 的订单记录的查询和修改，将被路由到第0个库的第1个order_1表中执行！！！</p><p>-——————– <br>作者：不知道取啥昵称 <br>来源：CSDN <br>原文：<a href="https://blog.csdn.net/winy/_lm/article/details/50708493">https://blog.csdn.net/winy\_lm/article/details/50708493</a> <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgreSQL 字段如何设置自增长</title>
    <link href="/2019/03/28/postgreSQL%20%E5%AD%97%E6%AE%B5%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E9%95%BF/"/>
    <url>/2019/03/28/postgreSQL%20%E5%AD%97%E6%AE%B5%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="postgreSQL-字段如何设置自增长"><a href="#postgreSQL-字段如何设置自增长" class="headerlink" title="postgreSQL 字段如何设置自增长"></a>postgreSQL 字段如何设置自增长</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 于 2019-03-28 10:21:29 发布</p><p>postgreSQL 自增需要使用序列</p><p>1.使用SERIAL</p><ol><li><p><code>CREATE TABLE users</code></p></li><li><p><code>(</code></p></li><li><p><code>id SERIAL primary key ,</code></p></li><li><p><code>name character varying,</code></p></li><li><p><code>password character varying</code></p></li><li><p><code>)</code></p></li></ol><p>自动创建名为users_id_seq的序列，且MAXVALUE&#x3D;9223372036854775807</p><p>其余值为1</p><p>2.先创建序列，然后设置字段的自增</p><ol><li><p><code>CREATE SEQUENCE users_id_seq</code></p></li><li><p><code>START WITH 1</code></p></li><li><p><code>INCREMENT BY 1</code></p></li><li><p><code>NO MINVALUE</code></p></li><li><p><code>NO MAXVALUE</code></p></li><li><p><code>CACHE 1;</code></p></li><li><p><code>alter table users alter column id set default nextval(&#39;users_id_seq&#39;);</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五种Sublime同时快速编辑多行内容</title>
    <link href="/2019/03/21/%E4%BA%94%E7%A7%8DSublime%E5%90%8C%E6%97%B6%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91%E5%A4%9A%E8%A1%8C%E5%86%85%E5%AE%B9/"/>
    <url>/2019/03/21/%E4%BA%94%E7%A7%8DSublime%E5%90%8C%E6%97%B6%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91%E5%A4%9A%E8%A1%8C%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="五种Sublime同时快速编辑多行内容"><a href="#五种Sublime同时快速编辑多行内容" class="headerlink" title="五种Sublime同时快速编辑多行内容"></a>五种Sublime同时快速编辑多行内容</h2><p>最新推荐文章于 2023-04-24 10:29:40 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-04-24 10:29:40 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>众所周知，Sublime text 3是一个非常强大的前端ide<br>下面提供五种Sublime text 3同时快速编辑多行内容</p><p>下面就来看下具体的五种方式吧：<br>1，鼠标选中多行，按下 Ctrl Shift L (Command Shift L) 即可同时编辑这些行； <br>2，鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑； <br>3，鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑； <br>4，Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择； <br>5，Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抛弃图形化管理，数据库从创建库到高级查询用到的sql语句（持续更新）</title>
    <link href="/2019/02/26/%E6%8A%9B%E5%BC%83%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%AE%A1%E7%90%86%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%BA%93%E5%88%B0%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%E7%94%A8%E5%88%B0%E7%9A%84sql%E8%AF%AD%E5%8F%A5%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <url>/2019/02/26/%E6%8A%9B%E5%BC%83%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%AE%A1%E7%90%86%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%BA%93%E5%88%B0%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%E7%94%A8%E5%88%B0%E7%9A%84sql%E8%AF%AD%E5%8F%A5%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>        <strong>前言:现在后端数据库有各种各样的数据库图形化管理软件，什么navicat、dbeaver、pgsql admin等等，但是作为一个后端程序员，我们不能过度依赖图形化管理软件，否则用多了，在需要写高级的sql的时候或者面试的时候便会写不出来。</strong></p><p><strong>首先是创建一个数据库并指定编码：</strong></p><p><strong>create database mall_test character set utf-8 collate utf8_general_ci;</strong></p><p><strong>显示所有的数据库：</strong></p><p><strong>show databases;</strong></p><p><strong>使用刚刚创建的数据库：</strong></p><p><strong>use mall_test;</strong></p><p><strong>创建一张表：</strong></p><p><strong>create table `order`(<br>id int primary key auto_increment,<br>userid int,<br>`desc` varchar(20),<br>time datetime);</strong></p><p><strong>注意order desc 在mysql中是倒序的意思要注意加上``转义   自增主键是 primary key auto_increment</strong></p><p><strong>插入数据：</strong></p><p><strong>insert into `order`(userid,`desc`,time) values(1,11,now()),(2,22,now()),(3,33,now());</strong></p><p><strong>可以插入多点数据 以供查询</strong></p><p><strong>now()是mysql查询系统当前时间函数</strong></p><p><strong>查询全部数据：</strong></p><p><strong>select * from  `order`;</strong></p><p><strong>查询每个用户的最近一个订单：</strong></p><p><strong>select id,userid,max(`time`) as earliest_time from `order` group by userid;</strong></p><p><strong>复制表：</strong></p><p><strong>insert into tableA select * from tableB</strong></p><p><strong>tableA 与tableB 结构相同</strong></p><p><strong>每个用户累计查询：</strong></p><p><strong>需求：</strong></p><p>查询年龄在18-25的<strong>充值金额总和</strong>大于1000的用户</p><p><strong>测试数据：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html">create table if not exists user_amount<br>(<br> id serial not null<br>  constraint user_pkey<br>   primary key,<br> name varchar,<br> age integer,<br> amount integer<br>)<br>;<br><br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (1, &#x27;way&#x27;, 24, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (2, &#x27;way&#x27;, 24, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (3, &#x27;way&#x27;, 24, 300);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (4, &#x27;way&#x27;, 24, 500);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (5, &#x27;way&#x27;, 24, 600);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (6, &#x27;way&#x27;, 24, 800);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (7, &#x27;may&#x27;, 26, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (8, &#x27;may&#x27;, 26, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (9, &#x27;may&#x27;, 26, 800);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (10, &#x27;may&#x27;, 26, 300);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (11, &#x27;tom&#x27;, 19, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (12, &#x27;tom&#x27;, 19, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (13, &#x27;tom&#x27;, 19, 800);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (14, &#x27;tom&#x27;, 19, 300);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (15, &#x27;tom&#x27;, 19, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (16, &#x27;tom&#x27;, 19, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (17, &#x27;tom&#x27;, 19, 800);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (18, &#x27;tom&#x27;, 19, 300);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (19, &#x27;jay&#x27;, 19, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (20, &#x27;jay&#x27;, 19, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (21, &#x27;kay&#x27;, 30, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (22, &#x27;kay&#x27;, 30, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (23, &#x27;mike&#x27;, 22, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (24, &#x27;mike&#x27;, 22, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (25, &#x27;coco&#x27;, 11, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (26, &#x27;coco&#x27;, 11, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (27, &#x27;yoyo&#x27;, 21, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (28, &#x27;yoyo&#x27;, 21, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (29, &#x27;yoyo&#x27;, 21, 500);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (30, &#x27;yoyo&#x27;, 21, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (31, &#x27;yoyo&#x27;, 21, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (32, &#x27;yoyo&#x27;, 21, 500);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (33, &#x27;jenny&#x27;, 33, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (34, &#x27;jenny&#x27;, 33, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (35, &#x27;jenny&#x27;, 33, 500);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (36, &#x27;jenny&#x27;, 33, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (37, &#x27;jenny&#x27;, 33, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (38, &#x27;jenny&#x27;, 33, 500);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (39, &#x27;jerry&#x27;, 25, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (40, &#x27;jerry&#x27;, 25, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (41, &#x27;jerry&#x27;, 25, 500);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (42, &#x27;jerry&#x27;, 25, 100);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (43, &#x27;jerry&#x27;, 25, 200);<br>INSERT INTO public.user_amount (id, name, age, amount) VALUES (44, &#x27;jerry&#x27;, 25, 500);<br></code></pre></td></tr></table></figure><p><strong>SQL:</strong></p><p><strong>select * from (select name,SUM(amount) as total_amount  from user_amount where age&lt;&#x3D;25 and age&gt;&#x3D;18 group by name) as new_table where total_amount&gt;1000;</strong></p><p><strong>结果：</strong></p><p> <strong>name  | total_amount<br>-——+————–<br> jerry |         1600<br> tom   |         2800<br> way   |         2500<br> yoyo  |         1600</strong></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML 剖析（2） —— 类图关联和时序图</title>
    <link href="/2019/02/13/UML%20%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%20%E2%80%94%E2%80%94%20%E7%B1%BB%E5%9B%BE%E5%85%B3%E8%81%94%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <url>/2019/02/13/UML%20%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%20%E2%80%94%E2%80%94%20%E7%B1%BB%E5%9B%BE%E5%85%B3%E8%81%94%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="UML-剖析（2）-——-类图关联和时序图"><a href="#UML-剖析（2）-——-类图关联和时序图" class="headerlink" title="UML 剖析（2） —— 类图关联和时序图"></a>UML 剖析（2） —— 类图关联和时序图</h2><p>上篇文章讲解完类图实体，现在讲解类图关联，如果没阅读过类图实体的那篇文章，链接在这：<a href="https://juejin.im/post/5a6984c06fb9a01c9140954c">UML 剖析（1） —— 类图实体</a> ，这节继续还是使用 StarUML 来讲解。</p><h2 id="1-类图关联"><a href="#1-类图关联" class="headerlink" title="1. 类图关联"></a>1. 类图关联</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c31955a34e72?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Classes(Basic)"></p><p>下面一个一个讲解上图的关联属性。</p><h3 id="1-2-Association"><a href="#1-2-Association" class="headerlink" title="1.2 Association"></a>1.2 Association</h3><p>Association 是双向关联的意思，比如老师与学生就是一个双向关联的关系。举例如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319559f0afd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Association"></p><p>上面这个图 Student 的 1..* 的意思一个到多个的意思，也就是代表一个 Teacher 对象对应多个 Student。</p><h3 id="1-3-Directed-Association"><a href="#1-3-Directed-Association" class="headerlink" title="1.3 Directed Association"></a>1.3 Directed Association</h3><p>这个关联是有方向关联的意思，举例图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319563d5d03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Directed Association"></p><p>这个的意思是就是被关联类 B 以类属性出现在类 A。</p><h3 id="1-4-Aggregation"><a href="#1-4-Aggregation" class="headerlink" title="1.4 Aggregation"></a>1.4 Aggregation</h3><p>这个是聚合的意思，体现了整体和部分的关系。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c3195806a45d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Aggregation"></p><p>上图的意思就是一个 School 类拥有一个或多个 Student 类。</p><h3 id="1-5-Composition"><a href="#1-5-Composition" class="headerlink" title="1.5 Composition"></a>1.5 Composition</h3><p>是一种比 Aggregation 更强的聚合关系，类似于孕妇与胎儿的关系，胎儿是依附于孕妇的，如果孕妇死了，胎儿也不能生存。举例如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c31956b936be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Composition"></p><h3 id="1-6-Dependency"><a href="#1-6-Dependency" class="headerlink" title="1.6 Dependency"></a>1.6 Dependency</h3><p>这个的意思其实就是一个类依赖另一个类，举例来说就是一个类作为参数在另一个类的方法中作为调用。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319577986d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Dependency"></p><h3 id="1-7-Generalization"><a href="#1-7-Generalization" class="headerlink" title="1.7 Generalization"></a>1.7 Generalization</h3><p>这个的意思是泛化关系，表示一个类对另一个类的继承。下图就是 A 继承 B 的意思。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c31980cbca0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Generalization"></p><h3 id="1-8-Interface-Realization"><a href="#1-8-Interface-Realization" class="headerlink" title="1.8 Interface Realization"></a>1.8 Interface Realization</h3><p>这个也非常简单，就是接口实现的意思。举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c31980943758?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Interface Realization"></p><h2 id="2-时序图"><a href="#2-时序图" class="headerlink" title="2. 时序图"></a>2. 时序图</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>时序图其实就是对象之间传递消息的时间顺序。现在还是使用 StarUML 来讲解时序图的元素。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c31981400452?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c3198312d5a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="2-2-Lifeline"><a href="#2-2-Lifeline" class="headerlink" title="2.2 Lifeline"></a>2.2 Lifeline</h3><p>这个的意思就是一个对象，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319845d6db7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Lifeline"></p><h3 id="2-3-Message"><a href="#2-3-Message" class="headerlink" title="2.3 Message"></a>2.3 Message</h3><p>这个的意思就是发送一条普通消息，比如用户发送一条登录的消息给服务器，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c3198812cfb9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Message"></p><h3 id="2-4-Self-Message"><a href="#2-4-Self-Message" class="headerlink" title="2.4 Self Message"></a>2.4 Self Message</h3><p>这个的意思就是自己发送消息给自己，比如一个对象的一个方法调用了本对象的另一个方法，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319a3017de5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Self Message"></p><h3 id="2-5-Async-Message"><a href="#2-5-Async-Message" class="headerlink" title="2.5 Async Message"></a>2.5 Async Message</h3><p>这个的意思是异步消息，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319a579e7a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Async Message"></p><p>这个图的意思就是 User 发出 Login 的消息给 Server，Server 发送保存用户消息给到数据库，注意这里的消息是异步消息。</p><h3 id="2-6-Reply-Message"><a href="#2-6-Reply-Message" class="headerlink" title="2.6 Reply Message"></a>2.6 Reply Message</h3><p>这里的意思是回调消息，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319a579e7a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Reply Message"></p><p>上图的意思就是 User 发出 Login 的消息给 Server 后，Server 同时发出异步消息给数据库和登录结果给到用户。</p><h3 id="2-7-Create-Message"><a href="#2-7-Create-Message" class="headerlink" title="2.7 Create Message"></a>2.7 Create Message</h3><p>这个的意思就是创建一个对象，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319a80c8eb8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Create Message"></p><h3 id="2-8-Delete-Message"><a href="#2-8-Delete-Message" class="headerlink" title="2.8 Delete Message"></a>2.8 Delete Message</h3><p>这个的意思是销毁一个对象，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319a8aaefea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Delete Message"></p><h3 id="2-9-Async-Signal-Message"><a href="#2-9-Async-Signal-Message" class="headerlink" title="2.9 Async Signal Message"></a>2.9 Async Signal Message</h3><p>这个的意思就是发送一个信号消息，意思就是当某个对象达到某个条件后就会自动发送一个信号消息给另一个对象，类似于观察者模式。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319ada0f23b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Async Signal Message"></p><h3 id="2-10-Found-Message"><a href="#2-10-Found-Message" class="headerlink" title="2.10 Found Message"></a>2.10 Found Message</h3><p>这个的意思就是发送一个不知道来源的消息，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319b83675b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Found Message"></p><h3 id="2-11-Lost-Message"><a href="#2-11-Lost-Message" class="headerlink" title="2.11 Lost Message"></a>2.11 Lost Message</h3><p>这个的意思就是消息发送到一个不知道来源的地方，也可以说消息没有到达目的地，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319c38b0e19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Lost Message"></p><h3 id="2-12-Endpoint"><a href="#2-12-Endpoint" class="headerlink" title="2.12 Endpoint"></a>2.12 Endpoint</h3><p>这个的意思就是一个不知来源的消息对象，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319caf8f555?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Endpoint"></p><h3 id="2-13-Gate"><a href="#2-13-Gate" class="headerlink" title="2.13 Gate"></a>2.13 Gate</h3><p>这个的意思用于在时序图外与图内的消息交互，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319d33bd790?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Gate"></p><p>上图的正方形就是 Gate。</p><h3 id="2-14-State-Invariant"><a href="#2-14-State-Invariant" class="headerlink" title="2.14 State Invariant"></a>2.14 State Invariant</h3><p>这个的意思就是约束某个对象要在某一个状态下，举例如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319d9f68994?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="State Invariant"></p><p>这个的意思就是说在 start 开始前，Task 必须要在 Finish 状态。</p><h3 id="2-15-Combined-Fragment"><a href="#2-15-Combined-Fragment" class="headerlink" title="2.15 Combined Fragment"></a>2.15 Combined Fragment</h3><p>这个的翻译叫组合片段，它是用来解决交互执行的条件和方式。 组合片段常用的有这么几种：</p><table><thead><tr><th>类型</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>alt（alternatives）</td><td>选择</td><td>包含一个片段列表，这个片段列表有备选的消息序列，每次只能走一个消息序列</td></tr><tr><td>opt（option)</td><td>选项</td><td>包含一个可能会发生的消息序列</td></tr><tr><td>loop（iteration）</td><td>重复</td><td>包含一个可以重复的消息序列</td></tr><tr><td>par（parallel）</td><td>并行</td><td>包含一个可以并行的消息序列</td></tr><tr><td>break（break）</td><td>中断</td><td>如果执行了此部分则放弃了序列的其他部分的执行，可用于中断 loop 片段</td></tr></tbody></table><p>以下来各自举例说明：</p><h4 id="2-15-1-alt（alternatives）"><a href="#2-15-1-alt（alternatives）" class="headerlink" title="2.15.1 alt（alternatives）"></a>2.15.1 alt（alternatives）</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319dd3291ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="alt（alternatives）"></p><p>上图的意思就是当满足了 a &gt; 1 条件后，就会执行 Message1，否则执行 Message2。</p><h4 id="2-15-2-opt（option"><a href="#2-15-2-opt（option" class="headerlink" title="2.15.2 opt（option)"></a>2.15.2 opt（option)</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319dd1833e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="opt（option)"></p><p>上图的意思就是当满足了 a &gt; 1 条件后，才会执行 Message1。</p><h4 id="2-15-3-loop（iteration）"><a href="#2-15-3-loop（iteration）" class="headerlink" title="2.15.3 loop（iteration）"></a>2.15.3 loop（iteration）</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319eb8056db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="loop（iteration）"></p><p>上图的意思是不停重复发送 Message1 消息。如果要限定 loop 的次数的话也可以按下图这样：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319ed68ca17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="loop(10)"></p><p>这样就代表这个循环重复了 10 次。</p><h4 id="2-15-4-par（parallel）"><a href="#2-15-4-par（parallel）" class="headerlink" title="2.15.4 par（parallel）"></a>2.15.4 par（parallel）</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319f591a4ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="par（parallel）"></p><p>上图的意思就是并行发送三条消息。</p><h4 id="2-15-6-break（break）"><a href="#2-15-6-break（break）" class="headerlink" title="2.15.6 break（break）"></a>2.15.6 break（break）</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319fbdf712b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="break（break）"></p><p>上图的意思就是当 a &gt; 0 时，就会跳出循环，发送消息到 ClassC。</p><p>常用的组合片段大概就是这些，如果各位对其他片段有兴趣的话，可以自行研究，这里就不再细说了。</p><h3 id="2-16-Continuation"><a href="#2-16-Continuation" class="headerlink" title="2.16 Continuation"></a>2.16 Continuation</h3><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c319ff8fefd4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Continuation"></p><p>这个的意思用来表示这个序列的作用。</p><h3 id="2-17-Interaction-Use"><a href="#2-17-Interaction-Use" class="headerlink" title="2.17 Interaction Use"></a>2.17 Interaction Use</h3><p>这个的意思就是用来描述两个对象的交互现象，举例如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612c31a035fd7e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Interaction Use"></p><p>这个的意思就是 User 和 UserManager 的交互结果，User 使用 id 和 password 作为参数，UserManager 返回 result 作为 结果。</p><p>参考书籍与文章：</p><p><a href="https://link.juejin.im/?target=https://link.jianshu.com/?t=https%253A%252F%252Fbook.douban.com%252Fsubject%252F1792387%252F">《UML和模式应用》</a></p><p><a href="https://link.juejin.im/?target=https://link.jianshu.com/?t=https%253A%252F%252Fbook.douban.com%252Fsubject%252F1792387%252F">《大象：Thinking in UML》</a></p><p><a href="https://link.juejin.im/?target=https://www.uml-diagrams.org/interaction-message.html">UML Message</a></p><p><a href="https://link.juejin.im/?target=https://www.uml-diagrams.org/sequence-diagrams.html">UML Sequence Diagrams</a></p><p>原文：<a href="https://juejin.im/post/5a69857a6fb9a01c952647e1">https://juejin.im/post/5a69857a6fb9a01c952647e1</a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Future与Callable</title>
    <link href="/2019/02/12/%E7%90%86%E8%A7%A3Future%E4%B8%8ECallable/"/>
    <url>/2019/02/12/%E7%90%86%E8%A7%A3Future%E4%B8%8ECallable/</url>
    
    <content type="html"><![CDATA[<p>先上一个场景：假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。</p><p>实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。</p><p>但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。</p><p>模拟代码1：</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>package test;</p><p>public class CommonCook {</p><pre><code class="hljs">public static void main(String\[\] args) throws InterruptedException &#123;    long startTime = System.currentTimeMillis();    // 第一步 网购厨具    OnlineShopping thread = new OnlineShopping();    thread.start();    thread.join();  // 保证厨具送到    // 第二步 去超市购买食材    Thread.sleep(2000);  // 模拟购买食材时间    Shicai shicai = new Shicai();    System.out.println(&quot;第二步：食材到位&quot;);    // 第三步 用厨具烹饪食材    System.out.println(&quot;第三步：开始展现厨艺&quot;);    cook(thread.chuju, shicai);        System.out.println(&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);&#125;// 网购厨具线程static class OnlineShopping extends Thread &#123;        private Chuju chuju;    @Override    public void run() &#123;        System.out.println(&quot;第一步：下单&quot;);        System.out.println(&quot;第一步：等待送货&quot;);        try &#123;            Thread.sleep(5000);  // 模拟送货时间        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;第一步：快递送到&quot;);        chuju = new Chuju();    &#125;    &#125;//  用厨具烹饪食材static void cook(Chuju chuju, Shicai shicai) &#123;&#125;// 厨具类static class Chuju &#123;&#125;// 食材类static class Shicai &#123;&#125;</code></pre><p>} </p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>运行结果：</p><p>第一步：下单<br>第一步：等待送货<br>第一步：快递送到<br>第二步：食材到位<br>第三步：开始展现厨艺<br>总共用时7013ms</p><p>可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。</p><p>有人问了，不阻塞主线程行不行？？？</p><p>不行！！！</p><p>从代码来看的话，run方法不执行完，属性chuju就没有被赋值，还是null。换句话说，没有厨具，怎么做饭。</p><p>Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。</p><p>面对这种尴尬的处境，程序员就会想：在子线程run方法计算的期间，能不能在主线程里面继续异步执行？？？</p><p>Where there is a will，there is a way！！！</p><p>这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。</p><p>模拟代码2：</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>package test;</p><p>import java.util.concurrent.Callable;<br>import java.util.concurrent.ExecutionException;<br>import java.util.concurrent.FutureTask;</p><p>public class FutureCook {</p><pre><code class="hljs">public static void main(String\[\] args) throws InterruptedException, ExecutionException &#123;    long startTime = System.currentTimeMillis();    // 第一步 网购厨具    Callable&lt;Chuju&gt; onlineShopping = new Callable&lt;Chuju&gt;() &#123;        @Override        public Chuju call() throws Exception &#123;            System.out.println(&quot;第一步：下单&quot;);            System.out.println(&quot;第一步：等待送货&quot;);            Thread.sleep(5000);  // 模拟送货时间            System.out.println(&quot;第一步：快递送到&quot;);            return new Chuju();        &#125;            &#125;;    FutureTask&lt;Chuju&gt; task = new FutureTask&lt;Chuju&gt;(onlineShopping);    new Thread(task).start();    // 第二步 去超市购买食材    Thread.sleep(2000);  // 模拟购买食材时间    Shicai shicai = new Shicai();    System.out.println(&quot;第二步：食材到位&quot;);    // 第三步 用厨具烹饪食材    if (!task.isDone()) &#123;  // 联系快递员，询问是否到货        System.out.println(&quot;第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）&quot;);    &#125;    Chuju chuju = task.get();    System.out.println(&quot;第三步：厨具到位，开始展现厨艺&quot;);    cook(chuju, shicai);        System.out.println(&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);&#125;//  用厨具烹饪食材static void cook(Chuju chuju, Shicai shicai) &#123;&#125;// 厨具类static class Chuju &#123;&#125;// 食材类static class Shicai &#123;&#125;</code></pre><p>}</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>运行结果：</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>第一步：下单<br>第一步：等待送货<br>第二步：食材到位<br>第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）<br>第一步：快递送到<br>第三步：厨具到位，开始展现厨艺<br>总共用时5005ms</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p> 可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。</p><p>好神奇，有没有。</p><p>下面具体分析一下第二段代码：</p><p><strong>1）</strong>把耗时的网购厨具逻辑，封装到了一个Callable的call方法里面。</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>public interface Callable<V> {<br>    &#x2F;**<br>     * Computes a result, or throws an exception if unable to do so.<br>     *<br>     * @return computed result<br>     * @throws Exception if unable to compute a result<br>     *&#x2F;<br>    V call() throws Exception;<br>}</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p> Callable接口可以看作是Runnable接口的补充，call方法带有返回值，并且可以抛出异常。</p><p><strong>2）</strong>把Callable实例当作参数，生成一个FutureTask的对象，然后把这个对象当作一个Runnable，作为参数另起线程。</p><p>public class FutureTask<V> implements RunnableFuture<V></p><p>public interface RunnableFuture<V> extends Runnable, Future<V></p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>public interface Future<V> {</p><pre><code class="hljs">boolean cancel(boolean mayInterruptIfRunning);boolean isCancelled();boolean isDone();V get() throws InterruptedException, ExecutionException;V get(long timeout, TimeUnit unit)    throws InterruptedException, ExecutionException, TimeoutException;</code></pre><p>}</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>这个继承体系中的核心接口是Future。Future的核心思想是：一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去<em><strong>控制</strong></em>方法f的计算过程。</p><p>原文 ：<a href="https://www.cnblogs.com/cz123/p/7693064.html">https://www.cnblogs.com/cz123/p/7693064.html</a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公司有代理如何使用git与npm</title>
    <link href="/2019/01/15/%E5%85%AC%E5%8F%B8%E6%9C%89%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E4%B8%8Enpm/"/>
    <url>/2019/01/15/%E5%85%AC%E5%8F%B8%E6%9C%89%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E4%B8%8Enpm/</url>
    
    <content type="html"><![CDATA[<h2 id="公司有代理如何使用git与npm"><a href="#公司有代理如何使用git与npm" class="headerlink" title="公司有代理如何使用git与npm"></a>公司有代理如何使用git与npm</h2><p>最新推荐文章于 2020-10-23 09:39:47 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2020-10-23 09:39:47 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>现在很多公司因为安全原因，很多都是内网使用代理上外网，但是这也造成很多开发人员不便，下面我将简单介绍一下如何在代理下使用git 和node的npm</p><p><strong>1.git</strong></p><p>git 使用代理命令</p><p>    git config –global http.proxy <a href="http://xxx:10110/">http://xxx:10110</a></p><p>            git config –global https.proxy <a href="https://xxx:10110/">https://xxx:10110</a></p><p>git 取消使用代理命令</p><p>     git config –global –unset http.proxy</p><p>            git config –global –unset https.proxy</p><p><strong>2.npm</strong></p><p>npm  使用代理命令</p><p>npm config set proxy <a href="http://xxx:10110/">http://xxx:10110</a></p><p>npm config set https-proxy <a href="https://xxx:10110/">https://xxx:10110</a></p><p>有时可能还要使用</p><p>npm config set strict-ssl false</p><p>npm取消使用代理命令</p><p>     npm config delete proxy</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度地图简单例子的使用</title>
    <link href="/2019/01/14/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/01/14/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="百度地图简单例子的使用"><a href="#百度地图简单例子的使用" class="headerlink" title="百度地图简单例子的使用"></a>百度地图简单例子的使用</h2><p>最新推荐文章于 2022-10-31 22:13:03 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-10-31 22:13:03 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><!DOCTYPE html><p>    </p><html>  <head>    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />    <title>Hello, World</title>    <style type="text/css">    html{height:100%}    body{height:100%;margin:0px;padding:0px}    #container{height:100%}    </style>    <script type="text/javascript" src="http://api.map.baidu.com/api?v=3.0&ak=lIwOjvNwoHLlBGjwq1BiWBNCjQqGY78E">  //v3.0版本的引用方式：src="http://api.map.baidu.com/api?v=3.0&ak=您的密钥"  </script>  </head>  <p>  <body>    </p><div id="container"></div>   <script type="text/javascript">   var map = new BMap.Map("container");  // 创建地图实例    var point = new BMap.Point(116.404, 39.915);  // 创建点坐标    map.centerAndZoom(point, 15);  // 初始化地图，设置中心点坐标和地图级别    var geolocation = new BMap.Geolocation();<p>function myFun(result){<br>    var cityName &#x3D; result.name;<br>    map.setCenter(cityName);<br>    alert(“当前定位城市:”+cityName);<br>}<br>var myCity &#x3D; new BMap.LocalCity();<br>myCity.get(myFun); <br></script>    </p></body>    </html>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于AES加解密java.security.InvalidKeyException的错误解决方法</title>
    <link href="/2018/12/24/%E5%85%B3%E4%BA%8EAES%E5%8A%A0%E8%A7%A3%E5%AF%86java.security.InvalidKeyException%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2018/12/24/%E5%85%B3%E4%BA%8EAES%E5%8A%A0%E8%A7%A3%E5%AF%86java.security.InvalidKeyException%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="关于AES加解密java-security-InvalidKeyException的错误解决方法"><a href="#关于AES加解密java-security-InvalidKeyException的错误解决方法" class="headerlink" title="关于AES加解密java.security.InvalidKeyException的错误解决方法"></a>关于AES加解密java.security.InvalidKeyException的错误解决方法</h2><p>最新推荐文章于 2023-11-22 17:55:03 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-11-22 17:55:03 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>最近springboot做项目时，在window上启动 调用服务没有问题，可是部署在linux后服务之间调用却出现了问题</p><p>debug看报错信息，刚开始看到的报错的信息</p><p>报的是javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher</p><p>以为是公司框架的AES加密解密方法的问题，一直修改调试，可是一直解决不了</p><p>后来仔细看debug发现有一个错误被捕获了没细看</p><p>报错信息是</p><p>org.springframework.http.converter.HttpMessageNotReadableException: I&#x2F;O error while reading input message; nested exception is java.io.IOException: java.lang.IllegalStateException: java.security.InvalidKeyException: No installedprovider supports this key: javax.crypto.spec.SecretKeySpec</p><p>这应该就是错误的根源了，经过大量的资料查询（google 百度）发现了java.security.InvalidKeyException: Illegal key size 异常. 因为密钥长度是受限制的, java运行时环境读到的是受限的policy文件. 文件位于${java_home}&#x2F;jre&#x2F;lib&#x2F;security, 这种限制是因为美国对软件出口的控制.   </p><p>处理方法: 在Java Oracle官方网站下载JCE无限制权限策略文件</p><p>JDK7的下载地址: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a><br>JDK8的下载地址: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html%C2%A0">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a> <br>下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt<br>如果安装了JRE，将两个jar文件放到%JRE_HOME%\lib\security目录下覆盖原来的文件<br>如果安装了JDK，还要将两个jar文件也放到%JDK_HOME%\jre\lib\security目录下覆盖原来文件</p><p>个人来说，我感觉这算是java开发中的一个大坑，在加密解密中应该会经常遇到所以特意记录一下</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java子类能不能继承父类synchronized关键字-</title>
    <link href="/2018/12/01/Java%E5%AD%90%E7%B1%BB%E8%83%BD%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BBsynchronized%E5%85%B3%E9%94%AE%E5%AD%97-/"/>
    <url>/2018/12/01/Java%E5%AD%90%E7%B1%BB%E8%83%BD%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BBsynchronized%E5%85%B3%E9%94%AE%E5%AD%97-/</url>
    
    <content type="html"><![CDATA[<p><strong>今天在Github 看Java synchronized方面的知识总结时</strong></p><p><strong>看到一个有趣的说法“子类不能继承父类的synchronized关键字”</strong></p><p><strong>我心里的第一个想法是：为什么子类不能继承父类的synchronized关键字呢</strong></p><p><strong>于是我决定用代码实践一下</strong></p><p><strong>首先，我先放上测试类主类的代码，运行哪个则注释其余的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java">​<br><span class="hljs-keyword">package</span> com.way.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        注意初始化不能放在for循环中,</span><br>        因为<span class="hljs-keyword">synchronized</span>是对象锁, 锁的是对象,<br>        如果每次<span class="hljs-keyword">for</span>循环中都新建了一个对象, 那么这把锁就毫无意义,怎样运行都是异步的效果<br><br><br>        <span class="hljs-type">Father</span> <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    father.method();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br><br><span class="hljs-comment">//        Son son = new Son();</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        for (int i =0;i&lt;5;i++) &#123;</span><br><span class="hljs-comment">//            new Thread(new Runnable() &#123;</span><br><span class="hljs-comment">//                @Override</span><br><span class="hljs-comment">//                public void run() &#123;</span><br><span class="hljs-comment">//                    son.method();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;).start();</span><br><span class="hljs-comment">//        &#125;</span><br><br><br><span class="hljs-comment">//        SonOverride sonOverride = new SonOverride();</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="hljs-comment">//            new Thread(new Runnable() &#123;</span><br><span class="hljs-comment">//                @Override</span><br><span class="hljs-comment">//                public void run() &#123;</span><br><span class="hljs-comment">//                    sonOverride.method();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;).start();</span><br><span class="hljs-comment">//        &#125;</span><br><br><br>    &#125;<br>&#125;<br><br>​<br></code></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F;        注意初始化不能放在for循环中,<br>&#x2F;&#x2F;        因为synchronized是对象锁, 锁的是对象,<br>&#x2F;&#x2F;        如果每次for循环中都新建了一个对象, 那么这把锁就毫无意义,怎样运行都是异步的效果</strong></p><p><strong>父类的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">​<br><span class="hljs-keyword">package</span> com.way.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AA&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;BB&quot;</span>);<br>    &#125;<br><br>&#125;<br><br>​<br></code></pre></td></tr></table></figure><p><strong>中间休眠一秒是为了有足够时间观察方法是否“同步”，否则太快的话是可能看不出来。</strong></p><p><strong>运行结果：</strong></p><p><strong><img src="https://img-blog.csdnimg.cn/20181201214646176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></strong></p><p><strong>可以看出AA——间隔一秒——BB是交替打印</strong></p><p><strong>然后，分别写两个子类，一个是直接继承上面的父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><strong><img src="https://img-blog.csdnimg.cn/20181201215205468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></strong></p><p><strong>可以看出跟父类是一样的，证明了是继承了父类的synchronized关键字</strong></p><p><strong>而另外一个则是继承并且重写了父类的方法，注意这里不要加上synchronized关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SonOverride</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;AAA &quot;</span>+Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;BBB &quot;</span>+Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><strong><img src="https://img-blog.csdnimg.cn/20181201215341489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></strong></p><p><strong>很明显这次运行结果是“异步的”，整个过程只间隔了一秒</strong></p><p><strong>倘若，我们在SonOverride中重写的方法中加上“Synchronized”关键字的话</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br></code></pre></td></tr></table></figure><p><strong>那么运行结果：</strong></p><p><strong><img src="https://img-blog.csdnimg.cn/20181201215547557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></strong></p><p><strong>可见效果跟直接继承父类类似。</strong></p><h4 id="显而易见，我们可以得出结论，加入父类方法中有synchronized关键字修饰，子类继承该父类的方法也有Synchronizde关键字的效果，但是如果重写该方法时不显式加上synchronized关键字时则不会有效果"><a href="#显而易见，我们可以得出结论，加入父类方法中有synchronized关键字修饰，子类继承该父类的方法也有Synchronizde关键字的效果，但是如果重写该方法时不显式加上synchronized关键字时则不会有效果" class="headerlink" title="显而易见，我们可以得出结论，加入父类方法中有synchronized关键字修饰，子类继承该父类的方法也有Synchronizde关键字的效果，但是如果重写该方法时不显式加上synchronized关键字时则不会有效果"></a><strong>显而易见，我们可以得出结论，加入父类方法中有synchronized关键字修饰，子类继承该父类的方法也有Synchronizde关键字的效果，但是如果重写该方法时不显式加上synchronized关键字时则不会有效果</strong></h4>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一张图说明线程状态变化</title>
    <link href="/2018/11/29/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8E%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/"/>
    <url>/2018/11/29/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8E%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>抵扣说明：</p><p>1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。<br>2.余额无法直接购买下载，可以购买VIP、付费专栏及课程。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么重写equals()的同时还得重写hashCode()</title>
    <link href="/2018/11/29/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals()%E7%9A%84%E5%90%8C%E6%97%B6%E8%BF%98%E5%BE%97%E9%87%8D%E5%86%99hashCode()/"/>
    <url>/2018/11/29/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals()%E7%9A%84%E5%90%8C%E6%97%B6%E8%BF%98%E5%BE%97%E9%87%8D%E5%86%99hashCode()/</url>
    
    <content type="html"><![CDATA[<p>这个问题之前我也很好奇，不过最后还是在书上得到了比较明朗的解释，当然这个问题主要是针对映射相关的操作（Map接口）。学过数据结构的同学都知道Map接口的类会使用到键对象的哈希码，当我们调用put方法或者get方法对Map容器进行操作时，都是根据键对象的哈希码来计算存储位置的，因此如果我们对哈希码的获取没有相关保证，就可能会得不到预期的结果。在java中，我们可以使用hashCode()来获取对象的哈希码，其值就是对象的存储地址，这个方法在Object类中声明，因此所有的子类都含有该方法。那我们先来认识一下hashCode()这个方法吧。hashCode的意思就是散列码，也就是哈希码，是由对象导出的一个整型值，散列码是没有规律的，如果x与y是两个不同的对象，那么x.hashCode()与y.hashCode()基本是不会相同的，注意是“基本”，还是有很小的几率会相同，因此两个对象hashCode一样并不能完全说明两个对象相等,下面通过String类的hashCode()计算一组散列码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">​<br><span class="hljs-keyword">package</span> com.way.test;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashCodeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> hash=<span class="hljs-number">0</span>;<br>        String s=<span class="hljs-string">&quot;ok&quot;</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>        <br>        System.out.println(s.hashCode()+<span class="hljs-string">&quot;  &quot;</span>+sb.hashCode());<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ok&quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>        System.out.println(t.hashCode()+<span class="hljs-string">&quot;  &quot;</span>+tb.hashCode());<br>    &#125;<br>    <br>&#125;<br><br>​<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>3548  1829164700</p><p>3548  2018699554</p><p>我们可以看出，字符串s与t拥有相同的散列码，这是因为字符串的散列码是由内容导出的。而字符串缓冲sb与tb却有着不同的散列码，这是因为StringBuilder没有重写hashCode方法，它的散列码是由Object类默认的hashCode方法计算出来的对象存储地址，所以散列码自然也就不同了。那么我们该如何重写出一个较好的hashCode方法呢，其实并不难，我们只要合理地组织对象的散列码，就能够让不同的对象产生比较均匀的散列码。例如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name.hashCode()+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(salary).hashCode() <br>                + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(sex).hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码我们通过合理的利用各个属性对象的散列码进行组合，最终便能产生一个相对比较好的或者说更加均匀的散列码，当然上面仅仅是个参考例子而已，我们也可以通过其他方式去实现，只要能使散列码更加均匀（所谓的均匀就是每个对象产生的散列码最好都不冲突）就行了。不过这里有点要注意的就是java 7中对hashCode方法做了两个改进，首先java发布者希望我们使用更加安全的调用方式来返回散列码，也就是使用null安全的方法Objects.hashCode（注意不是Object而是java.util.Objects）方法，这个方法的优点是如果参数为null，就只返回0，否则返回对象参数调用的hashCode的结果。Objects.hashCode 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> o != <span class="hljs-literal">null</span> ? o.hashCode() : <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因此我们修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> &#123;<br>    <span class="hljs-keyword">private</span>   String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(name)+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(salary).hashCode() <br>                + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(sex).hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>java 7还提供了另外一个方法java.util.Objects.hash(Object… objects),当我们需要组合多个散列值时可以调用该方法。进一步简化上述的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> &#123;<br>    <span class="hljs-keyword">private</span>   String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public int hashCode() &#123;</span><br><span class="hljs-comment">//        return Objects.hashCode(name)+new Double(salary).hashCode() </span><br><span class="hljs-comment">//                + new Integer(sex).hashCode();</span><br><span class="hljs-comment">//    &#125;</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name,salary,sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，到此hashCode()该介绍的我们都说了，还有一点要说的如果我们提供的是一个数值类型的变量的话，那么我们可以调用Arrays.hashCode()来计算它的散列码，这个散列码是由数组元素的散列码组成的。接下来我们回归到我们之前的问题，重写equals方法时也必须重写hashCode方法。在Java API文档中关于hashCode方法有以下几点规定（原文来自java深入解析一书）。</p><p>在java应用程序执行期间，如果在equals方法比较中所用的信息没有被修改，那么在同一个对象上多次调用hashCode方法时必须一致地返回相同的整数。如果多次执行同一个应用时，不要求该整数必须相同。</p><p><strong>如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。</strong></p><p>如果两个对象通过调用equals方法是不相等的，不要求这两个对象调用hashCode方法必须返回不同的整数。但是程序员应该意识到对不同的对象产生不同的hash值可以提供哈希表的性能。</p><p>通过前面的分析，我们知道在Object类中，hashCode方法是通过Object对象的地址计算出来的，因为Object对象只与自身相等，所以同一个对象的地址总是相等的，计算取得的哈希码也必然相等，对于不同的对象，由于地址不同，所获取的哈希码自然也不会相等。因此到这里我们就明白了，<strong>如果一个类重写了equals方法，但没有重写hashCode方法，将会直接违法了第2条规定</strong>，这样的话，如果我们通过映射表(Map接口)操作相关对象时，就无法达到我们预期想要的效果。如果大家不相信, 可以看看下面的例子（来自java深入解析一书）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String,Value&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Value&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;key&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;key&quot;</span>);    <br>        <span class="hljs-type">Value</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Value</span>(<span class="hljs-number">2</span>);<br>        map1.put(s1, value);<br>        System.out.println(<span class="hljs-string">&quot;s1.equals(s2):&quot;</span>+s1.equals(s2));<br>        System.out.println(<span class="hljs-string">&quot;map1.get(s1):&quot;</span>+map1.get(s1));<br>        System.out.println(<span class="hljs-string">&quot;map1.get(s2):&quot;</span>+map1.get(s2));<br>        <br>        <br>        Map&lt;Key,Value&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Key,Value&gt;();<br>        <span class="hljs-type">Key</span> <span class="hljs-variable">k1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Key</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-type">Key</span> <span class="hljs-variable">k2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Key</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>        map2.put(k1, value);<br>        System.out.println(<span class="hljs-string">&quot;k1.equals(k2):&quot;</span>+s1.equals(s2));<br>        System.out.println(<span class="hljs-string">&quot;map2.get(k1):&quot;</span>+map2.get(k1));<br>        System.out.println(<span class="hljs-string">&quot;map2.get(k2):&quot;</span>+map2.get(k2));<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 键</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>&#123;<br>        <span class="hljs-keyword">private</span> String k;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Key</span><span class="hljs-params">(String key)</span>&#123;<br>            <span class="hljs-built_in">this</span>.k=key;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>            <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Key)&#123;<br>                Key key=(Key)obj;<br>                <span class="hljs-keyword">return</span> k.equals(key.k);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 值</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> v;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Value</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span>&#123;<br>            <span class="hljs-built_in">this</span>.v=v;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;类Value的值－－&gt;&quot;</span>+v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码比较简单，我们就不过多解释了（注意Key类并没有重写hashCode方法），直接运行看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">s1.equals(s2):<span class="hljs-literal">true</span><br>map1.get(s1):类Value的值－－&gt;<span class="hljs-number">2</span><br>map1.get(s2):类Value的值－－&gt;<span class="hljs-number">2</span><br>k1.equals(k2):<span class="hljs-literal">true</span><br>map2.get(k1):类Value的值－－&gt;<span class="hljs-number">2</span><br>map2.get(k2):<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>对于s1和s2的结果，我们并不惊讶，因为相同的内容的s1和s2获取相同内的value这个很正常，因为String类重写了equals方法和hashCode方法，使其比较的是内容和获取的是内容的哈希码。但是对于k1和k2的结果就不太尽人意了，k1获取到的值是2，k2获取到的是null，这是为什么呢？想必大家已经发现了，Key只重写了equals方法并没有重写hashCode方法，这样的话，equals比较的确实是内容，而hashCode方法呢？<strong>没重写，那就肯定调用超类Object的hashCode方法，这样返回的不就是地址了吗</strong>？k1与k2属于两个不同的对象，返回的地址肯定不一样，所以现在我们知道调用map2.get(k2)为什么返回null了吧？那么该如何修改呢？很简单，我们要做也重写一下hashCode方法即可（如果参与equals方法比较的成员变量是引用类型的，则可以递归调用hashCode方法来实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> k.hashCode();<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">s1.equals(s2):<span class="hljs-literal">true</span><br>map1.get(s1):类Value的值－－&gt;<span class="hljs-number">2</span><br>map1.get(s2):类Value的值－－&gt;<span class="hljs-number">2</span><br>k1.equals(k2):<span class="hljs-literal">true</span><br>map2.get(k1):类Value的值－－&gt;<span class="hljs-number">2</span><br>map2.get(k2):类Value的值－－&gt;<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>本文有部分内容参考了其他博客</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Java实现几种常见的排序算法的思路</title>
    <link href="/2018/11/25/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <url>/2018/11/25/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="用Java实现几种常见的排序算法的思路"><a href="#用Java实现几种常见的排序算法的思路" class="headerlink" title="用Java实现几种常见的排序算法的思路"></a>用Java实现几种常见的排序算法的思路</h2><p>最新推荐文章于 2022-08-06 17:55:46 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p>置顶 <a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-08-06 17:55:46 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h4 id="一·选择排序"><a href="#一·选择排序" class="headerlink" title="一·选择排序"></a><strong>一·选择排序</strong></h4><p><strong>核心理解：每次选择一个最大的或者最小的放在i的位置，直至i循环了这个数组的length-1个元素</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; array.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (array[j] &lt; array[i]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];<br>                    array[i] = array[j];<br>                    array[j] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="二·冒泡排序"><a href="#二·冒泡排序" class="headerlink" title="二·冒泡排序"></a><strong>二·冒泡排序</strong></h4><p><strong>核心理解：元素之间相互比较，每轮排序把最大的（最小的）逐渐”浮上来“后，下一轮排序这个元素就不用再排序了；</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> array.length; i &gt;<span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i-<span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[j + <span class="hljs-number">1</span>] &lt; array[j]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                array[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三·插入排序"><a href="#三·插入排序" class="headerlink" title="三·插入排序"></a>三·插入排序</h4><p><strong>核心理解：每轮把数组分成两个，一个数组刚开始只有一个，从另外一个数组选择一个最大或者最小的插入到这个数组</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (array[i] &lt; array[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];<br>                    array[i] = array[j];<br>                    array[j] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="四·快速排序"><a href="#四·快速排序" class="headerlink" title="四·快速排序"></a>四·快速排序</h4><p><strong>核心理解：要理解快速排序的过程，有两个指针 low high，第一轮排序直至high low重合：，重合后，比基准值小的都在基准值左边，比基准值大的都在右边，然后根据递归思想 ，把基准值两边的元素再排序&#x2F;</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> array[low];<br><br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (array[high] &gt;= key &amp;&amp; low &lt; high) &#123;<br>            high--;<br>        &#125;<br>        <span class="hljs-comment">//这里之所以不用临时变量交换是因为是按高位先来</span><br>        array[low] = array[high];<br><br>        <span class="hljs-keyword">while</span> (array[low] &lt;= key &amp;&amp; low &lt; high) &#123;<br>            low++;<br>        &#125;<br><br>        <span class="hljs-comment">//这里之所以不用临时变量交换是因为是按高位先来</span><br>        array[high] = array[low];<br>    &#125;<br>    array[high] = key;<br>    <span class="hljs-comment">//得到的是划分后的基准的下标 基准左边都是比基准小的 右边都是比基准大的</span><br>    <span class="hljs-keyword">return</span> high;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> divide(array, low, high);<br>    quickSort(array, low, index - <span class="hljs-number">1</span>);<br>    quickSort(array, index + <span class="hljs-number">1</span>, high);<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="以上的算法不一定是最高效最优化的实现，但是算是比较容易理解的实现，若有不足的地方希望大家指出"><a href="#以上的算法不一定是最高效最优化的实现，但是算是比较容易理解的实现，若有不足的地方希望大家指出" class="headerlink" title="以上的算法不一定是最高效最优化的实现，但是算是比较容易理解的实现，若有不足的地方希望大家指出"></a><strong>以上的算法不一定是最高效最优化的实现，但是算是比较容易理解的实现，若有不足的地方希望大家指出</strong></h4>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一张图说明正向代理与反向代理的区别</title>
    <link href="/2018/11/22/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8E%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/11/22/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8E%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="一张图说明正向代理与反向代理的区别"><a href="#一张图说明正向代理与反向代理的区别" class="headerlink" title="一张图说明正向代理与反向代理的区别"></a>一张图说明正向代理与反向代理的区别</h2><p>最新推荐文章于 2022-01-13 17:20:25 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-01-13 17:20:25 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p><img src="https://upload-images.jianshu.io/upload_images/3257886-8ab4925e268f5780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>正向代理：需要配置代理服务器proxy的ip（域名）与端口，比如一些公司上外网的代理</p><p>反向代理：不需要配置，只要直接访问服务的地址，但是客户端根本不知道访问的是具体哪一台服务器主机</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP中application-x-www-form-urlencoded字符说明</title>
    <link href="/2018/11/21/HTTP%E4%B8%ADapplication-x-www-form-urlencoded%E5%AD%97%E7%AC%A6%E8%AF%B4%E6%98%8E/"/>
    <url>/2018/11/21/HTTP%E4%B8%ADapplication-x-www-form-urlencoded%E5%AD%97%E7%AC%A6%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP中application-x-www-form-urlencoded字符说明"><a href="#HTTP中application-x-www-form-urlencoded字符说明" class="headerlink" title="HTTP中application&#x2F;x-www-form-urlencoded字符说明"></a>HTTP中application&#x2F;x-www-form-urlencoded字符说明</h2><p>最新推荐文章于 2023-09-23 19:03:53 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-09-23 19:03:53 发布</p><p>一、概述<br>在学习ajax的时候，如果用post请求，需要设置如下代码。</p><p>ajax.setRequestHeader(“content-type”,”application&#x2F;x-www-form-urlencoded”);<br>1<br>虽然知道需要这么做，但是不知道application&#x2F;x-www-form-urlencoded表示什么意思。于是百度学习了下。</p><p>二、Form表单语法<br>在Form元素的语法中，EncType表明提交数据的格式 用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。 例如： application&#x2F;x-www-form-urlencoded： 窗体数据被编码为名称&#x2F;值对。这是标准的编码格式。 multipart&#x2F;form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分，这个一般文件上传时用。 text&#x2F;plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。 <br>补充</p><p>三、常用的编码方式<br>form的enctype属性为编码方式，常用有两种：application&#x2F;x-www-form-urlencoded和multipart&#x2F;form-data，默认为application&#x2F;x-www-form-urlencoded。</p><p>1.x-www-form-urlencoded<br>当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1&#x3D;value1&amp;name2&#x3D;value2…），然后把这个字串append到url后面，用?分割，加载这个新的url。</p><p>2.multipart&#x2F;form-data<br>当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 如果没有type&#x3D;file的控件，用默认的application&#x2F;x-www-form-urlencoded就可以了。 但是如果有type&#x3D;file的话，就要用到multipart&#x2F;form-data了。浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text&#x2F;plain),name(控件name)等信息，并加上分割符(boundary)。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql explain sql语句结果的type列 &amp; Extra列解释</title>
    <link href="/2018/10/25/Mysql%20explain%20sql%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%9C%E7%9A%84type%E5%88%97%20&amp;%20Extra%E5%88%97%E8%A7%A3%E9%87%8A/"/>
    <url>/2018/10/25/Mysql%20explain%20sql%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%9C%E7%9A%84type%E5%88%97%20&amp;%20Extra%E5%88%97%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p>explain 可以分析 select 语句的执行，即 MySQL 的“执行计划。</p><p>一、type 列</p><p>MySQL 在表里找到所需行的方式。包括（由左至右，由最差到最好）：<br>| All | index | range | ref | eq_ref | const,system | null |</p><p>ALL（所有）<br>全表扫描，MySQL 从头到尾扫描整张表查找行。<br>mysql&gt; explain select * from a\G<br>…<br>         type: ALL<br>如果加上 limit 如 select * from a limit 100 MySQL 会扫描 100 行，但扫描方式不会变，还是从头到尾扫描。</p><p>index（索引）<br>根据索引来读取数据，如果索引已包含了查询数据，只需扫描索引树，否则执行全表扫描和All类似；  <br>create table a(a_id int not null, key(a_id));<br>insert into a value(1),(2);<br>mysql&gt; explain select a_id from a\G<br>…<br>         type: index</p><p>range(范围)<br>以范围的形式扫描索引<br>建表：<br>create table a(a_id int not null, key(a_id));<br>insert into a values(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);<br>mysql&gt; explain select * from a where a_id &gt; 1\G<br>…<br>         type: range<br>…</p><p>IN 比较符也会用 range 表示：<br>mysql&gt; explain select * from a where a_id in (1,3,4)\G<br>…<br>         type: range<br>…</p><p>`<br>ref（引用）<br>非唯一性索引访问<br>建表：<br>create table a(a_id int not null, key(a_id));<br>insert into a values(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);<br>mysql&gt; explain select * from a where a_id&#x3D;1\G<br>…<br>         type: ref<br>…</p><p>eq_ref（等值引用）<br>使用有唯一性索引查找（主键或唯一性索引）<br>建表及插入数据：<br>create table a(id int primary key);<br>create table a_info(id int primary key, title char(1));<br>insert into a value(1),(2);<br>insert into a_info value(1, ‘a’),(2, ‘b’);<br>mysql&gt; explain select * from a join a_info using(id);<br>…+——–+——–+…<br>…| table  | type   |…<br>…+——–+——–+…<br>…| a      | index  |…<br>…| a_info | eq_ref |…<br>…+——–+——–+…<br>此时 a_info 每条记录与 a 一一对应，通过主键 id 关联起来，所以 a_info 的 type 为 eq_ref。<br>删除 a_info 的主键：ALTER TABLE  `a_info` DROP PRIMARY KEY;<br>现在 a_info 已经没有索引了：<br>mysql&gt; explain select * from a join a_info using(id);<br>+—-+…+——–+——–+…<br>| id |…| table  | type   |…<br>+—-+…+——–+——–+…<br>|  1 |…| a_info | ALL    |…<br>|  1 |…| a      | eq_ref |…<br>+—-+…+——–+——–+…<br>这次 MySQL 调整了执行顺序，先全表扫描 a_info 表，再对表 a 进行 eq_ref 查找，因为 a 表 id 还是主键。<br>删除 a 的主键：alter table a drop primary key;<br>现在 a 也没有索引了：<br>mysql&gt; explain select * from a join a_info using(id);<br>…+——–+——+…<br>…| table  | type |…<br>…+——–+——+…<br>…| a      | ALL  |…<br>…| a_info | ALL  |…<br>…+——–+——+…<br>现在两个表都使用全表扫描了。</p><p>建表及插入数据：<br>create table a(id int primary key);<br>create table a_info(id int, title char(1), key(id));<br>insert into a value(1),(2);<br>insert into a_info value(1, ‘a’),(2, ‘b’);<br>现在 a_info 表 id 列变为普通索引（非唯一性索引）：<br>mysql&gt; explain select * from a join a_info using(id) where a.id&#x3D;1;<br>…+——–+——-+…<br>…| table  | type  |…<br>…+——–+——-+…<br>…| a      | const |…<br>…| a_info | ref   |…<br>…+——–+——-+…<br>a_info 表 type 变为 ref 类型了。<br>所以，唯一性索引才会出现 eq_ref （非唯一性索引会出现 ref ），因为唯一，所以最多只返回一条记录，找到后无需继续查找，因此比 ref 更快。</p><p>const（常量连接）<br>被称为“常量”，这个词不好理解，不过出现 const 的话就表示发生下面两种情况：<br>在整个查询过程中这个表最多只会有一条匹配的行，比如主键 id&#x3D;1 就肯定只有一行，只需读取一次表数据便能取得所需的结果，且表数据在分解执行计划时读取。返回值直接放在 select 语句中，类似 select 1 AS f 。可以通过 extended 选择查看内部过程：</p><p>建表及插入数据：<br>create table a(id int primary key, c1 char(20) not null, c2 text not null, c3 text not null);<br>insert into a values(1, ‘asdfasdf’, ‘asdfasdf’, ‘asdfasdf’), (2, ‘asdfasdf’, ‘asdfasdf’, ‘asdfasdf’);<br>mysql&gt; explain extended select * from a where id&#x3D;1\G<br>…<br>         type: const<br>possible_keys: PRIMARY<br>          key: PRIMARY<br>…<br>用 show warnings 查看 MySQL 是如何优化的：<br>mysql&gt; show warnings\G<br>…<br>Message: select ‘1’ AS `id`,’asdfasdf’ AS `c1`,’asdfasdf’ AS `c2`,’asdfasdf’ AS<br>`c3` from `test`.`a` where 1<br>查询返回的结果为：<br>mysql&gt; select * from a where id&#x3D;1;<br>+—-+———-+———-+———-+<br>| id | c1       | c2       | c3       |<br>+—-+———-+———-+———-+<br>|  1 | asdfasdf | asdfasdf | asdfasdf |<br>+—-+———-+———-+———-+<br>可以看出，返回结果中的字段值都以“值 AS 字段名”的形式直接出现在优化后的 select 语句中。<br>修改一下查询：<br>mysql&gt; explain select * from a where id in(1,2)\G<br>…<br>         type: range<br>…<br>当返回结果超过 1 条时， type 便不再为 const 了。<br>重新建表及插入数据：<br>create table a (id int not null);<br>insert into a value(1),(2),(3);<br>mysql&gt; explain select * from a where id&#x3D;1\G<br>…<br>         type: ALL<br>目前表中只有一条 id&#x3D;1 的记录，但 type 已为 ALL ，因为只有唯一性索引才能保证表中最多只有一条记录，只有这样 type 才有可能为 const 。<br>为 id 加普通索引后， type 变为 ref ，改为加唯一或主键索引后， type 便变为 const 了。</p><p>二、Extra 列<br>Extra表示附加信息，常见的有如下几种（也按查询效率从高到低排列）：</p><p>Using index：表示使用索引，如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。如果同时出现Using where，代表使用索引来查找读取记录， 也是可以用到索引的，但是需要查询到数据表。<br>Using where：表示条件查询，如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where。如果type列是ALL或index，而没有出现该信息，则你有可能在执行错误的查询：返回所有数据。  <br>Using filesort：不是“使用文件索引”的含义！filesort是MySQL所实现的一种排序策略，通常在使用到排序语句ORDER BY的时候，会出现该信息。  <br>Using temporary：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合。</p><p>如果EXPLAIN出现后面两个信息（Using filesort，Using temporary），而rows又比较大，通常意味着你需要调整查询语句，或者需要添加索引，总之需要尽量消除这两个信息。</p><p>-——————– <br>作者：果儿妈 <br>来源：CSDN <br>原文：<a href="https://blog.csdn.net/xtdhqdhq/article/details/20377273">https://blog.csdn.net/xtdhqdhq/article/details/20377273</a> <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jconsole本地进程列表灰色connect不了的解决方法</title>
    <link href="/2018/10/24/Jconsole%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8%E7%81%B0%E8%89%B2connect%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2018/10/24/Jconsole%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8%E7%81%B0%E8%89%B2connect%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Jconsole本地进程列表灰色connect不了的解决方法"><a href="#Jconsole本地进程列表灰色connect不了的解决方法" class="headerlink" title="Jconsole本地进程列表灰色connect不了的解决方法"></a>Jconsole本地进程列表灰色connect不了的解决方法</h2><p>最新推荐文章于 2022-11-21 14:16:56 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-11-21 14:16:56 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>Jconsole是java中自带的一个很有用的查看线程 内存以及检测死锁的一个很有用的工具。</p><p>使用方法也很简单，就是打开cmd命令行后在cmd中输入jconsole</p><p><img src="https://img-blog.csdn.net/20181024104704509?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>可是今天在公司的电脑使用时发现以下问题：</p><p><img src="https://img-blog.csdn.net/20181024104726700?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>一些本地线程灰色无法点击并连接</p><p>google一下找到了解决方法，下面我以idea为例：</p><p>打开并编辑启动配置</p><p><img src="https://img-blog.csdn.net/20181024104948823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>在VM options中填入</p><p>-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port&#x3D;XXXX -Dcom.sun.management.jmxremote.ssl&#x3D;false -Dcom.sun.management.jmxremote.authenticate&#x3D;false</p><p>其中XXXX为你想通过jconsole连接的端口，随意的填一个不被占用的端口，在这里我填8989</p><p><img src="https://img-blog.csdn.net/20181024105052148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>然后在jconsole中选择Remote Process</p><p>并填入localhost:8989并连接</p><p><img src="https://img-blog.csdn.net/20181024105248508?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>然后便可以成功进入</p><p><img src="https://img-blog.csdn.net/20181024105514349?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在ehcache.xml中使用本地ehcache.xsd文件</title>
    <link href="/2018/10/10/%E5%A6%82%E4%BD%95%E5%9C%A8ehcache.xml%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0ehcache.xsd%E6%96%87%E4%BB%B6/"/>
    <url>/2018/10/10/%E5%A6%82%E4%BD%95%E5%9C%A8ehcache.xml%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0ehcache.xsd%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="如何在ehcache-xml中使用本地ehcache-xsd文件"><a href="#如何在ehcache-xml中使用本地ehcache-xsd文件" class="headerlink" title="如何在ehcache.xml中使用本地ehcache.xsd文件"></a>如何在ehcache.xml中使用本地ehcache.xsd文件</h2><p>最新推荐文章于 2022-06-21 12:37:10 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-06-21 12:37:10 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天用springboot做缓存时发现在idea中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;ehcache.xsd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>会报错，刚开始以为是公司代理墙了或者网速慢</p><p>即使换为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也还是不行。</p><p>于是，我干脆直接上去<a href="http://www.ehcache.org/ehcache.xsd">http://www.ehcache.org/ehcache.xsd</a> 访问并保存在本地</p><p>把保存在本地的ehcache.xsd文件 拉到和ehcache.xml同级目录下</p><p><img src="https://img-blog.csdn.net/20181010170836494?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><img src="https://img-blog.csdn.net/20181010170937864?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>这样就不会报错了  解决了ehcache.xml在idea中的报错</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Idea一些有用的快捷键</title>
    <link href="/2018/10/09/Idea%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2018/10/09/Idea%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Idea一些有用的快捷键"><a href="#Idea一些有用的快捷键" class="headerlink" title="Idea一些有用的快捷键"></a>Idea一些有用的快捷键</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 于 2018-10-09 15:21:43 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>查看被哪里调用&#x2F;调用处 Alt+F7</p><p>继承树 类关系图（查看某个类的父类以及接口）      Alt+Ctrl+U&#x2F;Alt+Ctrl+Shift+U</p><p>查看某个类的父类或接口 Ctrl+U</p><p>查找接口的实现类：Ctrl + Alt +B&#x2F;Ctrl +H</p><p>类结构 方法树（查看类成员 甚至查看继承的成员）  Ctrl+F12  按两次便可以查看继承的成员    &#x2F;Alt +7 </p><p>快捷生成getter&#x2F;setter 构造方法 重写方法等   Alt+Insert</p><p> 查看成员方法或者成员调用链（方法在哪里被调用）     Ctrl +H</p><p>生成新的单元测试方法   Ctrl+Shift+T</p><p>最近打开的文件  Ctrl+E</p><p>最近修改的文件  Ctrl+Shift+E</p><p>快速打开类   Ctrl+N</p><p>快速打开文件   Ctrl+Shift+N</p><p>快速打开成员  Ctrl+Shift+Alt+N</p><p>格式化代码  Ctrl+Alt+L</p><p>全局查找    shiftX2</p><p>上&#x2F;下移一行    Alt+Shift+Up&#x2F;Down</p><p>重构 - 重命名   Shift+F6</p><p>删除行   Ctrl+X</p><p>复制行  Ctrl+D</p><p>将代码包在一个块内，if else   try&#x2F;catch    Ctrl+Alt+ T</p><p>重写方法 Ctrl+O</p><p>（不定时更新）</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Idea Springboot热部署 页面刷新</title>
    <link href="/2018/09/21/Idea%20Springboot%E7%83%AD%E9%83%A8%E7%BD%B2%20%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0/"/>
    <url>/2018/09/21/Idea%20Springboot%E7%83%AD%E9%83%A8%E7%BD%B2%20%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Idea-Springboot热部署-页面刷新"><a href="#Idea-Springboot热部署-页面刷新" class="headerlink" title="Idea Springboot热部署 页面刷新"></a>Idea Springboot热部署 页面刷新</h2><p>最新推荐文章于 2023-09-07 14:08:28 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-09-07 14:08:28 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>最近用Idea做Springboot时发现按照百度的一些文章开启热部署功能依旧不行。</p><p>今天自己无意中发现了一个小配置</p><p><img src="https://img-blog.csdn.net/2018092117463553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>把这两个配置改为以下就可以了</p><p><img src="https://img-blog.csdn.net/20180921174714642?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring依赖注入和实例化(new)的差别</title>
    <link href="/2018/09/21/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96(new)%E7%9A%84%E5%B7%AE%E5%88%AB/"/>
    <url>/2018/09/21/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96(new)%E7%9A%84%E5%B7%AE%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring依赖注入和实例化-new-的差别"><a href="#Spring依赖注入和实例化-new-的差别" class="headerlink" title="Spring依赖注入和实例化(new)的差别"></a>Spring依赖注入和实例化(new)的差别</h2><p>最新推荐文章于 2024-01-05 10:55:25 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-05 10:55:25 发布</p><p>Spring依赖注入和实例化(new)的差别。 </p><p>Sping为什么使用依赖注入而不使用实例化对象的方式？ </p><p>首先说明一下概念 </p><p>依赖注入(Dependency of Injection)和控制反转(Inversion of Control 简称：ioc)是一个概念。 </p><p>具体含义： </p><p>   当某个角色(java实例class A，调用者)需要另一个角色(另一个Java实例class B，被调用者)的协助时，在传统的程序设计过程中通常由调用者来创建被调用者的实例(在class A里面 初始化class B)。 <br>但在Spring里，创建被调用者实例的工作不再由调用者来完成。因此成为控制反转(ioc)。创建被调用者实例的工作由Spring容器来完成，然后注入调用者。因此也称为依赖注入</p><p>不管是依赖注入还是控制反转，都说明Spring采用动态灵活的方式来管理各种对象，对象与对象之间的具体实现互相透明。</p><p>在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:一个人(Java实例，调用者)需要一把斧子(Java实例，被调用者)。</p><p>-  <strong>原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为:Java程序里的调用者自己创建被调用者。</strong> <br>- <strong>进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应Java程序的简单工厂的设计模式。</strong> <br>- <strong>进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应Spring的依赖注入。</strong></p><ul><li>第一种情况下，Java实例的调用者创建被调用的Java实例，必然要求被调用的Java类出现在调用者的代码里。无法实现二者之间的松耦合。</li><li>第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。</li><li>第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于Spring的管理下，二者之间的依赖关系由Spring提供。</li></ul><p><strong>所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理。依赖注入通常有三种:</strong> </p><p><strong>- set设值注入 <br>- 构造函数注入 <br>- spring注解注入</strong> </p><p>其实我一开始也好楼主有同样的困惑，但是在项目的慢慢积累，感觉spring的配置文件太有才了</p><p>我就和你分享一点：那就是软件的后期维护</p><p>比如说有一个订单的DAO接口：interface OrderDAO</p><p>在开发的时候我是用的MySql数据库，实现类为 class MySqlOrderDAOImpl implements OrderDAO</p><p>在业务代码里面，我要使用OrderDAO，这没什么难的，直接new一个对象不就行了吗，于是我就这样了：</p><p>OrderDAO dao &#x3D; new MySqlOrderDAOImpl();</p><p>轻松完成，最后项目完成，实施运营了，后来客户发现MySql不行了，要换成Oracle，这不难，我在写一个OrderDAO的实现类不就行了吗，于是我两指一挥：</p><p>class OracleOrderDAOImpl implements OrderDAO</p><p>可是这样就又来了一个麻烦就是在我的业务代码里面，我都是自己new的对象，都是“MySqlOrderDAOImpl”，</p><p>没问题，把 “MySqlOrderDAOImpl” 替换成”OracleOrderDAOImpl “就可以了</p><p>于是，全体动员，查找“MySqlOrderDAOImpl”然后替换成”OracleOrderDAOImpl “，这样浪费了半天，还可能有些地方还没替换呢</p><p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过node.js进行前后端分离</title>
    <link href="/2018/09/20/%E9%80%9A%E8%BF%87node.js%E8%BF%9B%E8%A1%8C%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    <url>/2018/09/20/%E9%80%9A%E8%BF%87node.js%E8%BF%9B%E8%A1%8C%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>       现在很多公司企业都是前后端分离开发，两端互相不干扰。由于以前在学校时习惯了把前端东西放在同一个项目里的projects目录或者springboot里的resources&#x2F;static文件夹下，所以作为一个后端程序员，今天我也简单的介绍一下通过node.js进行前后端分离开发。</p><p>      首先，确定自己已经搭建好node和npm安装环境，最好的话安装一下cnpm会快很多。</p><p>其次，准备一个可以通过localhost:8080&#x2F;api&#x2F;users显示数据  访问假数据或者连接数据库。我推荐用srpingboot快速搭建一个。具体可以看我的源码，如果你不喜欢或者没用过springboot的话也可以用spring mvc搭建一个</p><p><img src="https://img-blog.csdn.net/20180920112835666?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>（1）创建一个项目文件夹，文件夹名字是你的项目名在这里我就改为test-frontend。</p><p>（2）创建一个package.json。用cmd在test-frontend下运行npm init命令，一步一步填入你的项目相关信息。记得最后填yes才会生成。<img src="https://img-blog.csdn.net/2018092011014311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><img src="https://img-blog.csdn.net/20180920103133585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>(3) 用npm或者cnpm安装express 和 http-proxy-middleware。命令后面加了–save，要是拿了我源码的可以直接cnpm install 或者npm install即可全部安装。 </p><p><img src="https://img-blog.csdn.net/20180920110421202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>（4）编写index.html页面 还有 给目录结构大家参考一下</p><p><img src="https://img-blog.csdn.net/2018092015155397?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>users<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table-responsive&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myTable&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>password<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>phone<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">$.<span class="hljs-title function_">ajax</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://localhost:8080/api/users&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-comment">//url:&#x27;http://localhost/api/users&#x27;,</span></span><br><span class="language-javascript"><span class="hljs-comment">// type:&#x27;get&#x27;,</span></span><br><span class="language-javascript"><span class="hljs-attr">async</span>:<span class="hljs-literal">true</span>,</span><br><span class="language-javascript"><span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-comment">//crossDomain: true,</span></span><br><span class="language-javascript"><span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);</span><br><span class="language-javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">$(<span class="hljs-string">&#x27;#myTable&#x27;</span>).<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;&lt;tr&gt;&lt;td&gt;&#x27;</span>+data[i].<span class="hljs-property">id</span>+<span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span>+data[i].<span class="hljs-property">username</span>+<span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span>+data[i].<span class="hljs-property">password</span>+<span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span>+data[i].<span class="hljs-property">phone</span>+<span class="hljs-string">&#x27;&lt;/td&gt;&lt;/tr&gt;&#x27;</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-comment">//$(&#x27;#myTable&#x27;).append</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">error</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);</span><br><span class="language-javascript"><span class="hljs-comment">//console.log(data[0].id);</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（5）是最核心的一步，编写index.js。在这里说明一下这个不一定是叫index.js 你也可以叫main.js，不过最好跟你（2）填入的entry point 名字对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引用模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)<br><span class="hljs-keyword">var</span> app  = <span class="hljs-title function_">express</span>()<br><span class="hljs-comment">//静态资源直接访问</span><br><span class="hljs-comment">//如dist/js/jquery.js  访问路径为 http://localhost/js/jquery.js 在script标签中src=&quot;js/jquery.js&quot;</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;dist&#x27;</span>))<br><br><span class="hljs-comment">//api子目录下的都是用8080代理 </span><br><span class="hljs-comment">// 在我的源代码后端是8080端口开启 其中有两个controller  UserController  TestController</span><br><span class="hljs-comment">//UserController requestMapping是&quot;/api&quot;  访问http://localhost/api/users 相当于访问 http://localhost:8080/api/users</span><br><span class="hljs-comment">//TestController requestMapping是&quot;/test&quot; 访问http://localhost/test/users不能访问</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">const</span> apiProxy = <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, &#123; <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>,<span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span> &#125;);<span class="hljs-comment">//将服务器代理到localhost:8080端口上[本地服务器为localhost:3000]</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api/*&#x27;</span>, apiProxy);<br><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/index.html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>   res.<span class="hljs-title function_">sendFile</span>( __dirname + <span class="hljs-string">&quot;/src/&quot;</span> + <span class="hljs-string">&quot;index.html&quot;</span> );<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/login.html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>res.<span class="hljs-title function_">sendFile</span>( __dirname + <span class="hljs-string">&quot;/src/&quot;</span> + <span class="hljs-string">&quot;login.html&quot;</span> ); <br>&#125;)<br><span class="hljs-comment">// app.get(&#x27;*&#x27;,function(req,res)&#123;</span><br><span class="hljs-comment">// res.sendFile( __dirname + &quot;/src/&quot; + &quot;index.html&quot; );</span><br><span class="hljs-comment">// &#125;)</span><br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;connect successfully&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>app.use(express.static(‘dist’))</p><p>&#x2F;&#x2F;静态资源直接访问<br>&#x2F;&#x2F;如dist&#x2F;js&#x2F;jquery.js  访问路径为 <a href="http://localhost/js/jquery.js">http://localhost/js/jquery.js</a> 在script标签中src&#x3D;”js&#x2F;jquery.js”</p><p>const apiProxy &#x3D; proxy(‘&#x2F;api’, { target: ‘<a href="http://localhost:8080',changeOrigin">http://localhost:8080&#39;,changeOrigin</a>: true });&#x2F;&#x2F;将服务器代理到localhost:8080端口上[本地服务器为localhost:3000]<br>app.use(‘&#x2F;api&#x2F;*‘, apiProxy);</p><p>&#x2F;&#x2F;api子目录下的都是用8080代理 <br>&#x2F;&#x2F; 在我的源代码后端是8080端口开启 其中有两个controller  UserController  TestController<br>&#x2F;&#x2F;UserController requestMapping是”&#x2F;api”  访问<a href="http://localhost/api/users">http://localhost/api/users</a> 相当于访问 <a href="http://localhost:8080/api/users">http://localhost:8080/api/users</a><br>&#x2F;&#x2F;TestController requestMapping是”&#x2F;test” 访问<a href="http://localhost/test/users%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE">http://localhost/test/users不能访问</a>   </p><p>当然也可以把页面也放进去dist当作静态资源访问</p><p>(6)运行后端服务器，然后在前端项目根目录下cmd 命令”nodex index.js”</p><p><img src="https://img-blog.csdn.net/2018092015265367?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>表示成功运行</p><p>首先访问<a href="http://localhost:8080/api/users">http://localhost:8080/api/users</a></p><p><img src="https://img-blog.csdn.net/20180920152743139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>然后访问 <a href="http://localhost/api/users">http://localhost/api/users</a></p><p><img src="https://img-blog.csdn.net/2018092015292360?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>访问 <a href="http://localhost/test/users">http://localhost/test/users</a> 失败</p><p><img src="https://img-blog.csdn.net/20180920153039626?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>访问<a href="http://localhost:8080/test/users">http://localhost:8080/test/users</a> 成功</p><p><img src="https://img-blog.csdn.net/2018092015315167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>以上表明后端服务器运行和node 对&#x2F;api的代理成功了</p><p>访问<a href="http://localhost/index.html">http://localhost/index.html</a>也成功展现数据</p><p><img src="https://img-blog.csdn.net/20180920153311784?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">以上是我前后端分离的小小总结</p><p><strong>最后，放上我的源码地址<a href="https://github.com/wayleung/test-demo.git">https://github.com/wayleung/test-demo.git</a>，喜欢的可以star一下，感谢。</strong></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速了解MyISAM与InnoDB的索引差异</title>
    <link href="/2018/09/10/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3MyISAM%E4%B8%8EInnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E5%B7%AE%E5%BC%82/"/>
    <url>/2018/09/10/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3MyISAM%E4%B8%8EInnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h2 id="快速了解MyISAM与InnoDB的索引差异"><a href="#快速了解MyISAM与InnoDB的索引差异" class="headerlink" title="快速了解MyISAM与InnoDB的索引差异"></a>快速了解MyISAM与InnoDB的索引差异</h2><p>最新推荐文章于 2023-02-17 15:33:01 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-02-17 15:33:01 发布</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961486&idx=1&sn=b319a87f87797d5d662ab4715666657f&chksm=bd2d0d528a5a84446fb88da7590e6d4e5ad06cfebb5cb57a83cf75056007ba29515c85b9a24c&scene=21#wechat_redirect">数据库索引，到底是什么做的？</a>》介绍了B+树，它是一种非常适合用来做<strong>数据库索引</strong>的数据结构：</p><p>(1)很适合磁盘存储，能够充分利用局部性原理，磁盘预读；</p><p>(2)很低的树高度，能够存储大量数据；</p><p>(3)索引本身占用的内存很小；</p><p>(4)能够很好的支持单点查询，范围查询，有序性查询；</p><p>数据库的索引分为<strong>主键索引</strong>（Primary Inkex）与<strong>普通索引</strong>（Secondary Index）。InnoDB和MyISAM是怎么利用B+树来实现这两类索引，其又有什么差异呢？这是今天要聊的内容。</p><p><strong>一，MyISAM的索引</strong></p><p>MyISAM的索引与行记录是分开存储的，叫做<strong>非聚集索引</strong>（UnClustered Index）。</p><p>其主键索引与普通索引没有本质差异：</p><ul><li><p>有连续聚集的区域单独存储行记录</p></li><li><p>主键索引的叶子节点，存储主键，与对应行记录的指针</p></li><li><p>普通索引的叶子结点，存储索引列，与对应行记录的指针</p></li></ul><p><em>画外音：MyISAM的表可以没有主键。</em></p><p>主键索引与普通索引是两棵独立的索引B+树，通过索引列查找时，先定位到B+树的叶子节点，再通过指针定位到行记录。</p><p>举个例子，MyISAM：</p><p>t(id PK, name KEY, sex, flag);</p><p>表中有四条记录：</p><p>1, shenjian, m, A</p><p>3, zhangsan, m, A</p><p>5, lisi, m, A</p><p>9, wangwu, f, B</p><p><img src="https://img-blog.csdnimg.cn/img_convert/340e72b55702d04a2a09828538aca01d.png" alt="640?wx_fmt=png"></p><p>其B+树索引构造如上图：</p><ul><li><p>行记录单独存储</p></li><li><p>id为PK，有一棵id的索引树，叶子指向行记录</p></li><li><p>name为KEY，有一棵name的索引树，叶子也指向行记录</p></li></ul><p><strong>二、InnoDB的索引</strong></p><p>InnoDB的<strong>主键索引与</strong>行记录是存储在一起的，故叫做<strong>聚集索引</strong>（Clustered Index）：</p><ul><li><p>没有单独区域存储行记录</p></li><li><p>主键索引的叶子节点，存储主键，与对应行记录（而不是指针）</p></li></ul><p><em>画外音：因此，InnoDB的PK查询是非常快的。</em></p><p>因为这个特性，InnoDB的表必须要有聚集索引：</p><p>(1)如果表定义了PK，则PK就是聚集索引；</p><p>(2)如果表没有定义PK，则第一个非空unique列是聚集索引；</p><p>(3)否则，InnoDB会创建一个隐藏的row-id作为聚集索引；</p><p>聚集索引，也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。</p><p>InnoDB的<strong>普通索引</strong>可以有多个，它与聚集索引是不同的：</p><ul><li>普通索引的叶子节点，存储主键（也不是指针）</li></ul><p>对于InnoDB表，这里的启示是：</p><p>(1)不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；</p><p>(2)建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂，行记录移动；</p><p>仍是上面的例子，只是存储引擎换成InnoDB：</p><p>t(id PK, name KEY, sex, flag);</p><p>表中还是四条记录：</p><p>1, shenjian, m, A</p><p>3, zhangsan, m, A</p><p>5, lisi, m, A</p><p>9, wangwu, f, B</p><p><img src="https://img-blog.csdnimg.cn/img_convert/077adac66f305be56b5d81efd35c35d5.png" alt="640?wx_fmt=png"></p><p>其B+树索引构造如上图：</p><ul><li><p>id为PK，行记录和id索引树存储在一起</p></li><li><p>name为KEY，有一棵name的索引树，叶子存储id</p></li></ul><p>当：</p><p>select * from t where name&#x3D;‘lisi’;</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ba951e6e3443557673a5fb3225bb37dd.png" alt="640?wx_fmt=png"></p><p>会先通过name辅助索引定位到B+树的叶子节点得到id&#x3D;5，再通过聚集索引定位到行记录。</p><p><em>画外音：所以，其实扫了2遍索引树。</em></p><p><strong>三，总结</strong></p><p>MyISAM和InnoDB都使用B+树来实现索引：</p><ul><li><p>MyISAM的索引与数据分开存储</p></li><li><p>MyISAM的索引叶子存储指针，主键索引与普通索引无太大区别</p></li><li><p>InnoDB的<strong>聚集索引</strong>和数据行统一存储</p></li><li><p>InnoDB的聚集索引存储数据行本身，<strong>普通索引</strong>存储主键</p></li><li><p>InnoDB一定有且只有一个聚集索引</p></li><li><p>InnoDB建议使用趋势递增整数作为PK，而不宜使用较长的列作为PK</p></li></ul><p> </p><p>这篇博文是我看一个大神的，看完以后感觉简单易懂所以便转来自己这里收藏一下</p><p>原文出处：<a href="https://blog.csdn.net/u8AHNh95ix6lUC/article/details/82112319">https://blog.csdn.net/u8AHNh95ix6lUC/article/details/82112319</a></p><p><a href="https://blog.csdn.net/z50l2o08e2u4aftor9a/article/details/82111747">https://blog.csdn.net/z50l2o08e2u4aftor9a/article/details/82111747</a></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过代码简单介绍Java反射</title>
    <link href="/2018/09/06/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DJava%E5%8F%8D%E5%B0%84/"/>
    <url>/2018/09/06/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DJava%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Java-反射概述"><a href="#1-Java-反射概述" class="headerlink" title="1.Java 反射概述"></a>1.Java 反射概述</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><p>Java 反射是很多Java框架的基础和实现，所以掌握java反射对框架的理解有很大的作用</p><h3 id="2-三种获取Class类对象的方式"><a href="#2-三种获取Class类对象的方式" class="headerlink" title="2.三种获取Class类对象的方式"></a>2.三种获取Class类对象的方式</h3><h4 id="1-（最常用）Class-forName（String-className）注意括号中的是全类名，写过jdbc的相关代码的人都熟悉这种获取方式"><a href="#1-（最常用）Class-forName（String-className）注意括号中的是全类名，写过jdbc的相关代码的人都熟悉这种获取方式" class="headerlink" title="1.（最常用）Class.forName（String  className）注意括号中的是全类名，写过jdbc的相关代码的人都熟悉这种获取方式"></a>1.（最常用）Class.forName（String  className）注意括号中的是全类名，写过jdbc的相关代码的人都熟悉这种获取方式</h4><h4 id="2-对象的-class属性"><a href="#2-对象的-class属性" class="headerlink" title="2.对象的.class属性"></a>2.对象的.class属性</h4><h4 id="3-对象的getClass（）方法"><a href="#3-对象的getClass（）方法" class="headerlink" title="3.对象的getClass（）方法"></a>3.对象的getClass（）方法</h4><p>后面两种耦合度太高 一般都是用第一种</p><p>下面是代码介绍java反射的一些api用法</p><p>Student bean类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.reflect;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span>: Way Leung wayleung13@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 9/5/2018 10:34</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-type">char</span> gender;<br><br>    <span class="hljs-keyword">protected</span> String phone;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am the main method!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am the public constructor!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am the private constructor!&quot;</span>);<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    Student(<span class="hljs-type">int</span> id, String name, <span class="hljs-type">char</span> gender) &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am the default constructor!&quot;</span>);<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, <span class="hljs-type">char</span> gender, String phone)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am the protected constructor!&quot;</span>);<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>        <span class="hljs-built_in">this</span>.phone = phone;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, id=&quot;</span>+id+<span class="hljs-string">&quot; name=&quot;</span>+name+<span class="hljs-string">&quot;, i am a private method1!&quot;</span>;<br>    &#125;<br><br>    String <span class="hljs-title function_">method2</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello,  name=&quot;</span>+name+<span class="hljs-string">&quot;, i am a default method2!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">method3</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, name=&quot;</span>+name+<span class="hljs-string">&quot;, i am a protected method3!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">method4</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello,  name=&quot;</span>+name+<span class="hljs-string">&quot;, i am a private method4!&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGender</span><span class="hljs-params">(<span class="hljs-type">char</span> gender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> phone;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPhone</span><span class="hljs-params">(String phone)</span> &#123;<br>        <span class="hljs-built_in">this</span>.phone = phone;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, gender=&quot;</span> + gender +<br>                <span class="hljs-string">&quot;, phone=&#x27;&quot;</span> + phone + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>demo类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.reflect;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span>: Way Leung wayleung13@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 9/5/2018 10:32</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;<br>        Class&lt;?&gt; studentClass = Class.forName(<span class="hljs-string">&quot;com.way.reflect.Student&quot;</span>);<br>        Constructor&lt;?&gt;[] declaredConstructors = studentClass.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor constructor:declaredConstructors) &#123;<br>            System.out.println(constructor);<br><br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        Object student;<br>        Constructor&lt;?&gt; publicConstructor = studentClass.getDeclaredConstructor();<br>        student = publicConstructor.newInstance();<br>        System.out.println(student);<br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        Constructor&lt;?&gt; privateConstructor = studentClass.getDeclaredConstructor(<span class="hljs-type">int</span>.class,String.class);<br>        <span class="hljs-comment">//暴力访问(忽略掉访问修饰符)</span><br>        privateConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        student = privateConstructor.newInstance(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;way&quot;</span>);<br>        System.out.println(student);<br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        Constructor&lt;?&gt; protectedConstructor = studentClass.getDeclaredConstructor(<span class="hljs-type">int</span>.class,String.class,<span class="hljs-type">char</span>.class,String.class);<br>        <span class="hljs-comment">//暴力访问(忽略掉访问修饰符) 同一个包下可以不用</span><br>        <span class="hljs-comment">//protectedConstructor.setAccessible(true);</span><br>        student = protectedConstructor.newInstance(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;way&quot;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        System.out.println(student);<br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        Constructor&lt;?&gt; defaultConstructor = studentClass.getDeclaredConstructor(<span class="hljs-type">int</span>.class,String.class,<span class="hljs-type">char</span>.class);<br>        <span class="hljs-comment">//暴力访问(忽略掉访问修饰符) 同一个包下可以不用</span><br>        <span class="hljs-comment">//defaultConstructor.setAccessible(true);</span><br>        student = defaultConstructor.newInstance(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;way&quot;</span>,<span class="hljs-string">&#x27;M&#x27;</span>);<br>        System.out.println(student);<br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br><br>        Field[] declaredFields = studentClass.getDeclaredFields();<br><br>        <span class="hljs-keyword">for</span> (Field field:declaredFields<br>             ) &#123;<br>            System.out.println(field);<br>        &#125;<br><br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> studentClass.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);<br><br>        <span class="hljs-comment">//暴力访问(忽略掉访问修饰符)</span><br>        id.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//对对象属性赋值</span><br>        id.set(student,<span class="hljs-number">6666</span>);<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> (Student) student;<br>        <span class="hljs-comment">//验证</span><br>        System.out.println(stu.getId());<br><br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br><br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> studentClass.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><br>        <span class="hljs-comment">//暴力访问(忽略掉访问修饰符)  同一个包下可以不用</span><br>        <span class="hljs-comment">//name.setAccessible(true);</span><br>        <span class="hljs-comment">//对对象属性赋值</span><br>        name.set(student,<span class="hljs-string">&quot;wway&quot;</span>);<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu1</span> <span class="hljs-operator">=</span> (Student) student;<br>        <span class="hljs-comment">//验证</span><br>        System.out.println(stu1.getName());<br><br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br><br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> studentClass.getDeclaredField(<span class="hljs-string">&quot;gender&quot;</span>);<br><br>        <span class="hljs-comment">//暴力访问(忽略掉访问修饰符)  同一个包下可以不用</span><br>        <span class="hljs-comment">//name.setAccessible(true);</span><br>        <span class="hljs-comment">//对对象属性赋值</span><br>        gender.set(student,<span class="hljs-string">&#x27;F&#x27;</span>);<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> (Student) student;<br>        <span class="hljs-comment">//验证</span><br>        System.out.println(stu2.getGender());<br><br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br><br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> studentClass.getDeclaredField(<span class="hljs-string">&quot;phone&quot;</span>);<br><br>        <span class="hljs-comment">//暴力访问(忽略掉访问修饰符)  同一个包下可以不用</span><br>        <span class="hljs-comment">//name.setAccessible(true);</span><br>        <span class="hljs-comment">//对对象属性赋值</span><br>        phone.set(student,<span class="hljs-string">&quot;88888888&quot;</span>);<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu3</span> <span class="hljs-operator">=</span> (Student) student;<br>        <span class="hljs-comment">//验证</span><br>        System.out.println(stu3.getPhone());<br><br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br><br>        Method[] declaredMethods = studentClass.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method method:declaredMethods<br>             ) &#123;<br>            System.out.println(method);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method4</span> <span class="hljs-operator">=</span> studentClass.getDeclaredMethod(<span class="hljs-string">&quot;method4&quot;</span>, String.class);<br>        method4.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//调用某对象的方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">wayway</span> <span class="hljs-operator">=</span> method4.invoke(student,<span class="hljs-string">&quot;wayway&quot;</span>);<br>        System.out.println(wayway);<br><br><br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method2</span> <span class="hljs-operator">=</span> studentClass.getDeclaredMethod(<span class="hljs-string">&quot;method2&quot;</span>, String.class);<br>        <span class="hljs-comment">//method2.setAccessible(true);</span><br>        <span class="hljs-comment">//调用某对象的方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">wayway2</span> <span class="hljs-operator">=</span> method2.invoke(student,<span class="hljs-string">&quot;wayway2&quot;</span>);<br>        System.out.println(wayway2);<br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method3</span> <span class="hljs-operator">=</span> studentClass.getDeclaredMethod(<span class="hljs-string">&quot;method3&quot;</span>,<span class="hljs-type">int</span>.class, String.class);<br>        <span class="hljs-comment">//method3.setAccessible(true);</span><br>        <span class="hljs-comment">//调用某对象的方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">wayway3</span> <span class="hljs-operator">=</span> method3.invoke(student,<span class="hljs-number">333</span>,<span class="hljs-string">&quot;wayway3&quot;</span>);<br>        System.out.println(wayway3);<br><br>        System.out.println(<span class="hljs-string">&quot;***********************************&quot;</span>);<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method1</span> <span class="hljs-operator">=</span> studentClass.getDeclaredMethod(<span class="hljs-string">&quot;method1&quot;</span>,<span class="hljs-type">int</span>.class, String.class);<br>        method1.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//调用某对象的方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">wayway1</span> <span class="hljs-operator">=</span> method1.invoke(student,<span class="hljs-number">111</span>,<span class="hljs-string">&quot;wayway&quot;</span>);<br>        System.out.println(wayway1);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java数组声明与初始化定义以及要注意的地方</title>
    <link href="/2018/09/04/java%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <url>/2018/09/04/java%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="java数组声明与初始化定义以及要注意的地方"><a href="#java数组声明与初始化定义以及要注意的地方" class="headerlink" title="java数组声明与初始化定义以及要注意的地方"></a>java数组声明与初始化定义以及要注意的地方</h2><p>最新推荐文章于 2022-10-10 17:59:43 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2022-10-10 17:59:43 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>平时工作中都是用List等包装类打交道比较多，用数组则比较少，今天使用数组时差点就忘记了数组的定义，所以现在来复习一下。下面其中有一些知识是来源网络，具体地址我忘了，在这里多谢一下那位兄弟吧。</p><p>1.声明数组</p><p>通常声明一个数组有两种形式：</p><p>（1）.类型名[ ] 数组名</p><p>（2).类型名 数组 [ ] </p><p>我个人偏向第一种声明方法，而第二种更像是c++的数组声明</p><p>由于声明仅仅是声明，java并没有为数组开辟了内存空间所以此时使用数组的话，java就会报错</p><p>2.初始化数组</p><p>初始化数组则有以下几种形式</p><p> （1）&#x3D; new 类型名[数组长度] (此数组已经被声明过或者同时在&#x3D;左边声明)</p><p>（2）&#x3D; {数据1, 数据2, 数据3, ……, 数据n} (此数组已经被声明过或者同时在&#x3D;左边声明)</p><p>（3）&#x3D; new 类型名[]{数据1, 数据2, 数据3, ……, 数据n} (此数组已经被声明过或者同时在&#x3D;左边声明)</p><p>（4）在已经声明过数组的前提下，使用循环或者其他操作来给数组初始化或者赋值。</p><p>但是我们有一个问题要注意，只是给出了数组的长度，而并没有显示的给出数组中的数据，那么，如果数组类 型是double，那么里面的数都是0.0，如果数组类型是int，那么里面的数据都是0，如果数组类型是String，那么里面的数据都是null(空 的意思)，如果数组类型是boolean，那么里面的数据都是false。但是如果显示的给出了数据，那么我们不需要给出数组长度，java将自动获得数 组长度，而且里面的数据也都已经有了。</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络中的OSI七层网络模型</title>
    <link href="/2018/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2018/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络中的OSI七层网络模型"><a href="#计算机网络中的OSI七层网络模型" class="headerlink" title="计算机网络中的OSI七层网络模型"></a>计算机网络中的OSI七层网络模型</h2><p>最新推荐文章于 2023-04-11 14:47:09 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-04-11 14:47:09 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>1.OSI七层模型</p><p>1.1.简介</p><p>第一种模型是OSI七层模型，OSI为（Open System interconnect）的缩写，自上而下分别是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p>物理层：网卡，网线，集线器，中继器，调制解调器</p><p>数据链路层：网桥，交换机</p><p>网络层：路由器</p><p><img src="https://img-blog.csdn.net/2018090411342263?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>1.2物理层</p><p>首先，物理层并不是物理媒体本身，物理层的媒体包括电缆、光纤等。正因为物理媒体会有很多差异，所以物理层的作用正是尽可能地屏蔽这些差异，使上面的数据链路曾感觉不到这些差异。其主要任务就是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性等。在这一层，数据的单位为比特（bit）。</p><p>1.3数据链路层</p><p>数据链路层的使用的信道主要有以下两种类型：点对点信道、广播信道</p><p>数据链路层的协议有很多种，但有三个基本问题则是共同的：封装成帧、透明传输、差错检测。</p><p>封装成帧：就是在数据前后分别添加首部和尾部，这样就构成了 帧。</p><p>透明传输：用字节填充法（在非帧边界的控制字符插入转义字符）解决透明传输的问题。</p><p><img src="https://img-blog.csdn.net/20180904105851795?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>差错检测：传输过程中可能会出现差错（比特差错），为保证可靠性，在数据链路层广泛使用了循环冗余检验CRC的检错技术</p><p>数据链路层的协议的代表包括PPP STP SDLC等，这一层的单位是帧。</p><p>1.4网络层</p><p>网络层的任务就是选择合适的网间路由和交换结点，数据包是包含在帧中，包中封装了网络层包头，如源站点、目的站点信息等，如果你还在讨论一个ip地址，那么你是在这层的问题。此外还有一些路由协议的地址解析协议（ARP）,网络层还可以实现拥塞控制、网际互连等，这一层，数据的单位为数据包。网络协议代表有IP IPX RIP OSPF 等</p><p>1.5传输层（运输层）</p><p>传输层是整个网络体系结构中的关键层次之一。IP数据报中的首部明确标记了两个主机的IP地址，但是“两个主机之间的通信”说法不清楚，因为真正进行通信的实体是主机中的进程。根据应用程序的不用需求，运输层需要两种不同的运输协议，即面向连接的TCP和无连接的UDP。TCP数据单元为段 而UDP中数据单元为数据报。</p><p>TCP 面向连接 全双工 面向字节流 每一条TCP连接有两个端点，这两个端点是什么呢？不是主机，也不是主机IP，不是应用进程，也不是运输层的协议端口。TCP链接的端点叫做套接字（socket）&#x3D;IP地址：端口号</p><p>TCP的三次握手和四次挥手</p><p><img src="https://img-blog.csdn.net/20170607205709367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p><p><img src="https://img-blog.csdn.net/20170607205756255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p><p>TCP的可靠传输的实现：1.滑动窗口 2.超时重传 3.选择确认 SACK</p><p>TCP的流量控制：滑动窗口</p><p>TCP的拥塞控制：慢开始与拥塞避免</p><p>UDP是无连接 尽最大努力交付 面向报文 首部开销小 8字节 比TCP的20个字节小</p><p>1.6会话层</p><p>会话单位的控制层，其主要功能是按照在应用进程之间约定的原则，按照正确的顺序收、发数据，进行各种形态的对话。</p><p>1.7表示层</p><p>数据表示形式的控制层，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。</p><p>1.8.应用层</p><p>OSI参考模型的最高层。其功能是实现应用进程（如用户程序、终端操作员等）之间的信息交换。同时，还具有一系列业务处理所需要的服务功能。应用层许多协议都是基于客户服务器方式。</p><p>2.五层互联网协议</p><p>自上而下：应用层，传输层，网络层，链路层和物理层</p><p>3. TCP&#x2F;IP四层模型</p><p>3.1 应用层：对应OSI中的应用层、表示层、会话层</p><p>3.2 物理链路层：对应OSI中的数据链路层、物理层（也有叫网络接口层）</p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何动态调用jar包里的方法以及结合freemarker生成html模板要注意的地方</title>
    <link href="/2018/07/05/%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8jar%E5%8C%85%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%BB%93%E5%90%88freemarker%E7%94%9F%E6%88%90html%E6%A8%A1%E6%9D%BF%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <url>/2018/07/05/%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8jar%E5%8C%85%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%BB%93%E5%90%88freemarker%E7%94%9F%E6%88%90html%E6%A8%A1%E6%9D%BF%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<p>    最近刚刚转正没多久，正好前天部门大佬让我和一个同事做一个自动化的软件测试程序，通过导入一些excel的测试数据表格来生成测试html报告。而我负责的主要是freemarker生成html还有另外一个同事通过jar包调用我的方法.前者的freemarker转静态页面还是比较简单的，后者的话刚刚听到这个需求的时候其实我觉得有点迷惑,为什么不直接做成一个web应用或者打成一个jar包 还要打成几个jar包？后来我自己想了一下应该是考虑到这个测试应用是给一些不太懂代码的测试人员使用,还有就是打成几个jar包的话应该是为了解耦,对外提供接口，这样以后有其他web应用也可以调用这个jar包。</p><p>    之前一直做web应用比较多，打war包比较多，对于jar包了解的还是比较少。不过对于调用jar包里的方法，我脑海里浮出的第一个想法是——java反射。后来在大佬的提示和自己的查找资料也证实了这个想法。  </p><p>    首先，介绍一下两个项目的目录结构，两个项目都是普通java project  </p><p><img src="https://img-blog.csdn.net/2018070515360024?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><img src="https://img-blog.csdn.net/20180705153503596?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">  </p><p>到这里可能有人会问 为什么不用maven  为什么不用spring</p><p>不用maven是因为maven相当于依赖的路径导入 并没有导入真正的jar包支持</p><p>所以当你项目打成jar包就会报错找不到class </p><p>而不用spring是为了减少导入spring的 jar包  为了介绍体积</p><p>看图二可以知道我只导入了一个freemarker的jar包</p><p>dynamic-invoke-test中的invoke类将会调用 打成jar包后的freemarkerutil-test.jar的方法</p><p>首先我们定义dto</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.dto;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> String age;<br><span class="hljs-keyword">private</span> String sex;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(String age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sex;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br><span class="hljs-built_in">this</span>.sex = sex;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, String age, String sex)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br><span class="hljs-built_in">this</span>.sex = sex;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有freemarker的ftl模板 freemarker比较简单容易上手 大家就自行去搜索资料吧</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>学生信息<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>学生信息管理<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;student.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;student.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;student.sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ftl模板存放的路径我下面有提到</p><p>FreemarkerUtil.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.util;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.Writer;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><br><br><br><br><br><br><br><span class="hljs-keyword">import</span> com.way.dto.Student;<br><br><span class="hljs-keyword">import</span> freemarker.core.ParseException;<br><span class="hljs-keyword">import</span> freemarker.template.Configuration;<br><span class="hljs-keyword">import</span> freemarker.template.MalformedTemplateNameException;<br><span class="hljs-keyword">import</span> freemarker.template.Template;<br><span class="hljs-keyword">import</span> freemarker.template.TemplateException;<br><span class="hljs-keyword">import</span> freemarker.template.TemplateNotFoundException;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Way Liang ASNPHXW</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> Jul 3, 2018 </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FreemarkerUtil</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> TemplateNotFoundException, MalformedTemplateNameException, ParseException, IOException, TemplateException&#123;<br><br><span class="hljs-comment">// 添加数据</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;way&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-string">&quot;male&quot;</span>);<br><br>generateStudentHtml(student);<br>&#125;<br><br><br><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateStudentHtml</span><span class="hljs-params">(Student student)</span> <span class="hljs-keyword">throws</span> IOException, TemplateException&#123;<br><br><span class="hljs-comment">//获取ftl模板</span><br><span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> getTemplateByFtlName(<span class="hljs-string">&quot;student.ftl&quot;</span>);<br><br><span class="hljs-comment">//String outPutPath = &quot;src&quot;+File.separator+&quot;main&quot;+File.separator+&quot;webapp&quot;+File.separator+&quot;WEB-INF&quot;+File.separator+&quot;html&quot;+File.separator+&quot;summary.html&quot;;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">outPutPath</span> <span class="hljs-operator">=</span> File.separator+<span class="hljs-string">&quot;html&quot;</span>+File.separator+<span class="hljs-string">&quot;student.html&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> outPutPath .substring(<span class="hljs-number">0</span>, outPutPath.lastIndexOf(File.separator));  <br><span class="hljs-comment">//System.out.println(substring);</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(substring);<br><br>Map&lt;String, Object&gt; datamap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>datamap.put(<span class="hljs-string">&quot;student&quot;</span>, student);<br><span class="hljs-comment">//System.out.println(&quot;---generateSummaryHtml &quot;+outPutPath);</span><br><br><span class="hljs-keyword">if</span>(!f.exists())&#123;<br>f.mkdirs();<br>&#125;<br><br><span class="hljs-comment">// 输出文件路径</span><br><span class="hljs-type">Writer</span> <span class="hljs-variable">wr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(outPutPath);<br><br><span class="hljs-comment">// 写入</span><br>template.process(datamap, wr);<br><span class="hljs-comment">// 关闭流</span><br>wr.close();<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据模板名获取ftl模板</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ftlName</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> TemplateNotFoundException</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> MalformedTemplateNameException</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ParseException</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Template <span class="hljs-title function_">getTemplateByFtlName</span><span class="hljs-params">(String ftlName)</span> <span class="hljs-keyword">throws</span> TemplateNotFoundException, MalformedTemplateNameException, ParseException, IOException&#123;<br><br>        <span class="hljs-comment">// 第一步：创建一个Configuration对象，直接new一个对象。构造方法的参数就是freemarker对于的版本号。</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(Configuration.getVersion());<br>        <span class="hljs-comment">// 第二步：设置模板文件所在的路径。</span><br>        configuration.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(File.separator+<span class="hljs-string">&quot;freemarker/&quot;</span>));<br>        <span class="hljs-comment">// 第三步：设置模板文件使用的字符集。一般就是utf-8.</span><br>        configuration.setDefaultEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br><br><span class="hljs-comment">// 获取ftl,由于已经在配置文件中配置了路径所以在这里直接写模板名称就可以</span><br><span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> configuration.getTemplate(ftlName);<br><span class="hljs-keyword">return</span> template;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意的是(new File(File.separator+”freemarker&#x2F;“));的路径是你项目所在的盘的绝对路径</p><p>例如我的项目在D盘所以我的放freemarker  ftl模板的路径是D:\freemarker</p><p>还有 </p><p>String outPutPath &#x3D; File.separator+”html”+File.separator+”student.html”;</p><p>生成的html模板也是项目所在盘的绝对路径 例如我的就是生成在 D:\html</p><p>然后还有Invoke.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><br><span class="hljs-keyword">import</span> com.way.dto.Student;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Way Liang asnphxw</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> Jul 4, 2018 </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoke</span> &#123;<br> <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String softPath;  <br><span class="hljs-meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;resource&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br><span class="hljs-comment">//调用的jar包位置</span><br><span class="hljs-type">String</span><span class="hljs-variable">softPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;file:D:&quot;</span>+File.separator+<span class="hljs-string">&quot;jar&quot;</span>+File.separator+<span class="hljs-string">&quot;freemarkerutil-test.jar&quot;</span>;<br><br><span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(softPath)&#125;,Thread.currentThread().getContextClassLoader());<br><span class="hljs-type">Class</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> classLoader.loadClass(<span class="hljs-string">&quot;com.way.util.FreemarkerUtil&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> demo.newInstance();<br><br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;way&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-string">&quot;male&quot;</span>);<br><br>demo.getMethod(<span class="hljs-string">&quot;generateStudentHtml&quot;</span>,Student.class).invoke(object, student);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要注意的是softPath是我用eclipse导出jar包后的位置 </p><p>然后还有 classLoader.loadClass(“com.way.util.FreemarkerUtil”)  包名都要对应</p><p>最后是把freemarkerutil－test打成jar包 </p><p>我用的是eclipse  右键freemarkerutil－test 点export</p><p><img src="https://img-blog.csdn.net/20180705155426338?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">  </p><p>注意的是点 JAR file生成的jar包  invoke调用会出现classnotfound的错误</p><p>要先运行 FreemarkerUtil.java 的main方法一次 </p><p>然后再点Runnable JAR file  </p><p>配置Launch configuration</p><p><img src="https://img-blog.csdn.net/20180705155619215?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>]]></content>
    
    
    <categories>
      
      <category>所有文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
