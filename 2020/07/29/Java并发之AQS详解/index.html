

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Way Leung">
  <meta name="keywords" content="Java 后端开发 软件开发 软件设计 软件工程师 博客 技术文章 个人学习 技能提升">
  
    <meta name="description" content="Java并发之AQS详解一、概述　　谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！ 　　类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLat">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发之AQS详解">
<meta property="og:url" content="http://example.com/2020/07/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="小梁的个人博客">
<meta property="og:description" content="Java并发之AQS详解一、概述　　谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！ 　　类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTcwNS83MjEwNzAtMjAxNzA1MDQxMTAyNDYyMTEtMTA2ODQ0ODUucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTUxMS83MjEwNzAtMjAxNTExMDIxNDU3NDM0NjEtNjIzNzk0MzI2LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg">
<meta property="article:published_time" content="2020-07-29T07:15:08.000Z">
<meta property="article:modified_time" content="2024-01-07T14:16:06.769Z">
<meta property="article:author" content="Way Leung">
<meta property="article:tag" content="转载">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTcwNS83MjEwNzAtMjAxNzA1MDQxMTAyNDYyMTEtMTA2ODQ0ODUucG5n?x-oss-process=image/format,png">
  
  
  
  <title>Java并发之AQS详解 - 小梁的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"BdCpJ8k5SK8pIjyC4pwydVSY-gzGzoHsz","app_key":"OyBjbqUomyG2Y1ArgpK2iUlc","server_url":"https://bdcpj8k5.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="小梁的个人博客" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wayleung</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java并发之AQS详解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-07-29 15:15" pubdate>
          2020年7月29日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          64 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java并发之AQS详解</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="Java并发之AQS详解"><a href="#Java并发之AQS详解" class="headerlink" title="Java并发之AQS详解"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></h2><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>　　谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！</p>
<p>　　类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…。</p>
<p>　　以下是本文的目录大纲：</p>
<ol>
<li><ol>
<li>概述</li>
<li>框架</li>
<li>源码详解</li>
<li>简单应用</li>
</ol>
</li>
</ol>
<p>　　若有不正之处，请谅解和批评指正，不胜感激。</p>
<p>　　请尊重作者劳动成果，转载请标明原文链接（原文持续更新，建议阅读原文）：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>
<h2 id="二、框架"><a href="#二、框架" class="headerlink" title="二、框架"></a>二、框架</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTcwNS83MjEwNzAtMjAxNzA1MDQxMTAyNDYyMTEtMTA2ODQ0ODUucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>　　它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p>
<ul>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()</li>
</ul>
<p>　　AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p>
<p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<h2 id="三、源码详解"><a href="#三、源码详解" class="headerlink" title="三、源码详解"></a>三、源码详解</h2><p>　　本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。</p>
<h3 id="3-0-结点状态waitStatus"><a href="#3-0-结点状态waitStatus" class="headerlink" title="3.0 结点状态waitStatus"></a>3.0 结点状态waitStatus</h3><p>      这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li><p><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</p>
</li>
<li><p><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</p>
</li>
<li><p><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</p>
</li>
<li><p><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</p>
</li>
<li><p><strong>0</strong>：新结点入队时的默认状态。</p>
</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
<h3 id="3-1-acquire-int"><a href="#3-1-acquire-int" class="headerlink" title="3.1 acquire(int)"></a>3.1 acquire(int)</h3><p>　　此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p>
<p>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }</p>
<p>　　函数流程如下：</p>
<ol>
<li><ol>
<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li>
<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
</li>
</ol>
<p>　　这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。就像《大话西游》里唐僧说的：等你明白了舍生取义的道理，你自然会回来和我唱这首歌的。</p>
<h4 id="3-1-1-tryAcquire-int"><a href="#3-1-1-tryAcquire-int" class="headerlink" title="3.1.1 tryAcquire(int)"></a>3.1.1 tryAcquire(int)</h4><p>　　此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p>
<p>1     protected boolean tryAcquire(int arg) {<br>2         throw new UnsupportedOperationException();<br>3     }</p>
<p>　　什么？直接throw异常？说好的功能呢？好吧，<strong>还记得概述里讲的AQS只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现吗？</strong>就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get&#x2F;set&#x2F;CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p>
<p>　　这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</p>
<h4 id="3-1-2-addWaiter-Node"><a href="#3-1-2-addWaiter-Node" class="headerlink" title="3.1.2 addWaiter(Node)"></a>3.1.2 addWaiter(Node)</h4><p>　　此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 private Node addWaiter(Node mode) {<br> 2     &#x2F;&#x2F;以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）<br> 3     Node node &#x3D; new Node(Thread.currentThread(), mode);<br> 4<br> 5     &#x2F;&#x2F;尝试快速方式直接放到队尾。<br> 6     Node pred &#x3D; tail;<br> 7     if (pred !&#x3D; null) {<br> 8         node.prev &#x3D; pred;<br> 9         if (compareAndSetTail(pred, node)) {<br>10             pred.next &#x3D; node;<br>11             return node;<br>12         }<br>13     }<br>14<br>15     &#x2F;&#x2F;上一步失败则通过enq入队。<br>16     enq(node);<br>17     return node;<br>18 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 不用再说了，直接看注释吧。</p>
<p>3.1.2.1 enq(Node)</p>
<p> 　　此方法用于将node加入队尾。源码如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 private Node enq(final Node node) {<br> 2     &#x2F;&#x2F;CAS”自旋”，直到成功加入队尾<br> 3     for (;;) {<br> 4         Node t &#x3D; tail;<br> 5         if (t &#x3D;&#x3D; null) { &#x2F;&#x2F; 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。<br> 6             if (compareAndSetHead(new Node()))<br> 7                 tail &#x3D; head;<br> 8         } else {&#x2F;&#x2F;正常流程，放入队尾<br> 9             node.prev &#x3D; t;<br>10             if (compareAndSetTail(t, node)) {<br>11                 t.next &#x3D; node;<br>12                 return t;<br>13             }<br>14         }<br>15     }<br>16 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。<strong>CAS自旋volatile变量</strong>，是一种很经典的用法。还不太了解的，自己去百度一下吧。</p>
<h4 id="3-1-3-acquireQueued-Node-int"><a href="#3-1-3-acquireQueued-Node-int" class="headerlink" title="3.1.3 acquireQueued(Node, int)"></a>3.1.3 acquireQueued(Node, int)</h4><p>　　OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。这个函数非常关键，还是上源码吧：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 final boolean acquireQueued(final Node node, int arg) {<br> 2     boolean failed &#x3D; true;&#x2F;&#x2F;标记是否成功拿到资源<br> 3     try {<br> 4         boolean interrupted &#x3D; false;&#x2F;&#x2F;标记等待过程中是否被中断过<br> 5<br> 6         &#x2F;&#x2F;又是一个“自旋”！<br> 7         for (;;) {<br> 8             final Node p &#x3D; node.predecessor();&#x2F;&#x2F;拿到前驱<br> 9             &#x2F;&#x2F;如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。<br>10             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) {<br>11                 setHead(node);&#x2F;&#x2F;拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。<br>12                 p.next &#x3D; null; &#x2F;&#x2F; setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！<br>13                 failed &#x3D; false; &#x2F;&#x2F; 成功获取资源<br>14                 return interrupted;&#x2F;&#x2F;返回等待过程中是否被中断过<br>15             }<br>16<br>17             &#x2F;&#x2F;如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。<br>18             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>19                 parkAndCheckInterrupt())<br>20                 interrupted &#x3D; true;&#x2F;&#x2F;如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true<br>21         }<br>22     } finally {<br>23         if (failed) &#x2F;&#x2F; 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。<br>24             cancelAcquire(node);<br>25     }<br>26 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</p>
<p>3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)</p>
<p>　　此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的<a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/p/4920007.html">Thread详解</a>），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br> 2     int ws &#x3D; pred.waitStatus;&#x2F;&#x2F;拿到前驱的状态<br> 3     if (ws &#x3D;&#x3D; Node.SIGNAL)<br> 4         &#x2F;&#x2F;如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了<br> 5         return true;<br> 6     if (ws &gt; 0) {<br> 7         &#x2F;*<br> 8          * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。<br> 9          * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！<br>10          *&#x2F;<br>11         do {<br>12             node.prev &#x3D; pred &#x3D; pred.prev;<br>13         } while (pred.waitStatus &gt; 0);<br>14         pred.next &#x3D; node;<br>15     } else {<br>16          &#x2F;&#x2F;如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！<br>17         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>18     }<br>19     return false;<br>20 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p>
<p>3.1.3.2 parkAndCheckInterrupt()</p>
<p>　　如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p>
<p>1 private final boolean parkAndCheckInterrupt() {<br>2     LockSupport.park(this);&#x2F;&#x2F;调用park()使线程进入waiting状态<br>3     return Thread.interrupted();&#x2F;&#x2F;如果被唤醒，查看自己是不是被中断的。<br>4 }</p>
<p> 　　park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的<a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/p/4920007.html">Thread详解</a>）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p>
<p>3.1.3.3 小结</p>
<p>　　OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</p>
<ol>
<li>结点进入队尾后，检查状态，找到安全休息点；</li>
<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>
</ol>
<h4 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h4><p>　　OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</p>
<p>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }</p>
<p>再来总结下它的流程吧：</p>
<ol>
<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>
<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
<p>由于此函数是重中之重，我再用流程图总结一下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTUxMS83MjEwNzAtMjAxNTExMDIxNDU3NDM0NjEtNjIzNzk0MzI2LnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</p>
<h3 id="3-2-release-int"><a href="#3-2-release-int" class="headerlink" title="3.2 release(int)"></a>3.2 release(int)</h3><p> 　　上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>1 public final boolean release(int arg) {<br>2     if (tryRelease(arg)) {<br>3         Node h &#x3D; head;&#x2F;&#x2F;找到头结点<br>4         if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)<br>5             unparkSuccessor(h);&#x2F;&#x2F;唤醒等待队列里的下一个线程<br>6         return true;<br>7     }<br>8     return false;<br>9 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>　　逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，<strong>它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</strong></p>
<h4 id="3-2-1-tryRelease-int"><a href="#3-2-1-tryRelease-int" class="headerlink" title="3.2.1 tryRelease(int)"></a>3.2.1 tryRelease(int)</h4><p>　　此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p>
<p>1 protected boolean tryRelease(int arg) {<br>2     throw new UnsupportedOperationException();<br>3 }</p>
<p>　　跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-&#x3D;arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state&#x3D;0)，要返回true，否则返回false。</p>
<h4 id="3-2-2-unparkSuccessor-Node"><a href="#3-2-2-unparkSuccessor-Node" class="headerlink" title="3.2.2 unparkSuccessor(Node)"></a>3.2.2 unparkSuccessor(Node)</h4><p>　　此方法用于唤醒等待队列中下一个线程。下面是源码：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 private void unparkSuccessor(Node node) {<br> 2     &#x2F;&#x2F;这里，node一般为当前线程所在的结点。<br> 3     int ws &#x3D; node.waitStatus;<br> 4     if (ws &lt; 0)&#x2F;&#x2F;置零当前线程所在的结点状态，允许失败。<br> 5         compareAndSetWaitStatus(node, ws, 0);<br> 6<br> 7     Node s &#x3D; node.next;&#x2F;&#x2F;找到下一个需要唤醒的结点s<br> 8     if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) {&#x2F;&#x2F;如果为空或已取消<br> 9         s &#x3D; null;<br>10         for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev) &#x2F;&#x2F; 从后向前找。<br>11             if (t.waitStatus &lt;&#x3D; 0)&#x2F;&#x2F;从这里可以看出，&lt;&#x3D;0的结点，都是还有效的结点。<br>12                 s &#x3D; t;<br>13     }<br>14     if (s !&#x3D; null)<br>15         LockSupport.unpark(s.thread);&#x2F;&#x2F;唤醒<br>16 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>　　这个函数并不复杂。一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg))的判断（即使p!&#x3D;head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p&#x3D;&#x3D;head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p>
<h4 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h4><p>　　release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源。</p>
<p>      74楼的朋友提了一个非常有趣的问题：如果获取锁的线程在release时异常了，没有unpark队列中的其他结点，这时队列中的其他结点会怎么办？是不是没法再被唤醒了？</p>
<p>      答案是<strong>YES</strong>（测试程序详见76楼）！！！这时，队列中等待锁的线程将永远处于park状态，无法再被唤醒！！！但是我们再回头想想，获取锁的线程在什么情形下会release抛出异常呢？？</p>
<ol>
<li>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</li>
<li>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</li>
<li>release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。<strong>除非自己写的tryRelease()有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了</strong>。</li>
</ol>
<h3 id="3-3-acquireShared-int"><a href="#3-3-acquireShared-int" class="headerlink" title="3.3 acquireShared(int)"></a>3.3 acquireShared(int)</h3><p>　　此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p>
<p>1 public final void acquireShared(int arg) {<br>2     if (tryAcquireShared(arg) &lt; 0)<br>3         doAcquireShared(arg);<br>4 }</p>
<p>　　这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p>
<ol>
<li><ol>
<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>
<li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li>
</ol>
</li>
</ol>
<h4 id="3-3-1-doAcquireShared-int"><a href="#3-3-1-doAcquireShared-int" class="headerlink" title="3.3.1 doAcquireShared(int)"></a>3.3.1 doAcquireShared(int)</h4><p>　　此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 private void doAcquireShared(int arg) {<br> 2     final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;加入队列尾部<br> 3     boolean failed &#x3D; true;&#x2F;&#x2F;是否成功标志<br> 4     try {<br> 5         boolean interrupted &#x3D; false;&#x2F;&#x2F;等待过程中是否被中断过的标志<br> 6         for (;;) {<br> 7             final Node p &#x3D; node.predecessor();&#x2F;&#x2F;前驱<br> 8             if (p &#x3D;&#x3D; head) {&#x2F;&#x2F;如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的<br> 9                 int r &#x3D; tryAcquireShared(arg);&#x2F;&#x2F;尝试获取资源<br>10                 if (r &gt;&#x3D; 0) {&#x2F;&#x2F;成功<br>11                     setHeadAndPropagate(node, r);&#x2F;&#x2F;将head指向自己，还有剩余资源可以再唤醒之后的线程<br>12                     p.next &#x3D; null; &#x2F;&#x2F; help GC<br>13                     if (interrupted)&#x2F;&#x2F;如果等待过程中被打断过，此时将中断补上。<br>14                         selfInterrupt();<br>15                     failed &#x3D; false;<br>16                     return;<br>17                 }<br>18             }<br>19<br>20             &#x2F;&#x2F;判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()<br>21             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>22                 parkAndCheckInterrupt())<br>23                 interrupted &#x3D; true;<br>24         }<br>25     } finally {<br>26         if (failed)<br>27             cancelAcquire(node);<br>28     }<br>29 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>　　有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</p>
<p>　　跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p>
<p>3.3.1.1 setHeadAndPropagate(Node, int)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 private void setHeadAndPropagate(Node node, int propagate) {<br> 2     Node h &#x3D; head;<br> 3     setHead(node);&#x2F;&#x2F;head指向自己<br> 4      &#x2F;&#x2F;如果还有剩余量，继续唤醒下一个邻居线程<br> 5     if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0) {<br> 6         Node s &#x3D; node.next;<br> 7         if (s &#x3D;&#x3D; null || s.isShared())<br> 8             doReleaseShared();<br> 9     }<br>10 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>　　此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p>
<p>　　doReleaseShared()我们留着下一小节的releaseShared()里来讲。</p>
<h4 id="3-3-2-小结"><a href="#3-3-2-小结" class="headerlink" title="3.3.2 小结"></a>3.3.2 小结</h4><p>　　OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</p>
<ol>
<li><ol>
<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>
<li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()&#x2F;interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li>
</ol>
</li>
</ol>
<p>　　其实跟acquire()的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p>
<h3 id="3-4-releaseShared"><a href="#3-4-releaseShared" class="headerlink" title="3.4 releaseShared()"></a>3.4 releaseShared()</h3><p>　　上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>1 public final boolean releaseShared(int arg) {<br>2     if (tryReleaseShared(arg)) {&#x2F;&#x2F;尝试释放资源<br>3         doReleaseShared();&#x2F;&#x2F;唤醒后继结点<br>4         return true;<br>5     }<br>6     return false;<br>7 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>　　此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state&#x3D;0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state&#x3D;0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p>
<h4 id="3-4-1-doReleaseShared"><a href="#3-4-1-doReleaseShared" class="headerlink" title="3.4.1 doReleaseShared()"></a>3.4.1 doReleaseShared()</h4><p>　　此方法主要用于唤醒后继。下面是它的源码：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 private void doReleaseShared() {<br> 2     for (;;) {<br> 3         Node h &#x3D; head;<br> 4         if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) {<br> 5             int ws &#x3D; h.waitStatus;<br> 6             if (ws &#x3D;&#x3D; Node.SIGNAL) {<br> 7                 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br> 8                     continue;<br> 9                 unparkSuccessor(h);&#x2F;&#x2F;唤醒后继<br>10             }<br>11             else if (ws &#x3D;&#x3D; 0 &amp;&amp;<br>12                      !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))<br>13                 continue;<br>14         }<br>15         if (h &#x3D;&#x3D; head)&#x2F;&#x2F; head发生变化<br>16             break;<br>17     }<br>18 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>　　本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()&#x2F;acquireSharedInterruptibly()即是，相应的源码跟acquire()和acquireShared()差不多，这里就不再详解了。</p>
<h2 id="四、简单应用"><a href="#四、简单应用" class="headerlink" title="四、简单应用"></a>四、简单应用</h2><p>　　通过前边几个章节的学习，相信大家已经基本理解AQS的原理了。这里再将“框架”一节中的一段话复制过来：</p>
<p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>　　OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。</p>
<h3 id="4-1-Mutex（互斥锁）"><a href="#4-1-Mutex（互斥锁）" class="headerlink" title="4.1 Mutex（互斥锁）"></a>4.1 Mutex（互斥锁）</h3><p>　　Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p> 1 class Mutex implements Lock, java.io.Serializable {<br> 2     &#x2F;&#x2F; 自定义同步器<br> 3     private static class Sync extends AbstractQueuedSynchronizer {<br> 4         &#x2F;&#x2F; 判断是否锁定状态<br> 5         protected boolean isHeldExclusively() {<br> 6             return getState() &#x3D;&#x3D; 1;<br> 7         }<br> 8<br> 9         &#x2F;&#x2F; 尝试获取资源，立即返回。成功则返回true，否则false。<br>10         public boolean tryAcquire(int acquires) {<br>11             assert acquires &#x3D;&#x3D; 1; &#x2F;&#x2F; 这里限定只能为1个量<br>12             if (compareAndSetState(0, 1)) {&#x2F;&#x2F;state为0才设置为1，不可重入！<br>13                 setExclusiveOwnerThread(Thread.currentThread());&#x2F;&#x2F;设置为当前线程独占资源<br>14                 return true;<br>15             }<br>16             return false;<br>17         }<br>18<br>19         &#x2F;&#x2F; 尝试释放资源，立即返回。成功则为true，否则false。<br>20         protected boolean tryRelease(int releases) {<br>21             assert releases &#x3D;&#x3D; 1; &#x2F;&#x2F; 限定为1个量<br>22             if (getState() &#x3D;&#x3D; 0)&#x2F;&#x2F;既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！<br>23                 throw new IllegalMonitorStateException();<br>24             setExclusiveOwnerThread(null);<br>25             setState(0);&#x2F;&#x2F;释放资源，放弃占有状态<br>26             return true;<br>27         }<br>28     }<br>29<br>30     &#x2F;&#x2F; 真正同步类的实现都依赖继承于AQS的自定义同步器！<br>31     private final Sync sync &#x3D; new Sync();<br>32<br>33     &#x2F;&#x2F;lock&lt;–&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。<br>34     public void lock() {<br>35         sync.acquire(1);<br>36     }<br>37<br>38     &#x2F;&#x2F;tryLock&lt;–&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。<br>39     public boolean tryLock() {<br>40         return sync.tryAcquire(1);<br>41     }<br>42<br>43     &#x2F;&#x2F;unlock&lt;–&gt;release。两者语文一样：释放资源。<br>44     public void unlock() {<br>45         sync.release(1);<br>46     }<br>47<br>48     &#x2F;&#x2F;锁是否占有状态<br>49     public boolean isLocked() {<br>50         return sync.isHeldExclusively();<br>51     }<br>52 }</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" srcset="/img/loading.gif" lazyload alt="复制代码"></p>
<p>　　同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</p>
<p>　　除了Mutex，ReentrantLock&#x2F;CountDownLatch&#x2F;Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</p>
<p>　　OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</p>
<ul>
<li>作者：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone">水岩</a></li>
<li>出处：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone">http://www.cnblogs.com/waterystone</a></li>
<li>本博客中未标明转载的文章归作者<a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/">水岩</a>和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/" class="category-chain-item">所有文章</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%BD%AC%E8%BD%BD/" class="print-no-link">#转载</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java并发之AQS详解</div>
      <div>http://example.com/2020/07/29/Java并发之AQS详解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Way Leung</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年7月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/" title="代理模式中静态代理、jdk动态代理、cglib动态代理有什么不同？">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">代理模式中静态代理、jdk动态代理、cglib动态代理有什么不同？</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/29/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87ThreadLocal%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%83%BD%E7%94%A8%E5%BE%97%E8%BF%99%E4%B9%88%E6%BA%9C/" title="看完这篇ThreadLocal的详解，你也能用得这么溜">
                        <span class="hidden-mobile">看完这篇ThreadLocal的详解，你也能用得这么溜</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"BdCpJ8k5SK8pIjyC4pwydVSY-gzGzoHsz","appKey":"OyBjbqUomyG2Y1ArgpK2iUlc","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
