<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小梁的个人博客</title>
  
  <subtitle>wayleung</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-07T14:12:36.194Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Way Leung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring 循环依赖和三级缓存</title>
    <link href="http://example.com/2021/01/19/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://example.com/2021/01/19/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2021-01-19T03:34:14.000Z</published>
    <updated>2024-01-07T14:12:36.194Z</updated>
    
    <content type="html"><![CDATA[<p>前言</p><p>Spring中的循环依赖一直是Spring中一个很重要的话题，一方面是因为源码中为了解决循环依赖做了很多处理，另外一方面是因为面试的时候，如果问到Spring中比较高阶的问题，那么循环依赖必定逃不掉。如果你回答得好，那么这就是你的必杀技，反正，那就是面试官的必杀技，这也是取这个标题的原因，当然，本文的目的是为了让你在之后的所有面试中能多一个必杀技，专门用来绝杀面试官！</p><p>本文的核心思想就是，</p><p>当面试官问：</p><p>“请讲一讲Spring中的循环依赖。”的时候，</p><p>我们到底该怎么回答？</p><p>主要分下面几点</p><h3 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h3><p>什么情况下循环依赖可以被处理？</p><p>Spring是如何解决的循环依赖？</p><p>同时本文希望纠正几个目前业界内经常出现的几个关于循环依赖的错误的说法</p><p>只有在setter方式注入的情况下，循环依赖才能解决（错）</p><p>三级缓存的目的是为了提高效率（错）</p><p>OK，铺垫已经做完了，接下来我们开始正文</p><p>什么是循环依赖？</p><p>从字面上来理解就是A依赖B的同时B也依赖了A，就像下面这样</p><p><img src="https://img-blog.csdnimg.cn/img_convert/49462131406f26c9ee2f631344847803.png"></p><p>体现到代码层次就是这个样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class A &#123;<br>    // A中注入了B<br>    @Autowired<br>    private B b;<br>&#125;<br><br>@Component<br>public class B &#123;<br>    // B中也注入了A<br>    @Autowired<br>    private A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这是最常见的一种循环依赖，比较特殊的还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">// 自己依赖自己<br>@Component<br>public class A &#123;<br>    // A中注入了A<br>    @Autowired<br>    private A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然体现形式不一样，但是实际上都是同一个问题—–&gt;循环依赖</p><h3 id="什么情况下循环依赖可以被处理？"><a href="#什么情况下循环依赖可以被处理？" class="headerlink" title="什么情况下循环依赖可以被处理？"></a>什么情况下循环依赖可以被处理？</h3><p>在回答这个问题之前首先要明确一点，Spring解决循环依赖是有前置条件的</p><p>出现循环依赖的Bean必须要是单例</p><p>依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）</p><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class A &#123;<br>//    @Autowired<br>//    private B b;<br>    public A(B b) &#123;<br><br>    &#125;<br>&#125;<br><br><br>@Component<br>public class B &#123;<br><br>//    @Autowired<br>//    private A a;<br><br>    public B(A a)&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决，如果你的项目中有两个这样相互依赖的Bean，在启动时就会报出以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#x27;a&#x27;: Requested bean is currently in creation: Is there an unresolvable circular reference?<br></code></pre></td></tr></table></figure><p>为了测试循环依赖的解决情况跟注入方式的关系，我们做如下四种情况的测试：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/670ce918ea6d1da0797b73bff859a782.png"></p><p>具体的测试代码跟简单，我就不放了。从上面的测试结果我们可以看到，不是只有在setter方法注入的情况下循环依赖才能被解决，即使存在构造器注入的场景下，循环依赖依然被可以被正常处理掉。</p><p>那么到底是为什么呢？Spring到底是怎么处理的循环依赖呢？不要急，我们接着往下看</p><h3 id="Spring是如何解决的循环依赖？"><a href="#Spring是如何解决的循环依赖？" class="headerlink" title="Spring是如何解决的循环依赖？"></a>Spring是如何解决的循环依赖？</h3><p>关于循环依赖的解决方式应该要分两种情况来讨论</p><p>简单的循环依赖（没有AOP）</p><p>结合了AOP的循环依赖</p><p>简单的循环依赖（没有AOP）</p><p>我们先来分析一个最简单的例子，就是上面提到的那个demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class A &#123;<br>    // A中注入了B<br>    @Autowired<br>    private B b;<br>&#125;<br><br>@Component<br>public class B &#123;<br>    // B中也注入了A<br>    @Autowired<br>    private A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上文我们已经知道了这种情况下的循环依赖是能够被解决的，那么具体的流程是什么呢？我们一步步分析</p><p>首先，我们要知道Spring在创建Bean的时候默认是按照自然排序来进行创建的，所以第一步Spring会去创建A。</p><p>与此同时，我们应该知道，Spring在创建Bean的过程中分为三步</p><p>实例化，对应方法：AbstractAutowireCapableBeanFactory中的createBeanInstance方法</p><p>属性注入，对应方法：AbstractAutowireCapableBeanFactory的populateBean方法</p><p>初始化，对应方法：AbstractAutowireCapableBeanFactory的initializeBean</p><p>这些方法在之前源码分析的文章中都做过详细的解读了，如果你之前没看过我的文章，那么你只需要知道</p><p>实例化，简单理解就是new了一个对象</p><p>属性注入，为实例化中new出来的对象填充属性</p><p>初始化，执行aware接口中的方法，初始化方法，完成AOP代理</p><p>基于上面的知识，我们开始解读整个循环依赖处理的过程，整个流程应该是以A的创建为起点，前文也说了，第一步就是创建A嘛！</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b37eeaa5a8bb088c02c50aec435e8791.png"></p><p>创建A的过程实际上就是调用getBean方法，这个方法有两层含义</p><p>创建一个新的Bean</p><p>从缓存中获取到已经被创建的对象</p><p>我们现在分析的是第一层含义，因为这个时候缓存中还没有A嘛！</p><h3 id="调用getSingleton-beanName"><a href="#调用getSingleton-beanName" class="headerlink" title="调用getSingleton(beanName)"></a>调用getSingleton(beanName)</h3><p>首先调用getSingleton(a)方法，这个方法又会调用getSingleton(beanName, true)，在上图中我省略了这一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">public Object getSingleton(String beanName) &#123;<br>    return getSingleton(beanName, true);<br>&#125;<br></code></pre></td></tr></table></figure><p>getSingleton(beanName, true)这个方法实际上就是到缓存中尝试去获取Bean，整个缓存分为三级</p><p>singletonObjects，一级缓存，存储的是所有创建好了的单例Bean</p><p>earlySingletonObjects，完成实例化，但是还未进行属性注入及初始化的对象</p><p>singletonFactories，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象</p><p>因为A是第一次被创建，所以不管哪个缓存中必然都是没有的，因此会进入getSingleton的另外一个重载方法getSingleton(beanName, singletonFactory)。</p><h3 id="调用getSingleton-beanName-singletonFactory"><a href="#调用getSingleton-beanName-singletonFactory" class="headerlink" title="调用getSingleton(beanName, singletonFactory)"></a>调用getSingleton(beanName, singletonFactory)</h3><p>这个方法就是用来创建Bean的，其源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs auto">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;<br>    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);<br>    synchronized (this.singletonObjects) &#123;<br>        Object singletonObject = this.singletonObjects.get(beanName);<br>        if (singletonObject == null) &#123;<br><br>            // ....<br>            // 省略异常处理及日志<br>            // ....<br><br>            // 在单例对象创建前先做一个标记<br>            // 将beanName放入到singletonsCurrentlyInCreation这个集合中<br>            // 标志着这个单例Bean正在创建<br>            // 如果同一个单例Bean多次被创建，这里会抛出异常<br>            beforeSingletonCreation(beanName);<br>            boolean newSingleton = false;<br>            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);<br>            if (recordSuppressedExceptions) &#123;<br>                this.suppressedExceptions = new LinkedHashSet&lt;&gt;();<br>            &#125;<br>            try &#123;<br>                // 上游传入的lambda在这里会被执行，调用createBean方法创建一个Bean后返回<br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = true;<br>            &#125;<br>            // ...<br>            // 省略catch异常处理<br>            // ...<br>            finally &#123;<br>                if (recordSuppressedExceptions) &#123;<br>                    this.suppressedExceptions = null;<br>                &#125;<br>                // 创建完成后将对应的beanName从singletonsCurrentlyInCreation移除<br>                afterSingletonCreation(beanName);<br>            &#125;<br>            if (newSingleton) &#123;<br>                // 添加到一级缓存singletonObjects中<br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>        &#125;<br>        return singletonObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码我们主要抓住一点，通过createBean方法返回的Bean最终被放到了一级缓存，也就是单例池中。</p><p>那么到这里我们可以得出一个结论：一级缓存中存储的是已经完全创建好了的单例Bean</p><h3 id="调用addSingletonFactory方法"><a href="#调用addSingletonFactory方法" class="headerlink" title="调用addSingletonFactory方法"></a>调用addSingletonFactory方法</h3><p>如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fefaade085b561704af220ceef300b53.png"></p><p>在完成Bean的实例化后，属性注入之前Spring将Bean包装成一个工厂添加进了三级缓存中，对应源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">// 这里传入的参数也是一个lambda表达式，() -&gt; getEarlyBeanReference(beanName, mbd, bean)<br>protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;<br>    Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);<br>    synchronized (this.singletonObjects) &#123;<br>        if (!this.singletonObjects.containsKey(beanName)) &#123;<br>            // 添加到三级缓存中<br>            this.singletonFactories.put(beanName, singletonFactory);<br>            this.earlySingletonObjects.remove(beanName);<br>            this.registeredSingletons.add(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只是添加了一个工厂，通过这个工厂（ObjectFactory）的getObject方法可以得到一个对象，而这个对象实际上就是通过getEarlyBeanReference这个方法创建的。那么，什么时候会去调用这个工厂的getObject方法呢？这个时候就要到创建B的流程了。</p><p>当A完成了实例化并添加进了三级缓存后，就要开始为A进行属性注入了，在注入时发现A依赖了B，那么这个时候Spring又会去getBean(b)，然后反射调用setter方法完成属性注入。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b7e6c73f67c84e50c11bbadfd806f5de.png"></p><p>因为B需要注入A，所以在创建B的时候，又会去调用getBean(a)，这个时候就又回到之前的流程了，但是不同的是，之前的getBean是为了创建Bean，而此时再调用getBean不是为了创建了，而是要从缓存中获取，因为之前A在实例化后已经将其放入了三级缓存singletonFactories中，所以此时getBean(a)的流程就是这样子了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f5d078f0b1c26589d9ae5be4cf883402.png"></p><p>从这里我们可以看出，注入到B中的A是通过getEarlyBeanReference方法提前暴露出去的一个对象，还不是一个完整的Bean，那么getEarlyBeanReference到底干了啥了，我们看下它的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;<br>    Object exposedObject = bean;<br>    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;<br>                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>它实际上就是调用了后置处理器的getEarlyBeanReference，而真正实现了这个方法的后置处理器只有一个，就是通过@EnableAspectJAutoProxy注解导入的AnnotationAwareAspectJAutoProxyCreator。也就是说如果在不考虑AOP的情况下，上面的代码等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;<br>    Object exposedObject = bean;<br>    return exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说这个工厂啥都没干，直接将实例化阶段创建的对象返回了！所以说在不考虑AOP的情况下三级缓存有用嘛？讲道理，真的没什么用，我直接将这个对象放到二级缓存中不是一点问题都没有吗？如果你说它提高了效率，那你告诉我提高的效率在哪?</p><p>那么三级缓存到底有什么作用呢？不要急，我们先把整个流程走完，在下文结合AOP分析循环依赖的时候你就能体会到三级缓存的作用！</p><p>到这里不知道小伙伴们会不会有疑问，B中提前注入了一个没有经过初始化的A类型对象不会有问题吗？</p><p>答：不会</p><p>这个时候我们需要将整个创建A这个Bean的流程走完，如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/49ed72a2793cccdb3800e41075228daf.png"></p><p>从上图中我们可以看到，虽然在创建B时会提前给B注入了一个还未初始化的A对象，但是在创建A的流程中一直使用的是注入到B中的A对象的引用，之后会根据这个引用对A进行初始化，所以这是没有问题的。</p><h3 id="结合了AOP的循环依赖"><a href="#结合了AOP的循环依赖" class="headerlink" title="结合了AOP的循环依赖"></a>结合了AOP的循环依赖</h3><p>之前我们已经说过了，在普通的循环依赖的情况下，三级缓存没有任何作用。三级缓存实际上跟Spring中的AOP相关，我们再来看一看getEarlyBeanReference的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;<br>    Object exposedObject = bean;<br>    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;<br>                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在开启AOP的情况下，那么就是调用到AnnotationAwareAspectJAutoProxyCreator的getEarlyBeanReference方法，对应的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs auto">public Object getEarlyBeanReference(Object bean, String beanName) &#123;<br>    Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>    this.earlyProxyReferences.put(cacheKey, bean);<br>    // 如果需要代理，返回一个代理对象，不需要代理，直接返回当前传入的这个bean对象<br>    return wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>回到上面的例子，我们对A进行了AOP代理的话，那么此时getEarlyBeanReference将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ce0a289060ce766f18710e20eb94ddc6.png"></p><p>看到这个图你可能会产生下面这些疑问</p><p>在给B注入的时候为什么要注入一个代理对象？</p><p>答：当我们对A进行了AOP代理时，说明我们希望从容器中获取到的就是A代理后的对象而不是A本身，因此把A当作依赖进行注入时也要注入它的代理对象</p><p>明明初始化的时候是A对象，那么Spring是在哪里将代理对象放入到容器中的呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/129a11ee7d70690e46c0101341dd08d4.png"></p><p>在完成初始化后，Spring又调用了一次getSingleton方法，这一次传入的参数又不一样了，false可以理解为禁用三级缓存，前面图中已经提到过了，在为B中注入A时已经将三级缓存中的工厂取出，并从工厂中获取到了一个对象放入到了二级缓存中，所以这里的这个getSingleton方法做的时间就是从二级缓存中获取到这个代理后的A对象。exposedObject &#x3D;&#x3D; bean可以认为是必定成立的，除非你非要在初始化阶段的后置处理器中替换掉正常流程中的Bean，例如增加一个后置处理器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs auto">@Component<br>public class MyPostProcessor implements BeanPostProcessor &#123;<br>    @Override<br>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;<br>        if (beanName.equals(&quot;a&quot;)) &#123;<br>            return new A();<br>        &#125;<br>        return bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，请不要做这种骚操作，徒增烦恼！</p><p>初始化的时候是对A对象本身进行初始化，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</p><p>答：不会，这是因为不管是cglib代理还是jdk动态代理生成的代理类，内部都持有一个目标类的引用，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化</p><p>三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？</p><p>答：这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</p><p>我们思考一种简单的情况，就以单独创建A为例，假设AB之间现在没有依赖关系，但是A被代理了，这个时候当A完成实例化后还是会进入下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs auto">// A是单例的，mbd.isSingleton()条件满足<br>// allowCircularReferences：这个变量代表是否允许循环依赖，默认是开启的，条件也满足<br>// isSingletonCurrentlyInCreation：正在在创建A，也满足<br>// 所以earlySingletonExposure=true<br>boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;<br>                                  isSingletonCurrentlyInCreation(beanName));<br>// 还是会进入到这段代码中<br>if (earlySingletonExposure) &#123;<br>    // 还是会通过三级缓存提前暴露一个工厂对象<br>    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br></code></pre></td></tr></table></figure><p>看到了吧，即使没有循环依赖，也会将其添加到三级缓存中，而且是不得不添加到三级缓存中，因为到目前为止Spring也不能确定这个Bean有没有跟别的Bean出现循环依赖。</p><p>假设我们在这里直接使用二级缓存的话，那么意味着所有的Bean在这一步都要完成AOP代理。这样做有必要吗？</p><p>不仅没有必要，而且违背了Spring在结合AOP跟Bean的生命周期的设计！Spring结合AOP跟Bean的生命周期本身就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来完成的，在这个后置处理的postProcessAfterInitialization方法中对初始化后的Bean完成AOP代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。</p><h3 id="三级缓存真的提高了效率了吗？"><a href="#三级缓存真的提高了效率了吗？" class="headerlink" title="三级缓存真的提高了效率了吗？"></a>三级缓存真的提高了效率了吗？</h3><p>现在我们已经知道了三级缓存的真正作用，但是这个答案可能还无法说服你，所以我们再最后总结分析一波，三级缓存真的提高了效率了吗？分为两点讨论：</p><p>没有进行AOP的Bean间的循环依赖</p><p>从上文分析可以看出，这种情况下三级缓存根本没用！所以不会存在什么提高了效率的说法</p><p>进行了AOP的Bean间的循环依赖</p><p>就以我们上的A、B为例，其中A被AOP代理，我们先分析下使用了三级缓存的情况下，A、B的创建流程</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ea2b630fc6e5055e1e91699e1ba0f389.png"></p><p>假设不使用三级缓存，直接在二级缓存中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/75153d446d1c125a9605aa9c881904b1.png"></p><p>上面两个流程的唯一区别在于为A对象创建代理的时机不同，在使用了三级缓存的情况下为A创建代理的时机是在B中需要注入A的时候，而不使用三级缓存的话在A实例化后就需要马上为A创建代理然后放入到二级缓存中去。对于整个A、B的创建过程而言，消耗的时间是一样的</p><p>综上，不管是哪种情况，三级缓存提高了效率这种说法都是错误的！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试官：”Spring是如何解决的循环依赖？“</p><p>答：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><p>面试官：”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“</p><p>答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p><h3 id="一道思考题"><a href="#一道思考题" class="headerlink" title="一道思考题"></a>一道思考题</h3><p>为什么在下表中的第三种情况的循环依赖能被解决，而第四种情况不能被解决呢？</p><p>提示：Spring在创建Bean时默认会根据自然排序进行创建，所以A会先于B进行创建。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/80dae51e68b503803e4143ec18864c8c.png"></p><p>作者：Java程序猿阿谷<br>链接：<a href="https://zhuanlan.zhihu.com/p/157611040">https://zhuanlan.zhihu.com/p/157611040</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;Spring中的循环依赖一直是Spring中一个很重要的话题，一方面是因为源码中为了解决循环依赖做了很多处理，另外一方面是因为面试的时候，如果问到Spring中比较高阶的问题，那么循环依赖必定逃不掉。如果你回答得好，那么这就是你的必杀技，反正，那就是面试</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>秒懂 kafka HA（高可用）</title>
    <link href="http://example.com/2021/01/05/%E7%A7%92%E6%87%82%20kafka%20HA%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <id>http://example.com/2021/01/05/%E7%A7%92%E6%87%82%20kafka%20HA%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/</id>
    <published>2021-01-05T06:23:07.000Z</published>
    <updated>2024-01-07T14:12:33.269Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和-kafka-高可用相关的一些策略。"><a href="#我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和-kafka-高可用相关的一些策略。" class="headerlink" title="我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和 kafka 高可用相关的一些策略。"></a>我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本的follower是怎么复制备份leader的数据的？本文我们就来说一说和 kafka 高可用相关的一些策略。</h3><p>01</p><p>名词解释</p><p>要想说明白kafka的HA机制，我们必须先搞明白几个缩写名词，</p><p><strong>1、AR、ISR、OSR</strong></p><p>AR：Assigned Replicas，某分区的所有副本（这里所说的副本包括leader和follower）统称为 AR。</p><p>ISR：In Sync Replicas，所有与leader副本保持”一定程度同步”的副本（包括leader副本在内）组成 ISR 。生产者发送消息时，只有leader与客户端发生交互，follower只是同步备份leader的数据，以保障高可用，所以生产者的消息会先发送到leader，然后follower才能从leader中拉取消息进行同步，同步期间，follower的数据相对leader而言会有一定程度的滞后，前面所说的”一定程度同步”就是指可忍受的滞后范围，这个范围可以通过server.properties中的参数进行配置。</p><p>OSR ：Out-of-Sync Replied，在上面的描述中，相对leader滞后过多的follower将组成OSR 。</p><p>由此可见，AR &#x3D; ISR + OSR，理想情况下，所有的follower副本都应该与leader 保持一定程度的同步，即AR&#x3D;ISR，OSR集合为空</p><p><strong>2、ISR 的伸缩性</strong></p><p>leader负责跟踪维护 ISR 集合中所有follower副本的滞后状态，当follower副本”落后太多” 或 “follower超过一定时间没有向leader发送同步请求”时，leader副本会把它从 ISR 集合中剔除。如果 OSR 集合中有follower副本”追上”了leader副本，那么leader副本会把它从 OSR 集合转移至 ISR 集合。</p><p>上面描述的”落后太多”是指follower复制的消息落后于leader的条数超过预定值，这个预定值可在server.properties中通过replica.lag.max.messages配置，其默认值是4000。”超过一定时间没有向leader发送同步请求”，这个”一定时间”可以在server.properties中通过replica.lag.time.max.ms来配置，其默认值是10000，默认情况下，当leader发生故障时，只有 ISR 集合中的follower副本才有资格被选举为新的leader，而在 OSR 集合中的副本则没有任何机会（不过这个可以通过配置来改变）。</p><p><strong>3、HW</strong></p><p>HW （High Watermark）俗称高水位，它标识了一个特定的消息偏移量（offset），消费者只能消费HW之前的消息。</p><p>下图表示一个日志文件，这个日志文件中有9条消息，第一条消息的offset为0，最后一条消息的offset为8，虚线表示的offset为9的消息，代表下一条待写入的消息。日志文件的 HW 为6，表示消费者只能拉取offset在 0 到 5 之间的消息，offset为6的消息对消费者而言是不可见的。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a0b27955baa4da021745a5d8120dba3c.png" alt="Image"></p><p><strong>4、LEO</strong></p><p>LEO （Log End Offset），标识当前日志文件中下一条待写入的消息的offset。上图中offset为9的位置即为当前日志文件的 LEO，分区 ISR 集合中的每个副本都会维护自身的 LEO ，而 ISR 集合中最小的 LEO 即为分区的 HW（你品，你细品…），对消费者而言只能消费 HW 之前的消息。</p><p><strong>5、 ISR 集合和 HW、LEO的关系</strong></p><p>producer在发布消息到partition时，只会与该partition的leader发生交互将消息发送给leader，leader会将该消息写入其本地log，每个follower都从leader上pull数据做同步备份，follower在pull到该消息并写入其log后，会向leader发送ack，一旦leader收到了ISR中的所有follower的ack（只关注ISR中的所有follower，不考虑OSR，一定程度上提升了吞吐），该消息就被认为已经commit了，leader将增加HW，然后向producer发送ack。</p><p>也就是说，在ISR中所有的follower还没有完成数据备份之前，leader不会增加HW，也就是这条消息暂时还不能被消费者消费，只有当ISR中所有的follower都备份完成后，leader才会将HW后移。</p><p>ISR集合中LEO最小的副本，即同步数据同步的最慢的一个，这个最慢副本的LEO即leader的HW，消费者只能消费HW之前的消息。</p><p>02</p><p>kafka HA</p><p>Tips：我们说的副本包括leader和follower，都叫副本，不要认为叫副本说的就是follower。</p><p>kafka在0.8以前的版本中是没有分区副本的概念的，一旦某一个broker宕机，这个broker上的所有分区都将不可用。在0.8版本以后，引入了分区副本的概念，同一个partition可以有多个副本，在多个副本中会选出一个做leader，其余的作为follower，只有leader对外提供读写服务，follower只负责从leader上同步拉取数据，已保障高可用。</p><p>1、partition副本的分配策略</p><p>每个topic有多个partition，每个partition有多个副本，这些partition副本分布在不同的broker上，以保障高可用，那么这些partition副本是怎么均匀的分布到集群中的每个broker上的呢？</p><p>※ kafka分配partition副本的算法如下，</p><p>① 将所有的broker（假设总共n个broker）和 待分配的partition排序；</p><p>② 将第i个partition分配到第（i mod n）个broker上；</p><p>③ 第i个partition的第j个副本分配到第（(i+j) mod n）个broker上；</p><p>2、kafka的消息传递备份策略</p><p>生产者将消息发送给分区的leader，leader会将该消息写入其本地log，然后每个follower都会从leader pull数据，follower pull到该消息并将其写入log后，会向leader发送ack，当leader收到了ISR集合中所有follower的ack后，就认为这条消息已经commit了，leader将增加HW并且向生产者返回ack。在整个流程中，follower也可以批量的从leader复制数据，以提升复制性能。</p><p>producer在发送消息的时候，可指定参数acks，表示”在生产者认为发送请求完成之前，有多少分区副本必须接收到数据”，有三个可选值，0、1、all(或-1)，默认为1，</p><ul><li><p>acks&#x3D;0，表示producer只管发，只要发出去就认为发发送请求完成了，不管leader有没有收到，更不管follower有没有备份完成。</p></li><li><p>acks&#x3D;1，表示只要leader收到消息，并将其写入自己log后，就会返回给producer ack，不考虑follower有没有备份完成。</p></li><li><p>acks&#x3D;all(或-1)，表示不仅要leader收到消息写入本地log，还要等所有ISR集合中的follower都备份完成后，producer才认为发送成功。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/420b84aa4e74c2ec169520070903c101.png" alt="Image">实际上，为了提高性能，follower在pull到消息将其保存到内存中而尚未写入磁盘时，就会向leader发送ack，所以也就不能完全保证异常发生后该条消息一定能被Consumer消费。</p><p>3、kafka中的Leader选举</p><p>面试官在考查你kafka知识的时候如果问你：kafka中的选举是怎么回事？而不说具体哪种选举，那这个面试官可能对kafka也是一知半解，这个时候就是”弄死”他的时候了，当然如果你没有一定的知识储备，那么就是你被”弄死”的时候。</p><p>因为kafka中涉及到选举的地方有多处，最常提及的也有：①cotroller选举 、 ②分区leader选举 和 ③consumer group leader的选举。我们在前面说过同一个partition有多个副本，其中一个副本作为leader，其余的作为follower。这里我们再说一个角色：controller！kafka集群中多个broker，有一个会被选举为controller，注意区分两者，一个是broker的leader，我们称为controller，一个是分区副本的leader，我们称为leader。</p><p>① controller的选举【broker的leader】</p><p>controller的选举是通过broker在zookeeper的”&#x2F;controller”节点下创建临时节点来实现的，并在该节点中写入当前broker的信息 {“version”:1,”brokerid”:1,”timestamp”:”1512018424988”} ，利用zookeeper的强一致性特性，一个节点只能被一个客户端创建成功，创建成功的broker即为controller，即”先到先得”。 </p><p>当controller宕机或者和zookeeper失去连接时，zookeeper检测不到心跳，zookeeper上的临时节点会被删除，而其它broker会监听临时节点的变化，当节点被删除时，其它broker会收到通知，重新发起controller选举。</p><p>② leader的选举【分区副本的leader】</p><p>分区leader的选举由 controller 负责管理和实施，当leader发生故障时，controller会将leader的改变直接通过RPC的方式通知需要为此作出响应的broker，需要为此作出响应的broker即该分区的ISR集合中follower所在的broker，kafka在zookeeper中动态维护了一个ISR，只有ISR里的follower才有被选为Leader的可能。</p><p>具体过程是这样的：按照AR集合中副本的顺序 查找到 第一个 存活的、并且属于ISR集合的 副本作为新的leader。一个分区的AR集合在创建分区副本的时候就被指定，只要不发生重分配的情况，AR集合内部副本的顺序是保持不变的，而分区的ISR集合上面说过因为同步滞后等原因可能会改变，所以注意这里是根据AR的顺序而不是ISR的顺序找。</p><p>※ 对于上面描述的过程我们假设一种极端的情况，如果partition的所有副本都不可用时，怎么办？这种情况下kafka提供了两种可行的方案：</p><p>1、选择 ISR中 第一个活过来的副本作为Leader；</p><p>2、选择第一个活过来的副本（不一定是ISR中的）作为Leader；</p><p>这就需要在可用性和数据一致性当中做出选择，如果一定要等待ISR中的副本活过来，那不可用的时间可能会相对较长。选择第一个活过来的副本作为Leader，如果这个副本不在ISR中，那数据的一致性则难以保证。kafka支持用户通过配置选择，以根据业务场景在可用性和数据一致性之间做出权衡。</p><p>③消费组leader的选举</p><p>组协调器会为消费组（consumer group）内的所有消费者选举出一个leader，这个选举的算法也很简单，第一个加入consumer group的consumer即为leader，如果某一时刻leader消费者退出了消费组，那么会重新 随机 选举一个新的leader。</p><p>03</p><p>kafka架构中zookeeper的结构</p><p>1、查看方式</p><p>我们知道，kafka是基于zookeeper协调管理的，那么zookeeper中究竟存储了哪些信息？另外在后面分析 broker宕机 和 controller宕机 时，我们也需要先了解zookeeper的目录结构，所以我们先学习一下怎么查看zookeeper的目录结构？</p><p>① 首先启动zookeeper客户端连接zk服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto"># cd /usr/local/zookeeper-cluster/zk1/bin# ./zkCli.sh<br></code></pre></td></tr></table></figure><p>② 查看zk根节点的子目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">[zk: localhost:2181(CONNECTED) 0] ls /[cluster, controller_epoch, controller, brokers, zookeeper, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]<br></code></pre></td></tr></table></figure><p>③ 可以看到zk根节点下有很多子目录，以brokers为例，查看brokers的层级结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">[zk: localhost:2181(CONNECTED) 1] ls /brokers[ids, topics, seqid][zk: localhost:2181(CONNECTED) 2] ls /brokers/ids[0][zk: localhost:2181(CONNECTED) 3] get /brokers/ids/0&#123;&quot;listener_security_protocol_map&quot;:&#123;&quot;PLAINTEXT&quot;:&quot;PLAINTEXT&quot;&#125;,&quot;endpoints&quot;:[&quot;PLAINTEXT://172.17.80.219:9092&quot;],&quot;jmx_port&quot;:-1,&quot;host&quot;:&quot;172.17.80.219&quot;,&quot;timestamp&quot;:&quot;1584267365984&quot;,&quot;port&quot;:9092,&quot;version&quot;:4&#125;cZxid = 0x300000535ctime = Sun Mar 15 18:16:06 CST 2020mZxid = 0x300000535mtime = Sun Mar 15 18:16:06 CST 2020pZxid = 0x300000535cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x20191d7053f0009dataLength = 196numChildren = 0[zk: localhost:2181(CONNECTED) 4] [zk: localhost:2181(CONNECTED) 4][zk: localhost:2181(CONNECTED) 4][zk: localhost:2181(CONNECTED) 4] ls /brokers/topics[__consumer_offsets, first][zk: localhost:2181(CONNECTED) 5] ls /brokers/topics/first[partitions][zk: localhost:2181(CONNECTED) 6] ls /brokers/topics/first/partitions[0, 1][zk: localhost:2181(CONNECTED) 7] ls /brokers/topics/first/partitions/0[state][zk: localhost:2181(CONNECTED) 8] get /brokers/topics/first/partitions/0/state&#123;&quot;controller_epoch&quot;:21,&quot;leader&quot;:0,&quot;version&quot;:1,&quot;leader_epoch&quot;:8,&quot;isr&quot;:[0]&#125;cZxid = 0x3000003e9ctime = Sun Mar 08 16:24:37 CST 2020mZxid = 0x3000005cbmtime = Sun Mar 15 18:54:09 CST 2020pZxid = 0x3000003e9cversion = 0dataVersion = 10aclVersion = 0ephemeralOwner = 0x0dataLength = 73numChildren = 0[zk: localhost:2181(CONNECTED) 9]<br></code></pre></td></tr></table></figure><p>可以看到，brokers下包括[ids, topics, seqid]，ids里面存储了存活的broker的信息，topics里面存储了kafka集群中topic的信息。同样的方法，可以查看其余节点的结构，这里不再演示。</p><p>2、节点信息（这里只列出和HA相关的部分节点）</p><p>① controller</p><p>controller节点下存放的是kafka集群中controller的信息（controller即kafka集群中所有broker的leader）。</p><p>② controller_epoch</p><p>controller_epoch用于记录controller发生变更的次数（controller宕机后会重新选举controller，这时候controller_epoch的值会+1），即记录当前的控制器是第几代控制器，用于防止broker脑裂。</p><p>③ brokes</p><p>brokers下的ids存储了存活的broker信息，topics存储了kafka集群中topic的信息，其中有一个特殊的topic：_consumer_offsets，新版本的kafka将消费者的offset就存储在__consumer_offsets下。</p><p>04</p><p>broker failover</p><p>我们了解了kafka集群中zookpeeper的结构，本文的主题是kafka的高可用分析，所以我们还是结合zookpper的结构，来分析一下，当kafka集群中的一个broker节点宕机时（非controller节点），会发生什么？</p><p>在讲之前，我们再来回顾一下brokers的结构，</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4405f61410cff44764a91cb77ec2f4d1.png" alt="Image"></p><p>※ 当非controller的broker宕机时，会执行如下操作，</p><p>1、controller会在zookeeper的 “ &#x2F;brokers&#x2F;ids&#x2F;“ 节点注册一个watcher（监视器），当有broker宕机时，zookeeper会触发监视器（fire watch）通知controller。</p><p>2、controller 从 “&#x2F;brokers&#x2F;ids” 节点读取到所有可用的broker。</p><p>3、controller会声明一个set_p集合，该集合包含了宕机broker上所有的partition。</p><p>4、针对set_p中的每一个partition，</p><p>① 从 “&#x2F;state”节点 读取该partition当前的ISR；</p><p>② 决定该partition的新leader：如果该分区的 ISR中有存活的副本，则选择其中一个作为新leader；如果该partition的ISR副本全部挂了，则选择该partition的 AR集合 中任一幸存的副本作为leader；如果该partition的所有副本都挂，则将分区的leader设为-1；</p><p>③ 将新 leader、ISR、controller_epoch 和 leader_epoch 等信息写入 state 节点；</p><p>5、通过RPC向set_p相关的broker发送LeaderAndISR Request命令。</p><p>05</p><p>controller failover</p><p>当 controller 宕机时会触发 controller failover。每个 broker 都会在 zookeeper 的 “&#x2F;controller” 节点注册 watcher（监听器），当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知，每个 broker 都尝试创建新的临时节点，只有一个会创建成功并当选为 controller。</p><p>当新的 controller 当选时，会回调KafkaController的onControllerFailover()方法，在这个方法中完成controller的初始化，controller 在初始化时，首先会利用 ZK 的 watch 机制注册很多不同类型的监听器，主要有以下几种：</p><ul><li><p>监听 &#x2F;admin&#x2F;reassign_partitions 节点，用于分区副本迁移的监听；</p></li><li><p>监听 &#x2F;isr_change_notification 节点，用于 Partition Isr 变动的监听；</p></li><li><p>监听 &#x2F;admin&#x2F;preferred_replica_election 节点，用于 Partition 最优 leader 选举的监听；</p></li><li><p>监听 &#x2F;brokers&#x2F;topics 节点，用于 topic 新建的监听；</p></li><li><p>监听 &#x2F;brokers&#x2F;topics&#x2F;TOPIC_NAME 节点，用于 Topic Partition 扩容的监听；</p></li><li><p>监听 &#x2F;admin&#x2F;delete_topics 节点，用于 topic 删除的监听；</p></li><li><p>监听 &#x2F;brokers&#x2F;ids 节点，用于 Broker 上下线的监听；</p></li></ul><p>除了注册多种监听器外，controller初始化时还做以下操作，</p><ul><li><p>initializeControllerContext()</p><p>初始化controller上下文，设置当前所有broker、topic、partition的leader、ISR等；</p></li><li><p>replicaStateMachine.startup()</p></li><li><p>partitionStateMachine.startup()</p><p>启动状态机；</p></li><li><p>brokerState.newState(RunningAsController)</p><p>将 brokerState 状态设置为 RunningAsController；</p></li><li><p>sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq)</p><p>把partition leadership信息发到所有brokers；</p></li><li><p>autoRebalanceScheduler.startup()</p><p>如果打开了autoLeaderRebalance，则启动”partition-rebalance-thread”线程；</p></li><li><p>deleteTopicManager.start()</p><p>如果delete.topic.enable&#x3D;true，且 &#x2F;admin&#x2F;delete_topics 节点下有值，则删除相应的topic；</p></li></ul><p>最后，把onControllerFailover()方法的源码贴一下，上面说的这些操作就是在这个方法中完成的，感兴趣的可以再去看下kafka源码，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">def onControllerFailover() &#123;    if (isRunning) &#123;        info(&quot;Broker %d starting become controller state transition&quot;.format(config.brokerId))        //read controller epoch from zk        readControllerEpochFromZookeeper()        // increment the controller epoch        incrementControllerEpoch(zkUtils.zkClient)        // before reading source of truth from zookeeper, register the listeners to get broker/topic callbacks        registerReassignedPartitionsListener()        registerIsrChangeNotificationListener()        registerPreferredReplicaElectionListener()        partitionStateMachine.registerListeners()        replicaStateMachine.registerListeners()        initializeControllerContext()        replicaStateMachine.startup()        partitionStateMachine.startup()        // register the partition change listeners for all existing topics on failover        controllerContext.allTopics.foreach(topic =&gt; partitionStateMachine.registerPartitionChangeListener(topic))        info(&quot;Broker %d is ready to serve as the new controller with epoch %d&quot;.format(config.brokerId, epoch))        brokerState.newState(RunningAsController)        maybeTriggerPartitionReassignment()        maybeTriggerPreferredReplicaElection()        /* send partition leadership info to all live brokers */        sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq)        if (config.autoLeaderRebalanceEnable) &#123;            info(&quot;starting the partition rebalance scheduler&quot;)            autoRebalanceScheduler.startup()            autoRebalanceScheduler.schedule(&quot;partition-rebalance-thread&quot;, checkAndTriggerPartitionRebalance,                5, config.leaderImbalanceCheckIntervalSeconds.toLong, TimeUnit.SECONDS)        &#125;        deleteTopicManager.start()    &#125;    else        info(&quot;Controller has been shut down, aborting startup/failover&quot;)&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;我们知道，kafka中每个topic被划分为多个partition，每个partition又有多个副本，那么这些分区副本是怎么均匀的分布在整个kafka集群的broker节点上的？partition副本的leader是通过什么算法选举出来的？partition副本</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>大白话 kafka 架构原理</title>
    <link href="http://example.com/2021/01/05/%E5%A4%A7%E7%99%BD%E8%AF%9D%20kafka%20%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/01/05/%E5%A4%A7%E7%99%BD%E8%AF%9D%20kafka%20%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-01-05T06:20:33.000Z</published>
    <updated>2024-01-07T10:21:13.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。"><a href="#大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。" class="headerlink" title="大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。"></a>大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netflix每天都用Kafka处理万亿级的信息。本文就让我们一起来大白话kafka的架构原理。</h3><p>kafka官网：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p><p>01</p><p>PART</p><p>kafka简介</p><p>Kafka最初由Linkedin公司开发，是一个分布式的、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常用于web&#x2F;nginx日志、访问日志、消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p><p>02</p><p>PART</p><p>kafka的特性</p><ul><li><p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒；</p></li><li><p>可扩展性：kafka集群支持热扩展；</p></li><li><p>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止丢失；</p></li><li><p>容错性：允许集群中的节点失败(若分区副本数量为n,则允许n-1个节点失败)；</p></li><li><p>高并发：单机可支持数千个客户端同时读写；</p></li></ul><p>03</p><p>PART</p><p>kafka的应用场景</p><ul><li><p>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口开放给各种消费端，例如hadoop、Hbase、Solr等。</p></li><li><p>消息系统：解耦生产者和消费者、缓存消息等。</p></li><li><p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索记录、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p></li><li><p>运营指标：Kafka也经常用来记录运营监控数据。</p></li><li><p>流式处理</p></li></ul><p>04</p><p>PART</p><p>kafka架构（重头戏!）</p><p>下面是一个kafka的架构图，</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e243ead512ce442d090f6cf29ddd3a4.png" alt="Image"></p><p>整体来看，kafka架构中包含四大组件：生产者、消费者、kafka集群、zookeeper集群。对照上面的结构图，我们先来搞清楚几个很重要的术语，（看图！对照图理解~）</p><p>1、broker</p><p>kafka 集群包含一个或多个服务器，每个服务器节点称为一个broker。</p><p>2、topic</p><p>每条发布到kafka集群的消息都有一个类别，这个类别称为topic，其实就是将消息按照topic来分类，topic就是逻辑上的分类，同一个topic的数据既可以在同一个broker上也可以在不同的broker结点上。</p><p>3、partition</p><p>分区，每个topic被物理划分为一个或多个分区，每个分区在物理上对应一个文件夹，该文件夹里面存储了这个分区的所有消息和索引文件。在创建topic时可指定parition数量，生产者将消息发送到topic时，消息会根据 分区策略 追加到分区文件的末尾，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5a5ecec9dd76ef9560625073e0cb3c8d.png" alt="Image"></p><p>上面提到了分区策略，所谓分区策略就是决定生产者将消息发送到哪个分区的算法。Kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略。kafka允许为每条消息设置一个key，一旦消息被定义了 Key，那么就可以保证同一个 Key 的所有消息都进入到相同的分区，这种策略属于自定义策略的一种，被称作”按消息key保存策略”，或Key-ordering 策略。</p><p>同一主题的多个分区可以部署在多个机器上，以此来实现 kafka 的伸缩性。同一partition中的数据是有序的，但topic下的多个partition之间在消费数据时不能保证有序性，在需要严格保证消息顺序消费的场景下，可以将partition数设为1，但这种做法的缺点是降低了吞吐，一般来说，只需要保证每个分区的有序性，再对消息设置key来保证相同key的消息落入同一分区，就可以满足绝大多数的应用。</p><p>4、offset</p><p>partition中的每条消息都被标记了一个序号，这个序号表示消息在partition中的偏移量，称为offset，每一条消息在partition都有唯一的offset，消息者通过指定offset来指定要消费的消息。</p><p>正常情况下，消费者在消费完一条消息后会递增offset，准备去消费下一条消息，但也可以将offset设成一个较小的值，重新消费一些消费过的消息，可见offset是由consumer控制的，consumer想消费哪一条消息就消费哪一条消息，所以kafka broker是无状态的，它不需要标记哪些消息被消费过。</p><p>5、producer</p><p>生产者，生产者发送消息到指定的topic下，消息再根据分配规则append到某个partition的末尾。</p><p>6、consumer</p><p>消费者，消费者从topic中消费数据。</p><p>7、consumer group</p><p>消费者组，每个consumer属于一个特定的consumer group，可为每个consumer指定consumer group，若不指定则属于默认的group。</p><p>同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。这也是kafka用来实现一个topic消息的广播和单播的手段，如果需要实现广播，一个consumer group内只放一个消费者即可，要实现单播，将所有的消费者放到同一个consumer group即可。</p><p>用consumer group还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</p><p>8、leader</p><p>每个partition有多个副本，其中有且仅有一个作为leader，leader会负责所有的客户端读写操作。</p><p>9、follower</p><p>follower不对外提供服务，只与leader保持数据同步，如果leader失效，则选举一个follower来充当新的leader。当follower与leader挂掉、卡住或者同步太慢，leader会把这个follower从ISR列表中删除，重新创建一个follower。</p><p>10、rebalance</p><p>同一个consumer group下的多个消费者互相协调消费工作，我们这样想，一个topic分为多个分区，一个consumer group里面的所有消费者合作，一起去消费所订阅的某个topic下的所有分区(每个消费者消费部分分区)，kafka会将该topic下的所有分区均匀的分配给consumer group下的每个消费者，如下图，</p><p><img src="https://img-blog.csdnimg.cn/img_convert/924db4e3900f5802bd337b0f9b08327d.png" alt="Image"></p><p>rebalance表示”重平衡”，consumer group内某个消费者挂掉后，其他消费者自动重新分配订阅主题分区的过程，是 Kafka 消费者端实现高可用的重要手段。如下图Consumer Group A中的C2挂掉，C1会接收P1和P2，以达到重新平衡。同样的，当有新消费者加入consumer group，也会触发重平衡操作。</p><p>05</p><p>PART</p><p>对kafka架构的几点解释</p><ul><li><p>一个典型的kafka集群中包含若干producer，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干consumer group，以及一个zookeeper集群。kafka通过zookeeper协调管理kafka集群，选举分区leader，以及在consumer group发生变化时进行rebalance。</p></li><li><p>kafka的topic被划分为一个或多个分区，多个分区可以分布在一个或多个broker节点上，同时为了故障容错，每个分区都会复制多个副本，分别位于不同的broker节点，这些分区副本中（不管是leader还是follower都称为分区副本），一个分区副本会作为leader，其余的分区副本作为follower。其中leader负责所有的客户端读写操作，follower不对外提供服务，仅仅从leader上同步数据，当leader出现故障时，其中的一个follower会顶替成为leader，继续对外提供服务。</p></li><li><p>对于传统的MQ而言，已经被消费的消息会从队列中删除，但在Kafka中被消费的消息也不会立马删除，在kafka的server.propertise配置文件中定义了数据的保存时间，当文件到设定的保存时间时才会删除，</p><p># 数据的保存时间(单位:小时，默认为7天)</p><p>log.retention.hours&#x3D;168</p><p>因为Kafka读取消息的时间复杂度为O(1)，与文件大小无关，所以这里删除过期文件与提高Kafka性能并没有关系，所以选择怎样的删除策略应该考虑磁盘以及具体的需求。</p></li><li><p>点对点模式 VS 发布订阅模式</p><p>传统的消息系统中，有两种主要的消息传递模式：点对点模式、发布订阅模式。</p><p>①点对点模式 </p><p>生产者发送消息到queue中，queue支持存在多个消费者，但是对一个消息而言，只可以被一个消费者消费，并且在点对点模式中，已经消费过的消息会从queue中删除不再存储。</p><p>②发布订阅模式</p><p>生产者将消息发布到topic中，topic可以被多个消费者订阅，且发布到topic的消息会被所有订阅者消费。而kafka就是一种发布订阅模式。</p></li><li><p>消费端 pull 和 push</p><p>① push方式：由消息中间件主动地将消息推送给消费者；</p><p>优点：优点是不需要消费者额外开启线程监控中间件，节省开销。</p><p>缺点：无法适应消费速率不相同的消费者。因为消息的发送速率是broker决定的，而消</p><p>费者的处理速度又不尽相同，所以容易造成部分消费者空闲，部分消费者堆积，造成缓</p><p>冲区溢出。</p><p>② pull方式：由消费者主动向消息中间件拉取消息；</p><p>优点：消费端可以按处理能力进行拉取；</p><p>缺点：消费端需要另开线程监控中间件，有性能开销；</p><p>对于Kafka而言，pull模式更合适。pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式，既可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p></li></ul><p>06</p><p>PART</p><p>kafka和rabbitMQ对比</p><table><tbody><tr><td>&nbsp;</td><td><p>RabbitMQ</p></td><td><p>Kafka</p></td></tr><tr><td><p>开发语言</p></td><td><p>erlang</p></td><td><p>scala，Java</p></td></tr><tr><td><p>架构模型</p></td><td><p>① 遵循AMQP；</p><p>② 生产者、消费者、broker。</p><p>③ broker由exchange、binding、queue组成；</p><p>④ consumer消费位置由broker通过确认机制保存；</p></td><td><p>① 不遵循AMQP；</p><p>② 生产者、消费者、kafka集群、zookeeper集群；</p><p>③ kafka集群由多个broker节点组成，消息按照topic分类，每个topic又划分为多个partition；</p><p>④ broker无状态，offset由消费者指定；</p></td></tr><tr><td><p>可靠性</p></td><td>&nbsp;</td><td><p>RabbitMQ可靠性更好，支持事务，支持消息确认机制</p></td></tr><tr><td><p>高可用</p></td><td><p>采用镜像队列，即主从模式，数据是异步同步的，当消息过来，主从全部写完后，回ack，这样保障了数据的一致性。</p></td><td><p>每个分区都有一个或多个副本，这些副本保存在不同的broker上，其中有且仅有一个分区副本作为leader，其余的作为follower，当leader不可用时，会选举follower作为新leader继续提供服务。</p><p>只有leader提供读写服务，follower从leader同步拉取数据然后备份。</p></td></tr><tr><td><p>吞吐量</p></td><td><p>kafka更高</p></td><td>&nbsp;</td></tr><tr><td><p>是否支持事务</p></td><td><p>支持</p></td><td><p>不支持</p></td></tr><tr><td><p>负载均衡</p></td><td><p>需要外部支持才能实现（如：loadbalancer）</p></td><td><p>kafka利用zk和分区机制实现负载均衡</p></td></tr><tr><td><p>是否支持消费者Push</p></td><td><p>不支持</p></td><td><p>支持</p></td></tr><tr><td><p>是否支持消费者Pull</p></td><td><p>支持</p></td><td><p>支持</p></td></tr><tr><td><p>适用场景</p></td><td><p>kafka的优势主要体现在吞吐量上，它主要用在高吞吐量的场景。比如日志采集。</p></td><td><p>具有较高的严谨性，数据丢失的可能性更小，同时具备较高的实时性，用在对实时性、可靠性要求较高的消息传递上。</p></td></tr></tbody></table><p>07</p><p>PART</p><p>kafka吞吐量为什么这么高</p><p>1、顺序读写磁盘</p><p>Kafka是将消息持久化到本地磁盘中的，一般人会认为磁盘读写性能差，可能会对Kafka性能提出质疑。实际上不管是内存还是磁盘，快或慢的关键在于寻址方式，磁盘分为顺序读写与随机读写，内存一样也分为顺序读写与随机读写。基于磁盘的随机读写确实很慢，但基于磁盘的顺序读写性能却很高，一般而言要高出磁盘的随机读写三个数量级，一些情况下磁盘顺序读写性能甚至要高于内存随机读写，这里贴一张著名学术期刊 ACM Queue 上的一张性能对比图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/47f98458333eaae12442f549893fe730.png" alt="Image"></p><p>2、page cache</p><p>为了优化读写性能，Kafka利用了操作系统本身的Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。这样做是因为，</p><p>&gt; JVM中一切皆对象，对象的存储会带来额外的内存消耗；</p><p>&gt; 使用JVM会受到GC的影响，随着数据的增多，垃圾回收也会变得复杂与缓慢，降低吞吐量；</p><p>另外操作系统本身对page cache做了大量优化，通过操作系统的Page Cache，Kafka的读写操作基本上是基于系统内存的，读写性能也得到了极大的提升。</p><p>3、零拷贝</p><p>零拷贝是指Kafka利用 linux 操作系统的 “zero-copy” 机制在消费端做的优化。首先来看一下消费端在消费数据时，数据从broker磁盘通过网络传输到消费端的整个过程：</p><p>&gt; 操作系统从磁盘读取数据到内核空间（kernel space）的page cache；</p><p>&gt; 应用程序读取page cache的数据到用户空间（user space）的缓冲区；</p><p>&gt; 应用程序将用户空间缓冲区的数据写回内核空间的socket缓冲区（socket buffer）；</p><p>&gt; 操作系统将数据从socket缓冲区复制到硬件（如网卡）缓冲区；</p><p><img src="https://img-blog.csdnimg.cn/img_convert/213fe78a0275018b10c86ea46bbf8b08.png" alt="Image"></p><p>整个过程如上图所示，这个过程包含4次copy操作和2次系统上下文切换，而上下文切换是CPU密集型的工作，数据拷贝是I&#x2F;O密集型的工作，性能其实非常低效。</p><p>零拷贝就是使用了一个名为sendfile()的系统调用方法，将数据从page cache直接发送到Socket缓冲区，避免了系统上下文的切换，消除了从内核空间到用户空间的来回复制。从上图可以看出，”零拷贝”并不是说整个过程完全不发生拷贝，而是站在内核的角度来说的，避免了内核空间到用户空间的来回拷贝。</p><p>4、分区分段</p><p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。这也非常符合分布式系统分区分桶的设计思想。</p><p>通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p><p>总之，Kafka采用顺序读写、Page Cache、零拷贝以及分区分段等这些设计，再加上在索引方面做的优化，另外Kafka数据读写也是批量的而不是单条的，使得Kafka具有了高性能、高吞吐、低延时的特点。</p><p>Scan to Follow</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;大数据时代来临，如果你还不知道Kafka那就真的out了！据统计，有三分之一的世界财富500强企业正在使用Kafka，包括所有TOP10旅游公司，7家TOP10银行，8家TOP10保险公司，9家TOP10电信公司等等。LinkedIn、Microsoft和Netf</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash算法详解</title>
    <link href="http://example.com/2020/12/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2020/12/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-12-08T08:04:09.000Z</published>
    <updated>2024-01-07T14:12:30.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一致性hash算法详解"><a href="#一致性hash算法详解" class="headerlink" title="一致性hash算法详解"></a>一致性hash算法详解</h2><p>最新推荐文章于 2024-01-06 13:51:23 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-06 13:51:23 发布</p><p>目前正在维护公司的分布式任务调度平台，在任务节点的分配上使用到了一致性hash算法，特此记录，那么在后面的博文中会给出基于java实现的一致性hash算法的代码，以及分布式调度平台的一些设计思路。</p><h3 id="1-hash算法"><a href="#1-hash算法" class="headerlink" title="1.hash算法"></a>1.hash算法</h3><p>那么什么是hash算法呢，百度百科的定义如下：</p><p>哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。</p><p><strong>普通的hash算法在分布式应用中的不足：</strong></p><p><strong>比如，在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。</strong></p><p>接下来我们来了解，一致性hash算法是怎么解决这个问题的。</p><h3 id="2-一致性hash算法"><a href="#2-一致性hash算法" class="headerlink" title="2.一致性hash算法"></a>2.一致性hash算法</h3><p>一致性哈希提出了在动态变化的Cache环境中，哈希算法应该满足的4个适应条件(from 百度百科)：</p><h4 id="均衡性-Balance"><a href="#均衡性-Balance" class="headerlink" title="均衡性(Balance)"></a>均衡性(Balance)</h4><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><h4 id="单调性-Monotonicity"><a href="#单调性-Monotonicity" class="headerlink" title="单调性(Monotonicity)"></a>单调性(Monotonicity)</h4><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。（这段翻译信息有负面价值的，当缓冲区大小变化时一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区。）</p><h4 id="分散性-Spread"><a href="#分散性-Spread" class="headerlink" title="分散性(Spread)"></a>分散性(Spread)</h4><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p><h4 id="负载-Load"><a href="#负载-Load" class="headerlink" title="负载(Load)"></a>负载(Load)</h4><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p><p>接下来说一下具体的设计：</p><h4 id="2-1环形hash空间"><a href="#2-1环形hash空间" class="headerlink" title="2.1环形hash空间"></a>2.1环形hash空间</h4><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。</p><p><strong>NOTE:<strong>当然，节点的个数可以自定义，</strong>整个hash环我们可以用TreeMap来实现，因为treeMap是排序的，我们刚好可以利用上</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e116caac05ee8718ae499652d5371c16.png"></p><h4 id="2-2映射服务器节点"><a href="#2-2映射服务器节点" class="headerlink" title="2.2映射服务器节点"></a>2.2映射服务器节点</h4><p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假设我们将四台服务器使用ip地址哈希后在环空间的位置如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/77247578bc606dcd10613d8ea8f2b9e4.png"></p><h4 id="2-3映射数据"><a href="#2-3映射数据" class="headerlink" title="2.3映射数据"></a>2.3映射数据</h4><p>现在我们将objectA、objectB、objectC、objectD四个对象通过特定的Hash函数计算出对应的key值，<strong>然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e73adab0e5d0b65b5798337cc1045b9e.png"></p><h4 id="2-4服务器的删除与添加"><a href="#2-4服务器的删除与添加" class="headerlink" title="2.4服务器的删除与添加"></a>2.4服务器的删除与添加</h4><p><strong>2.4.1如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化</strong></p><p><strong>2.4.2如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c5c5780cb28e08f36dae84bc4ce9c758.png"></p><h4 id="2-5-虚拟节点"><a href="#2-5-虚拟节点" class="headerlink" title="2.5.虚拟节点"></a>2.5.虚拟节点</h4><p>到目前为止一致性hash也可以算做完成了，但是有一个问题还需要解决，那就是<strong>平衡性</strong>。从下图我们可以看出，当服务器节点比较少的时候，<strong>会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/97cdd5bc93cabecf2241caa6a048f17e.png"></p><p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/551d603b3eb2619933d57dce7a14b4bf.png"></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。<strong>这样就解决了服务节点少时数据倾斜的问题。每个物理节点关联的虚拟节点数量就根据具体的生产环境情况在确定。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一致性hash算法详解&quot;&gt;&lt;a href=&quot;#一致性hash算法详解&quot; class=&quot;headerlink&quot; title=&quot;一致性hash算法详解&quot;&gt;&lt;/a&gt;一致性hash算法详解&lt;/h2&gt;&lt;p&gt;最新推荐文章于 2024-01-06 13:51:23 发布&lt;/p&gt;</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器介绍以及布隆过滤器的实现</title>
    <link href="http://example.com/2020/12/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2020/12/04/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-12-04T03:17:50.000Z</published>
    <updated>2024-01-07T10:21:05.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器介绍以及布隆过滤器的实现"><a href="#布隆过滤器介绍以及布隆过滤器的实现" class="headerlink" title="布隆过滤器介绍以及布隆过滤器的实现"></a>布隆过滤器介绍以及布隆过滤器的实现</h2><p>最新推荐文章于 2023-07-26 00:15:00 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-07-26 00:15:00 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h3 id="一·简介"><a href="#一·简介" class="headerlink" title="一·简介"></a><strong>一·简介</strong></h3><p>       布隆过滤器（Bloom Filter）实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p><h3 id="二·原理"><a href="#二·原理" class="headerlink" title="二·原理"></a><strong>二·原理</strong></h3><p>1·刚开始是一个全部位为0的 bit 向量或者说 bit 数组</p><p>2.往过滤器增加”Bloom”</p><p><img src="https://img-blog.csdnimg.cn/20201204111442414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160113831-543587792.png?version=1&modificationDate=1606372166000&api=v2"></p><p>3.往过滤器增加”Filter”</p><p><img src="https://img-blog.csdnimg.cn/20201204111519559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160126506-1020676650.png?version=1&modificationDate=1606372198000&api=v2"></p><p>4.在过滤器中查询“Hash”，5的位置是0，说明“Hash”一定不存在</p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160139140-362048813.png?version=1&modificationDate=1606372206000&api=v2"></p><p><img src="https://img-blog.csdnimg.cn/20201204111611969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>5.可能存在误判情况（布隆过滤器可能会误判，如果它说不存在那肯定不存在，如果它说存在，那数据有可能实际不存在；）</p><p><img src="https://img-blog.csdnimg.cn/20201204111645641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><img src="http://confluence.admin.bluemoon.com.cn/download/attachments/39753387/1652302-20200510160155384-464445682.png?version=1&modificationDate=1606372206000&api=v2"></p><p>Redis的bitmap 支持2^32大小，对应到内存也就是512MB，误判率万分之一，可以放下2亿左右的数据，性能高，空间占用率及小，省去了大量无效的数据库连接。</p><h3 id="三·使用场景"><a href="#三·使用场景" class="headerlink" title="三·使用场景"></a><strong>三·使用场景</strong></h3><ul><li><strong>防止缓存穿透</strong></li><li><strong>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</strong></li><li><strong>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</strong></li><li><strong>Google Chrome 使用布隆过滤器识别恶意 URL；</strong></li><li><strong>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</strong></li><li><strong>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。</strong></li></ul><h3 id="四·实战使用"><a href="#四·实战使用" class="headerlink" title="四·实战使用"></a><strong>四·实战使用</strong></h3><h4 id="1-Java-Guava实现"><a href="#1-Java-Guava实现" class="headerlink" title="1.Java Guava实现"></a><strong>1.Java Guava实现</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>19.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-11-26 11:31:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterTest</span> &#123;<br>    <span class="hljs-comment">//预计要插入多少数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><br>    <span class="hljs-comment">//期望的误判率</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.001</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//插入数据 1-1000000</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000000</span>; i++) &#123;<br>            bloomFilter.put(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断 1000001-2000000 因为肯定是不存在的，所以如果是true的话那肯定就是误判</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000001</span>; i &lt;= <span class="hljs-number">2000000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bloomFilter.mightContain(i)) &#123;<br>                count++;<br>                System.out.println(i + <span class="hljs-string">&quot;误判了&quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;一共的误判数:&quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以查看输出结果并计算得知误判率994&#x2F;1000000&#x3D;0.000994 跟期望误判率大致相等</p><p><img src="https://img-blog.csdnimg.cn/20201204114608959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="2-Redis实现"><a href="#2-Redis实现" class="headerlink" title="2.Redis实现"></a>2.Redis实现</h4><p>1、安装Redis官方插件 RedisBloom并在Redis配置文件中添加插件</p><p><a href="https://github.com/RedisLabsModules/redisbloom/"><em>https://github.com/RedisLabsModules/redisbloom/</em></a></p><p>[root@redis]# vim redis.conf</p><p>#####################MODULES####################                                                                                                                      </p><p># Load modules at startup. If the server is not able to load modules<br># it will abort. It is possible to use multiple loadmodule directives.<br>loadmodule &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redisbloom-1.1.1&#x2F;<a href="http://rebloom.so/">rebloom.so</a></p><p>2、使用布隆过滤</p><p>  增加到布隆过滤器</p><p>  bf.add myfilter  123</p><p>从布隆过滤器中查询，判断是否存在</p><p>  bf.exists myfilter  123   #返回  1 ，说明可能存在值</p><p>  bf.exists myfilter  321   #返回  0， 说明不存在该值</p><p>3、准确率</p><p>  Redis中有一个命令可以来设置布隆过滤器的准确率：</p><p>  bf.reserve myfilter  0.01 100</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;布隆过滤器介绍以及布隆过滤器的实现&quot;&gt;&lt;a href=&quot;#布隆过滤器介绍以及布隆过滤器的实现&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器介绍以及布隆过滤器的实现&quot;&gt;&lt;/a&gt;布隆过滤器介绍以及布隆过滤器的实现&lt;/h2&gt;&lt;p&gt;最新推荐文章于 20</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="原创" scheme="http://example.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>动态修改LOGGER级别—— Arthas</title>
    <link href="http://example.com/2020/12/04/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9LOGGER%E7%BA%A7%E5%88%AB%E2%80%94%E2%80%94%20Arthas/"/>
    <id>http://example.com/2020/12/04/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9LOGGER%E7%BA%A7%E5%88%AB%E2%80%94%E2%80%94%20Arthas/</id>
    <published>2020-12-04T03:09:50.000Z</published>
    <updated>2024-01-07T14:12:42.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态修改LOGGER级别——-Arthas"><a href="#动态修改LOGGER级别——-Arthas" class="headerlink" title="动态修改LOGGER级别—— Arthas"></a>动态修改LOGGER级别—— Arthas</h2><p>最新推荐文章于 2023-05-30 13:48:41 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-05-30 13:48:41 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h3 id="一·背景"><a href="#一·背景" class="headerlink" title="一·背景"></a><strong>一·背景</strong></h3><p>记得前阵子，我在工作中就遇到过一个生产环境数据的排查，但是大多数情况下，我们的项目在部署的时候就已经定义了LOGGER级别，用来控制输出的信息范围。</p><p>一般生产环境上我们的日志级别会设置成info级别因为，过多的输出会影响输出和查看日志的效率，另一方面，过少的日志让问题定位变得困难。</p><p>所以当生产出现问题时，线上容器通常定义在info级别，发生一些疑难问题时，光靠info级别的日志很难定位问题。</p><h3 id="二·Arthas介绍"><a href="#二·Arthas介绍" class="headerlink" title="二·Arthas介绍"></a><strong>二·Arthas介绍</strong></h3><p>Arthas是阿里开源的Java诊断工具。</p><p><img src="https://img-blog.csdnimg.cn/2020120411055538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>官方网站：<a href="https://arthas.aliyun.com/zh-cn/">https://arthas.aliyun.com/zh-cn/</a></p><h3 id="三·如何使用-Arthas进行日志级别动态修改"><a href="#三·如何使用-Arthas进行日志级别动态修改" class="headerlink" title="三·如何使用****Arthas进行日志级别动态修改"></a><strong>三·如何使用****Arthas进行日志级别动态修改</strong></h3><h4 id="1-下载并运行Arthas"><a href="#1-下载并运行Arthas" class="headerlink" title="1.下载并运行Arthas"></a><strong>1.下载并运行Arthas</strong></h4><p><strong>java -jar arthas-boot.jar</strong></p><p><img src="https://img-blog.csdnimg.cn/20201204110722314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="2-选取要查看的java应用，输入编号"><a href="#2-选取要查看的java应用，输入编号" class="headerlink" title="2.选取要查看的java应用，输入编号"></a><strong>2.选取要查看的java应用，输入编号</strong></h4><p><img src="https://img-blog.csdnimg.cn/20201204110749784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="3-运行logger命令查看应用当前日志级别"><a href="#3-运行logger命令查看应用当前日志级别" class="headerlink" title="3.运行logger命令查看应用当前日志级别"></a><strong>3.运行logger命令查看应用当前日志级别</strong></h4><p><img src="https://img-blog.csdnimg.cn/20201204110811304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="4-logger-–name-ROOT-–level-info-把ROOT的日志级别修改为info"><a href="#4-logger-–name-ROOT-–level-info-把ROOT的日志级别修改为info" class="headerlink" title="4.logger –name ROOT –level info 把ROOT的日志级别修改为info"></a>4.logger –name ROOT –level info 把ROOT的日志级别修改为info</h4><p><img src="https://img-blog.csdnimg.cn/2020120411092018.png"></p><h4 id="5-logger-–name-ROOT-–level-debug-记得排查完以后把日志级别修改回debug"><a href="#5-logger-–name-ROOT-–level-debug-记得排查完以后把日志级别修改回debug" class="headerlink" title="5.logger –name ROOT –level debug 记得排查完以后把日志级别修改回debug"></a>5.logger –name ROOT –level debug 记得排查完以后把日志级别修改回debug</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态修改LOGGER级别——-Arthas&quot;&gt;&lt;a href=&quot;#动态修改LOGGER级别——-Arthas&quot; class=&quot;headerlink&quot; title=&quot;动态修改LOGGER级别—— Arthas&quot;&gt;&lt;/a&gt;动态修改LOGGER级别—— Arthas&lt;/</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="原创" scheme="http://example.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java实现一次遍历单链表删除指定节点 剑指Offer18</title>
    <link href="http://example.com/2020/11/18/Java%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%20%E5%89%91%E6%8C%87Offer18/"/>
    <id>http://example.com/2020/11/18/Java%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%20%E5%89%91%E6%8C%87Offer18/</id>
    <published>2020-11-18T08:11:03.000Z</published>
    <updated>2024-01-07T10:21:10.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java实现一次遍历单链表删除指定节点-剑指Offer18"><a href="#Java实现一次遍历单链表删除指定节点-剑指Offer18" class="headerlink" title="Java实现一次遍历单链表删除指定节点 剑指Offer18"></a>Java实现一次遍历单链表删除指定节点 剑指Offer18</h2><p>最新推荐文章于 2024-01-03 17:56:19 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p>置顶 <a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-03 17:56:19 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>今天刷leetcode的时候做到了一条单链表的经典题目，我做的题解运行速度和所占空间都不错所以分享给大家一下我的题解和思路。</p><p>循例先上一下题目和运行结果：</p><p><strong>题目：</strong></p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.   </p><p>说明：</p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>运行结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201118160534840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><strong>题解思路：</strong></p><p><strong>首先处理头节点的两种特殊情况1.头节点为空 2.头节点就是要删除的节点</strong></p><p><strong>然后创建两个引用记录现在“位置” 和 前一个listNode的位置</strong></p><p><strong>必须要记录上一个listnode的“位置” 否则无法一次遍历就删除</strong></p><p><strong>遍历判断相等是否相等 并 移动两个引用到下一个listnode</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sword18</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword18</span>().test();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">9</span>);<br>        node4.next = node5;<br>        node5.next = node1;<br>        node1.next = node9;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword18</span>().deleteNode(node4, <span class="hljs-number">5</span>));<br>    &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">//处理头节点的两种特殊情况</span><br>        <span class="hljs-comment">//1.头节点为空</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.头节点就是要删除的节点</span><br>        <span class="hljs-keyword">if</span>(head.val==val)&#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<br>        <span class="hljs-comment">//当前位置的ListNode引用</span><br>        ListNode now;<br>        <span class="hljs-comment">//上一个位置的ListNode引用</span><br>        ListNode pre;<br>        now = head.next;<br>        pre = head;<br>        <span class="hljs-keyword">while</span>(now!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(now.val==val)&#123;<br>                <span class="hljs-comment">//删除</span><br>                pre.next = now.next;<br>            &#125;<br>            <span class="hljs-comment">//两个引用移动到下一个位置</span><br>            now = now.next;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode(<span class="hljs-type">int</span> x) &#123;<br>            val = x;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ListNode&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;val=&quot;</span> + val +<br>                    <span class="hljs-string">&quot;, next=&quot;</span> + next +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java实现一次遍历单链表删除指定节点-剑指Offer18&quot;&gt;&lt;a href=&quot;#Java实现一次遍历单链表删除指定节点-剑指Offer18&quot; class=&quot;headerlink&quot; title=&quot;Java实现一次遍历单链表删除指定节点 剑指Offer18&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="原创" scheme="http://example.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 05 替换空格 ，用时0ms，超过100%用户的Java解法</title>
    <link href="http://example.com/2020/11/12/%E5%89%91%E6%8C%87%20Offer%2005%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%20%EF%BC%8C%E7%94%A8%E6%97%B60ms%EF%BC%8C%E8%B6%85%E8%BF%87100%%E7%94%A8%E6%88%B7%E7%9A%84Java%E8%A7%A3%E6%B3%95/"/>
    <id>http://example.com/2020/11/12/%E5%89%91%E6%8C%87%20Offer%2005%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%20%EF%BC%8C%E7%94%A8%E6%97%B60ms%EF%BC%8C%E8%B6%85%E8%BF%87100%%E7%94%A8%E6%88%B7%E7%9A%84Java%E8%A7%A3%E6%B3%95/</id>
    <published>2020-11-12T11:36:51.000Z</published>
    <updated>2024-01-07T14:12:27.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-05-替换空格-，用时0ms，超过100-用户的Java解法"><a href="#剑指-Offer-05-替换空格-，用时0ms，超过100-用户的Java解法" class="headerlink" title="剑指 Offer 05 替换空格 ，用时0ms，超过100%用户的Java解法"></a>剑指 Offer 05 替换空格 ，用时0ms，超过100%用户的Java解法</h2><p>最新推荐文章于 2024-01-06 14:29:50 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-06 14:29:50 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p><strong>题目：</strong></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”   </p><p>限制：</p><p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>然后再上一下我的提交结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201112193057780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p><strong>我的解题思路：</strong></p><h3 id="1-首先遍历记录下空格字符的数目，原字符数组大小-空格字符的数目-（替换后的字符串-1）得出新数组的大小"><a href="#1-首先遍历记录下空格字符的数目，原字符数组大小-空格字符的数目-（替换后的字符串-1）得出新数组的大小" class="headerlink" title="1.首先遍历记录下空格字符的数目，原字符数组大小+空格字符的数目*（替换后的字符串-1）得出新数组的大小"></a>1.首先遍历记录下空格字符的数目，原字符数组大小+空格字符的数目*（替换后的字符串-1）得出新数组的大小</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>2.遍历字符串的原字符数组遇到空格字符的话  新数组i位置以及后面的元素为 %20还有 修改i的位置 直至遍历完成</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>3.最后返回新数组组成的字符串</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;剑指-Offer-05-替换空格-，用时0ms，超过100-用户的Java解法&quot;&gt;&lt;a href=&quot;#剑指-Offer-05-替换空格-，用时0ms，超过100-用户的Java解法&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 05 替换</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="原创" scheme="http://example.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java的快速失败与安全失败与遍历修改</title>
    <link href="http://example.com/2020/10/21/Java%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5%E4%B8%8E%E9%81%8D%E5%8E%86%E4%BF%AE%E6%94%B9/"/>
    <id>http://example.com/2020/10/21/Java%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5%E4%B8%8E%E9%81%8D%E5%8E%86%E4%BF%AE%E6%94%B9/</id>
    <published>2020-10-21T02:48:43.000Z</published>
    <updated>2024-01-07T14:12:44.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的快速失败与安全失败与遍历修改"><a href="#Java的快速失败与安全失败与遍历修改" class="headerlink" title="Java的快速失败与安全失败与遍历修改"></a>Java的快速失败与安全失败与遍历修改</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 于 2020-10-21 10:48:43 发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><h4 id="一、快速失败（fail—fast）"><a href="#一、快速失败（fail—fast）" class="headerlink" title="一、快速失败（fail—fast）"></a>一、快速失败（fail—fast）</h4><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。</p><p><strong>原理：</strong>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()&#x2F;next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>注意：</strong>这里异常的抛出条件是检测到 <strong>modCount !&#x3D; expectedmodCount</strong> 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。</p><p><strong>场景：</strong>java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><p><strong>方法1:</strong></p><p>在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码：</p><p><strong>方法2:</strong></p><p>使用java并发包(java.util.concurrent)中的类来代替 ArrayList 和hashMap。</p><p>比如使用 CopyOnWriterArrayList代替 ArrayList， CopyOnWriterArrayList在是使用上跟 ArrayList几乎一样， CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于 CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。</p><p>对于HashMap，可以使用ConcurrentHashMap， ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生fail-fast，但不保证获取的是最新的数据。</p><h4 id="二、安全失败（fail—safe）"><a href="#二、安全失败（fail—safe）" class="headerlink" title="二、安全失败（fail—safe）"></a>二、安全失败（fail—safe）</h4><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p><strong>原理：</strong>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</p><p>&gt;缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p><strong>场景：</strong>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><p>参考自：<a href="https://www.runoob.com/w3cnote/java-fail-ast-fail-safe.html">https://www.runoob.com/w3cnote/java-fail-ast-fail-safe.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java的快速失败与安全失败与遍历修改&quot;&gt;&lt;a href=&quot;#Java的快速失败与安全失败与遍历修改&quot; class=&quot;headerlink&quot; title=&quot;Java的快速失败与安全失败与遍历修改&quot;&gt;&lt;/a&gt;Java的快速失败与安全失败与遍历修改&lt;/h2&gt;&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="原创" scheme="http://example.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>记一次阿里巴巴面试的经历</title>
    <link href="http://example.com/2020/08/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://example.com/2020/08/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%9A%84%E7%BB%8F%E5%8E%86/</id>
    <published>2020-08-20T12:32:17.000Z</published>
    <updated>2024-01-07T10:21:19.282Z</updated>
    
    <content type="html"><![CDATA[<p>       今天我下班的时候接到了昨晚阿里巴巴面试我的技术面试官的电话，他问我昨晚的编程题是提交了全部的代码吗，我那时候正在地铁刚下班也有点迷糊，而且我想着昨晚的题也基本完成了90%应该没问题，于是我就说了：”应该是的“，然后说了一些昨晚没全部完成的理由。后面我们的通话就结束了，但是当我挂了以后我就十分后悔，我感觉这很有可能是面试官给我的最后一个机会，我想回拨回去，可是奈何这是虚拟电话，根本没有用。于是回到家中我十分懊恼，也用了一会就把昨晚的题完全做出来了，可是当我打开邮箱的时候却收到这样一封邮件：<img src="https://img-blog.csdnimg.cn/20200820201307994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><p>瞬间，我觉得这可能是我离阿里最远但是又是最近的一次，最近是因为从8.11日我收到了阿里的简历内推成功进入面试的通知，我很兴奋而且我感觉前面回答面试官的技术问题都回答的不错的，编程题也基本做出来了，最远又是因为这个结果已经很明确了——FAILED！后面我实在忍不住哭了，向我女朋友倾诉了，其实我这么想进去大厂，很大的一个缘故也是因为想快点赚多点钱跟她买房子，娶她。</p><p>        写到这里，我心情稍微平复，我告诉自己我得振作，总结经验：这次我感觉主要就是我的心态问题。面对阿里这样的大厂我不应该抱着完成90%就可以的心态，90%就是相当于没完成，昨晚到今天时间这么长我就应该抽出时间100%完成，这样说不定还有机会进入下一步，今天我在这里记录这个经历就当给自己的一个激励，后面我必须继续提升自己，严谨的做事，最后奉上我完成的代码和刚刚输出的符合面试官的编程题要求的输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.way.test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-19 19:40:59</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wayleung/work/test.txt&quot;</span>);<br>        List&lt;Tree&gt; list = parseFile(file);<br>        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> buildTree(list);<br><span class="hljs-comment">//        System.out.println(tree);</span><br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;平谷区&quot;</span>, <span class="hljs-literal">null</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;天河区&quot;</span>, <span class="hljs-literal">null</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;天河区&quot;</span>, <span class="hljs-string">&quot;武强县&quot;</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;河北省&quot;</span>, <span class="hljs-string">&quot;衡水市&quot;</span>, <span class="hljs-string">&quot;武强县&quot;</span>));<br>        System.out.println(isValid(tree, <span class="hljs-string">&quot;河北省&quot;</span>, <span class="hljs-string">&quot;衡水市&quot;</span>, <span class="hljs-string">&quot;武强县1&quot;</span>));<br>        System.out.println(isValid(tree, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>));<br><span class="hljs-comment">//        System.out.println();</span><br>        printTree(tree);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Tree&gt; <span class="hljs-title function_">parseFile</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;Tree&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        BufferedReader br= <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(read);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> parseString(line);<br>                result.add(tree);<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            br.close();<br>            read.close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析每行字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">parseString</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>();<br>        String[] split = str.split(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">if</span>(split.length&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">parentStr</span> <span class="hljs-operator">=</span> split[<span class="hljs-number">0</span>];<br>            String[] parentStrArray = parentStr.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-keyword">if</span>(parentStrArray.length&gt;<span class="hljs-number">0</span>)&#123;<br>                tree.setParent(Integer.valueOf(parentStrArray[<span class="hljs-number">0</span>]));<br>                tree.setParentArea(parentStrArray[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">childStr</span> <span class="hljs-operator">=</span> split[<span class="hljs-number">1</span>];<br>            String[] childStrArray = childStr.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-keyword">if</span>(childStrArray.length&gt;<span class="hljs-number">0</span>)&#123;<br>                tree.setData(Integer.valueOf(childStrArray[<span class="hljs-number">0</span>]));<br>                tree.setArea(childStrArray[<span class="hljs-number">1</span>]);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> tree;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">buildTree</span><span class="hljs-params">(List&lt;Tree&gt; trees)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * groupingby 二级code 获取一个已经groupby的 二级-三级关系的map</span><br><span class="hljs-comment">         */</span><br>        Map&lt;Integer, List&lt;Tree&gt;&gt; tempChildrenMap = sortMap(trees.stream().filter(tree -&gt; tree.getParent() != <span class="hljs-number">0</span>).sorted(Comparator.comparing(Tree::getData)).collect(Collectors.groupingBy(tree -&gt; tree.getParent())));<br>        <span class="hljs-comment">//todo 可优化</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取map key所有二级关系的code</span><br><span class="hljs-comment">         */</span><br>        Set&lt;Integer&gt; keys = tempChildrenMap.keySet();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * key所有二级关系的code构建一级-二级关系 零级-一级关系的Tree 其实应该先构建了Tree的List再转map</span><br><span class="hljs-comment">         */</span><br>        List&lt;Tree&gt; allTrees = getSecondAndOne(keys,trees);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * groupingby 二级code 获取一个已经groupby的 二级-三级关系的map 完整数据</span><br><span class="hljs-comment">         */</span><br>        Map&lt;Integer, List&lt;Tree&gt;&gt; childrenMap = sortMap(allTrees.stream().filter(tree -&gt; tree.getParent() != <span class="hljs-number">0</span>).sorted(Comparator.comparing(Tree::getData)).collect(Collectors.groupingBy(tree -&gt; tree.getParent())));<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历 把所有的节点的children都关联上 引用类型 自然会一一关联</span><br><span class="hljs-comment">         */</span><br>        allTrees.forEach(tree -&gt; tree.setChildren(childrenMap.get(tree.getData())));<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 最后获取根节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> allTrees.stream().filter(tree -&gt; tree.getParent() == <span class="hljs-number">0</span>).collect(Collectors.toList()).get(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title function_">sortMap</span><span class="hljs-params">(Map&lt;Integer, List&lt;Tree&gt;&gt; childrenMap)</span> &#123;<br>        <span class="hljs-keyword">return</span> childrenMap.entrySet().stream()<br>                .sorted(Map.Entry.comparingByKey())<br>                .collect(<br>                        Collectors.toMap(<br>                                Map.Entry::getKey,<br>                                Map.Entry::getValue,<br>                                (oldVal, newVal) -&gt; oldVal,<br>                                LinkedHashMap::<span class="hljs-keyword">new</span><br>                        )<br>                );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * key为二层节点 构建一二层节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Tree&gt; <span class="hljs-title function_">getSecondAndOne</span><span class="hljs-params">(Set&lt;Integer&gt; keys,List&lt;Tree&gt; trees)</span>&#123;<br>        keys.forEach(key-&gt;&#123;<br>            <span class="hljs-type">Tree</span> <span class="hljs-variable">tempTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>();<br>            tempTree.setParent(<span class="hljs-number">1</span>);<br>            tempTree.setData(key);<br>            <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> getTree(trees, key);<br>            tempTree.setArea(tree.getParentArea());<br>            trees.add(tempTree);<br>        &#125;);<br>        trees.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;中国&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>));<br>        <span class="hljs-keyword">return</span> trees;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据data查找对应Tree</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">getTree</span><span class="hljs-params">(List&lt;Tree&gt; trees, Integer data)</span>&#123;<br>        <span class="hljs-keyword">for</span>(Tree tree:trees) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">dataTemp</span> <span class="hljs-operator">=</span> tree.getParent();<br>            <span class="hljs-keyword">if</span>(dataTemp.equals(data))&#123;<br>                <span class="hljs-keyword">return</span> tree;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Integer, List&lt;Tree&gt;&gt; <span class="hljs-title function_">buildTreeMap</span><span class="hljs-params">(List&lt;Tree&gt; trees)</span> &#123;<br>        <span class="hljs-keyword">return</span> trees.stream().filter(tree -&gt; tree.getParent() != <span class="hljs-number">1</span>).collect(Collectors.groupingBy(tree -&gt; tree.getParent()));<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否有孩子节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHasChild</span><span class="hljs-params">(Tree tree)</span>&#123;<br>        <span class="hljs-keyword">if</span>(tree.getChildren()!=<span class="hljs-literal">null</span>&amp;&amp;tree.getChildren().size()&gt;<span class="hljs-number">0</span>&amp;&amp;tree.getChildren().get(<span class="hljs-number">0</span>).getData()!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 集合是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(List list)</span>&#123;<br>        <span class="hljs-keyword">if</span>(list!=<span class="hljs-literal">null</span>&amp;&amp;list.size()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断地址是否合法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lv1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lv2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lv3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(Tree tree,String lv1,String lv2,String lv3)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!isHasChild(tree))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(lv1!=<span class="hljs-literal">null</span>&amp;&amp;!lv1.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>                List&lt;Tree&gt; children = tree.getChildren();<br>                <span class="hljs-type">Tree</span> <span class="hljs-variable">tree1</span> <span class="hljs-operator">=</span> ifHasData(children, lv1);<br>                <span class="hljs-keyword">if</span>(tree1!=<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(lv2!=<span class="hljs-literal">null</span>&amp;&amp;!lv2.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>                        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree2</span> <span class="hljs-operator">=</span> ifHasData(tree1.getChildren(), lv2);<br>                        <span class="hljs-keyword">if</span>(tree2!=<span class="hljs-literal">null</span>)&#123;<br>                            <span class="hljs-keyword">if</span>(lv3!=<span class="hljs-literal">null</span>&amp;&amp;!lv3.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>                                <span class="hljs-type">Tree</span> <span class="hljs-variable">tree3</span> <span class="hljs-operator">=</span> ifHasData(tree2.getChildren(), lv3);<br>                                <span class="hljs-keyword">if</span>(tree3!=<span class="hljs-literal">null</span>)&#123;<br>                                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                                &#125;<span class="hljs-keyword">else</span>&#123;<br>                                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;<span class="hljs-keyword">else</span>&#123;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 寻找是否有该节点 有的话返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trees</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> area</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title function_">ifHasData</span><span class="hljs-params">(List&lt;Tree&gt; trees,String area)</span>&#123;<br>        <span class="hljs-keyword">for</span>(Tree tree:trees)&#123;<br>            <span class="hljs-keyword">if</span>(tree.getArea().equals(area))&#123;<br>                <span class="hljs-keyword">return</span> tree;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">lv</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">(Tree tree)</span>&#123;<br>        <span class="hljs-keyword">if</span>(tree!=<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(printBlank(lv)+<span class="hljs-string">&quot;-&quot;</span> + tree.getData() + <span class="hljs-string">&quot;:&quot;</span> + tree.getArea());<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isHasChild(tree))&#123;<br>            lv++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tree.getChildren().size(); i++) &#123;<br>                printTree(tree.getChildren().get(i));<br>            &#125;<br>            lv--;<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">printBlank</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">blank</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            blank = blank+<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> blank;<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 地区树实体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span>&#123;<br>    <span class="hljs-keyword">private</span> Integer parent;<br>    <span class="hljs-keyword">private</span> Integer data;<br>    <span class="hljs-keyword">private</span> String area;<br>    <span class="hljs-keyword">private</span> String parentArea;<br>    <span class="hljs-keyword">private</span> List&lt;Tree&gt; children;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getParentArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> parentArea;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParentArea</span><span class="hljs-params">(String parentArea)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parentArea = parentArea;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArea</span><span class="hljs-params">(String area)</span> &#123;<br>        <span class="hljs-built_in">this</span>.area = area;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">(Integer parent, Integer data, List&lt;Tree&gt; children)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.children = children;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">(Integer parent, Integer data,String area,String parentArea, List&lt;Tree&gt; children)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>        <span class="hljs-built_in">this</span>.parentArea = parentArea;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.children = children;<br>        <span class="hljs-built_in">this</span>.area = area;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> parent;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(Integer parent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Tree&gt; <span class="hljs-title function_">getChildren</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> children;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setChildren</span><span class="hljs-params">(List&lt;Tree&gt; children)</span> &#123;<br>        <span class="hljs-built_in">this</span>.children = children;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        return &quot;-&quot;+data+&quot;:&quot;+area+children;</span><br><br><span class="hljs-comment">//        return &quot;\n-&quot;+data+&quot;:&quot;+area+children;</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;-&quot;</span>+data+<span class="hljs-string">&quot;:&quot;</span>+area;<br>        <span class="hljs-keyword">if</span>(children!=<span class="hljs-literal">null</span>)&#123;<br>            result = result + <span class="hljs-string">&quot;\n   &quot;</span>+children.toString();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200820202923154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;       今天我下班的时候接到了昨晚阿里巴巴面试我的技术面试官的电话，他问我昨晚的编程题是提交了全部的代码吗，我那时候正在地铁刚下班也有点迷糊，而且我想着昨晚的题也基本完成了90%应该没问题，于是我就说了：”应该是的“，然后说了一些昨晚没全部完成的理由。后面我们的通话就</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="原创" scheme="http://example.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper集群与Leader选举</title>
    <link href="http://example.com/2020/08/18/Zookeeper%E9%9B%86%E7%BE%A4%E4%B8%8ELeader%E9%80%89%E4%B8%BE/"/>
    <id>http://example.com/2020/08/18/Zookeeper%E9%9B%86%E7%BE%A4%E4%B8%8ELeader%E9%80%89%E4%B8%BE/</id>
    <published>2020-08-18T07:40:33.000Z</published>
    <updated>2024-01-07T10:21:16.602Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper是一个开源分布式协调服务、分布式数据一致性解决方案。可基于ZooKeeper实现命名服务、集群管理、Master选举、分布式锁等功能。</p><p><strong>高可用</strong></p><p>为了保证ZooKeeper的可用性，在生产环境中我们使用ZooKeeper集群模式对外提供服务，并且集群规模至少由3个ZooKeeper节点组成。</p><p>集群至少由3个节点组成</p><p>ZooKeeper其实2个节点也可以组成集群并对外提供服务，但我们使用集群主要目的是为了高可用。如果2个节点组成集群，其中1个节点挂了，另外ZooKeeper节点不能正常对外提供服务。因此也失去了集群的意义。</p><p>如果3个节点组成集群，其中1个节点挂掉后，根据ZooKeeper的Leader选举机制是可以从另外2个节点选出一个作为Leader的，集群可以继续对外提供服务。</p><p>并非节点越多越好</p><ul><li>节点越多，使用的资源越多</li><li>节点越多，ZooKeeper节点间花费的通讯成本越高，节点间互连的Socket也越多。影响ZooKeeper集群事务处理</li><li>节点越多，造成脑裂的可能性越大</li></ul><p>集群规模为奇数</p><p>集群规模除了考虑自身成本和资源外还要结合ZooKeeper特性考虑：</p><ul><li>节省资源<br>3节点集群和4节点集群，我们选择使用3节点集群；5节点集群和6节点集群，我们选择使用5节点集群。以此类推。因为生产环境为了保证高可用，3节点集群最多只允许挂1台，4节点集群最多也只允许挂1台(过半原则中解释了原因)。同理5节点集群最多允许挂2台，6节点集群最多也只允许挂2台。<br>出于对资源节省的考虑，我们应该使用奇数节点来满足相同的高可用性。</li><li>集群可用性<br>当集群中节点间网络通讯出现问题时奇数和偶数对集群的影响</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi1iYmYyNGY3ZTA1N2FlZWUyOWRkMDY4MjE4ZGUyY2U5OF83MjB3LmpwZw?x-oss-process=image/format,png"></p><p>集群配置</p><p>ZooKeeper集群配置至少需要2处变更：</p><p><strong>1、增加集群配置</strong></p><p>在{ZK_HOME}&#x2F;conf&#x2F;zoo.cfg中增加集群的配置，结构以server.id&#x3D;ip:port1:port2为标准。</p><p>比如下面配置文件中表示由3个ZooKeeper组成的集群：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br></code></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi03NDhlM2NlMTU2NzZlZGU1MzM2ODE2MmVkYzMyYmJiMF83MjB3LnBuZw?x-oss-process=image/format,png"></p><p><strong>2、配置节点id</strong></p><p>zoo.cfg中配置集群时需要指定server.id，这个id需要在dataDir（zoo.cfg中配置）指定的目录中创建myid文件，文件内容就是当前ZooKeeper节点的id。</p><p><strong>集群角色</strong></p><p>ZooKeeper没有使用Master&#x2F;Slave的概念，而是将集群中的节点分为了3类角色：</p><ul><li><p>Leader</p><p>在一个ZooKeeper集群中，只能存在一个Leader，这个Leader是集群中事务请求唯一的调度者和处理者，所谓事务请求是指会改变集群状态的请求；Leader根据事务ID可以保证事务处理的顺序性。<br>如果一个集群中存在多个Leader，这种现象称为「脑裂」。试想一下，一个集群中存在多个Leader会产生什么影响？<br>相当于原本一个大集群，裂出多个小集群，他们之间的数据是不会相互同步的。「脑裂」后集群中的数据会变得非常混乱。</p></li><li><p>Follower<br>Follower角色的ZooKeeper服务只能处理非事务请求；如果接收到客户端事务请求会将请求转发给Leader服务器；参与Leader选举；参与Leader事务处理投票处理。<br>Follower发现集群中Leader不可用时会变更自身状态，并发起Leader选举投票，最终集群中的某个Follower会被选为Leader。</p></li><li><p>Observer<br>Observer与Follower很像，可以处理非事务请求；将事务请求转发给Leader服务器。<br>与Follower不同的是，Observer不会参与Leader选举；不会参与Leader事务处理投票。<br>Observer用于不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p></li></ul><p><strong>Leader选举</strong></p><p>Leader在集群中是非常重要的一个角色，负责了整个事务的处理和调度，保证分布式数据一致性的关键所在。既然Leader在ZooKeeper集群中这么重要所以一定要保证集群在任何时候都有且仅有一个Leader存在。</p><p>如果集群中Leader不可用了，需要有一个机制来保证能从集群中找出一个最优的服务晋升为Leader继续处理事务和调度等一系列职责。这个过程称为Leader选举。</p><p>选举机制</p><p>ZooKeeper选举Leader依赖下列原则并遵循优先顺序：</p><p><strong>1、选举投票必须在同一轮次中进行</strong></p><p>如果Follower服务选举轮次不同，不会采纳投票。</p><p><strong>2、数据最新的节点优先成为Leader</strong></p><p>数据的新旧使用事务ID判定，事务ID越大认为节点数据约接近Leader的数据，自然应该成为Leader。</p><p><strong>3、比较server.id，id值大的优先成为Leader</strong></p><p>如果每个参与竞选节点事务ID一样，再使用server.id做比较。server.id是节点在集群中唯一的id，myid文件中配置。</p><p>不管是在集群启动时选举Leader还是集群运行中重新选举Leader。集群中每个Follower角色服务都是以上面的条件作为基础推选出合适的Leader，一旦出现某个节点被过半推选，那么该节点晋升为Leader。</p><p>过半原则</p><p>ZooKeeper集群会有很多类型投票。Leader选举投票；事务提议投票；这些投票依赖过半原则。就是说ZooKeeper认为投票结果超过了集群总数的一半，便可以安全的处理后续事务。</p><ul><li><strong>事务提议投票</strong><br>假设有3个节点组成ZooKeeper集群，客户端请求添加一个节点。Leader接到该事务请求后给所有Follower发起「创建节点」的提议投票。如果Leader收到了超过集群一半数量的反馈，继续给所有Follower发起commit。此时Leader认为集群过半了，就算自己挂了集群也是安全可靠的。</li><li><strong>Leader选举投票</strong><br>假设有3个节点组成ZooKeeper集群，这时Leader挂了，需要投票选举Leader。当相同投票结果过半后Leader选出。</li><li><strong>集群可用节点</strong><br>ZooKeeper集群中每个节点有自己的角色，对于集群可用性来说必须满足过半原则。这个过半是指Leader角色 + Follower角色可用数大于集群中Leader角色 + Follower角色总数。<br>假设有5个节点组成ZooKeeper集群，一个Leader、两个Follower、两个Observer。当挂掉两个Follower或挂掉一个Leader和一个Follower时集群将不可用。因为Observer角色不参与任何形式的投票。</li></ul><p>所谓过半原则算法是说票数 &gt; 集群总节点数&#x2F;2。其中集群总节点数&#x2F;2的计算结果会向下取整。</p><p>在ZooKeeper源代码QuorumMaj.java中实现了这个算法。下面代码片段有所缩减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs auto">public boolean containsQuorum(HashSet&lt;Long&gt; set) &#123;<br>  /** n是指集群总数 */<br>  int half = n / 2;<br>  return (set.size() &gt; half);<br>&#125;<br></code></pre></td></tr></table></figure><p>回过头我们看一下奇数和偶数集群在Leader选举的结果</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi03OWExZTRmYzU1OTdmODg3ZGMwNGZlNWJlNDljNWUxMV83MjB3LnBuZw?x-oss-process=image/format,png"></p><p>所以3节点和4节点组成的集群在ZooKeeper过半原则下都最多只能挂1节点，但是4比3要多浪费一个节点资源。</p><p><strong>场景实战</strong></p><p>我们以两个场景来了解集群不可用时Leader重新选举的过程。</p><p>3节点集群重选Leader</p><p>假设有3节点组成的集群，分别是server.1（Follower）、server.2（Leader）、server.3（Follower）。此时server.2不可用了。集群会产生以下变化：</p><p><strong>1、集群不可用</strong></p><p>因为Leader挂了，集群不可用于事务请求了。</p><p><strong>2、状态变更</strong></p><p>所有Follower节点变更自身状态为LOOKING，并且变更自身投票。投票内容就是自己节点的事务ID和server.id。我们以(事务ID, server.id)表示。</p><p>假设server.1的事务id是10，变更的自身投票就是（10, 1）；server.3的事务id是8，变更的自身投票就是（8, 3）。</p><p><strong>3、首轮投票</strong></p><p>将变更的投票发给集群中所有的Follower节点。server.1将（10, 1）发给集群中所有Follower，包括它自己。server.3也一样，将（8, 3）发给所有Follower。</p><p>所以server.1将收到（10, 1）和（8, 3）两个投票，server.3将收到（8, 3）和（10, 1）两个投票。</p><p><strong>4、投票PK</strong></p><p>每个Follower节点除了发起投票外，还接其他Follower发来的投票，并与自己的投票PK(比较两个提议的事务ID以及server.id)，PK结果决定是否要变更自身状态并再次投票。</p><p>对于server.1来说收到（10, 1）和（8, 3）两个投票，与自己变更的投票比较后没有一个比自身投票（10, 1）要大的，所以server.1维持自身投票不变。</p><p>对于server.3来说收到（10, 1）和（8, 3）两个投票，与自身变更的投票比较后认为server.1发来的投票要比自身的投票大，所以server.3会变更自身投票并将变更后的投票发给集群中所有Follower。</p><p><strong>5、第二轮投票</strong></p><p>server.3将自身投票变更为（10, 1）后再次将投票发给集群中所有Follower。</p><p>对于server.1来说在第二轮收到了（10, 1）投票，server.1经过PK后继续维持不变。</p><p>对于server.3来说在第二轮收到了（10, 1）投票，因为server.3自身已变更为（10,1）投票，所以本次也维持不变。</p><p>此时server.1和server.3在投票上达成一致。</p><p><strong>6、投票接收桶</strong></p><p>节点接收的投票存储在一个接收桶里，每个Follower的投票结果在桶内只记录一次。ZooKeeper源码中接收桶用Map实现。</p><p>下面代码片段是ZooKeeper定义的接收桶，以及向桶内写入数据。Map.Key是Long类型，用来存储投票来源节点的server.id，Vote则是对应节点的投票信息。节点收到投票后会更新这个接收桶，也就是说桶里存储了所有Follower节点的投票并且仅存最后一次的投票结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs auto">HashMap&lt;Long, Vote&gt; recvset = new HashMap&lt;Long, Vote&gt;();<br>recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));<br></code></pre></td></tr></table></figure><p><strong>7、统计投票</strong></p><p>接收到投票后每次都会尝试统计投票，投票统计过半后选举成功。</p><p>投票统计的数据来源于投票接收桶里的投票数据，我们从头描述这个场景，来看一下接收桶里的数据变化情况。</p><p>server.2挂了后，server.1和server.3发起第一轮投票。</p><p>server.1接收到来自server.1的（10, 1）投票和来自server.3的（8, 3）投票。</p><p>server.3同样接收到来自server.1的（10, 1）投票和来自server.3的（8, 3）投票。此时server.1和server.3接收桶里的数据是这样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0yZjJjYzIzMDJiNDgxNzc2OTJhYzM1MGQ3YzFiNmMwMV83MjB3LmpwZw?x-oss-process=image/format,png"></p><p>server.3经过PK后认为server.1的选票比自己要大，所以变更了自己的投票并重新发起投票。</p><p>server.1收到了来自server.3的（10, 1）投票;server.3收到了来自sever.3的（10, 1）投票。此时server.1和server.3接收桶里的数据变成了这样：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0xNDVkNTlhMjcxZDliYTkxMGIwMWM1ZDg4ZDYxZDg0ZV83MjB3LmpwZw?x-oss-process=image/format,png"></p><p>基于ZooKeeper过半原则：桶内投票选举server.1作为Leader出现2次，满足了过半 2 &gt; 3&#x2F;2 即 2&gt;1。</p><p>最后sever.1节点晋升为Leader，server.3变更为Follower。</p><h4 id="集群扩容Leader启动时机"><a href="#集群扩容Leader启动时机" class="headerlink" title="集群扩容Leader启动时机"></a><strong>集群扩容Leader启动时机</strong></h4><p>ZooKeeper集群扩容需要在zoo.cfg配置文件中加入新节点。扩容流程在ZooKeeper扩容中介绍。这里我们以3节点扩容到5节点时，Leader启动时机做一个讨论。</p><p>假设目前有3个节点组成集群，分别是server.1（Follower）、server.2（Leader）、server.3（Follower），假设集群中节点事务ID相同。配置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br></code></pre></td></tr></table></figure><p><strong>1、新节点加入集群</strong></p><p>集群中新增server.4和server.5两个节点，首先修改server.4和server.5的zoo.cfg配置并启动。节点4和5在启动后会变更自身投票状态，发起一轮Leader选举投票。server.1、server.2、server.3收到投票后由于集群中已有选定Leader，所以会直接反馈server.4和server.5投票结果：server.2是Leader。server.4和server.5收到投票后基于过半原则认定server.2是Leader，自身便切换为Follower。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs auto">#节点server.1、server.2、server.3配置<br>server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br><br>#节点server.4、server.5配置<br>server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br>server.4=localhost:2884:3884<br>server.5=localhost:2885:3885<br></code></pre></td></tr></table></figure><p><strong>2、停止Leader</strong></p><p>server.4和server.5的加入需要修改集群server.1、server.2、server.3的zoo.cfg配置并重启。但是Leader节点何时重启是有讲究的，因为Leader重启会导致集群中Follower发起Leader重新选举。在server.4和server.5两个新节点正常加入后，集群不会因为新节点加入变更Leader，所以目前server.2依然是Leader。</p><p>我们以一个错误的顺序启动，看一下集群会发生什么样的变化。修改server.2zoo.cfg配置文件，增加server.4和server.5的配置并停止server.2服务。停止server.2后，Leader不存在了，集群中所有Follower会发起投票。当server.1和server.3发起投票时并不会将投票发给server.4和server.5，因为在server.1和server.3的集群配置中不包含server.4和server.5节点。相反，server.4和server.5会把选票发给集群中所有节点。也就是说对于server.1和server.3他们认为集群中只有3个节点。对于server.4和server.5他们认为集群中有5个节点。</p><p>根据过半原则，server.1和server.3很快会选出一个新Leader，我们这里假设server.3晋级成为了新Leader。但是我们没有启动server.2的情况下，因为投票不满足过半原则，server.4和server.5会一直做投票选举Leader的动作。截止到现在集群中节点状态是这样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1jN2E5N2M0OThlMTEwOGEyOTFjY2FjNmI2NmNmYWQ2N183MjB3LnBuZw?x-oss-process=image/format,png"></p><p><strong>3、启动Leader</strong></p><p>现在，我们启动server.2。因为server.2zoo.cfg已经是server.1到serverv.5的全量配置，在server.2启动后会发起选举投票，同时serverv.4和serverv.5也在不断的发起选举投票。当server.2的选举轮次和serverv.4与serverv.5选举轮次对齐后，最终server.2会变更自己的状态，认定server.5是Leaader。</p><p>意想不到的事情发生了，出现两个Leader：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0yM2NhMTJmNDk4YzMyYjI3MGYwN2Y2N2Q3NjVkNjkwMl83MjB3LnBuZw?x-oss-process=image/format,png"></p><p>ZooKeeper集群扩容时，如果Leader节点最后启动就可以避免这类问题发生，因为在Leader节点重启前，所有的Follower节点zoo.cfg配置已经是相同的，他们基于同一个集群配置两两互联，做投票选举。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ZooKeeper是一个开源分布式协调服务、分布式数据一致性解决方案。可基于ZooKeeper实现命名服务、集群管理、Master选举、分布式锁等功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高可用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了保证ZooKeeper的可用性，在生产环境中我</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>CP和AP有是什么？有什么区别？</title>
    <link href="http://example.com/2020/08/18/CP%E5%92%8CAP%E6%9C%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2020/08/18/CP%E5%92%8CAP%E6%9C%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2020-08-18T07:31:32.000Z</published>
    <updated>2024-01-07T10:21:33.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CP和AP有是什么？有什么区别？"><a href="#CP和AP有是什么？有什么区别？" class="headerlink" title="CP和AP有是什么？有什么区别？"></a>CP和AP有是什么？有什么区别？</h2><p>最新推荐文章于 2024-01-06 16:53:14 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-06 16:53:14 发布</p><p>最近有时间研究分布式架构，因为公司使用的Zookeeper，并没有使用Spring Cloud Eureka，所以想探究一下他们之间的区别，于是看到简书里的文章：<a href="https://www.jianshu.com/p/e47c027a9aeb">Spring Cloud Eureka简介及与Zookeeper对比</a>，明显的区别可能就是Zookeeper为CP设计，而Eureka为AP设计，但是对CAP&#x2F;AP&#x2F;CP很不理解，于是查阅资料，做一个简单的了解。</p><blockquote><p>Eureka服务治理机制与Dubbo服务治理机制的比较</p><table><thead><tr><th>Feature</th><th>Eureka</th><th>Zookeeper</th></tr></thead><tbody><tr><td>服务健康检查</td><td>可配支持</td><td>(弱)长连接，keepalive</td></tr><tr><td>CAP</td><td>AP</td><td>CP</td></tr><tr><td>watch支持（客户端观察到服务提供者变化）</td><td>支持 long polling&#x2F;大部分增量</td><td>支持</td></tr><tr><td>自我保护</td><td>支持</td><td>-</td></tr><tr><td>客户端缓存</td><td>支持</td><td>-</td></tr><tr><td>自身集群的监控</td><td>metrics</td><td>-</td></tr></tbody></table><p>Eureka支持健康检查，自我保护等</p><p>Zookeeper为CP设计，Eureka为AP设计。作为服务发现产品，可用性优先级较高，一致性的特点并不重要，宁可返回错误的数据，也比不反回结果要好得多。</p><p>服务列表变更Zookeeper服务端会有通知，Eureka则通过长轮询来实现，Eureka未来会实现watch机制</p></blockquote><p>CAP理论提出就是针对分布式数据库环境的，所以，P这个属性是必须具备的。<br>P就是在分布式环境中，由于网络的问题可能导致某个节点和其它节点失去联系，这时候就形成了P(partition)，也就是由于网络问题，将系统的成员隔离成了2个区域，互相无法知道对方的状态，这在分布式环境下是非常常见的。<br>因为P是必须的，那么我们需要选择的就是A和C。<br>大家知道，在分布式环境下，为了保证系统可用性，通常都采取了复制的方式，避免一个节点损坏，导致系统不可用。那么就出现了每个节点上的数据出现了很多个副本的情况，而数据从一个节点复制到另外的节点时需要时间和要求网络畅通的，所以，当P发生时，也就是无法向某个节点复制数据时，这时候你有两个选择：<br>选择可用性 A(Availability)，此时，那个失去联系的节点依然可以向系统提供服务，不过它的数据就不能保证是同步的了（失去了C属性）。<br>选择一致性C(Consistency)，为了保证数据库的一致性，我们必须等待失去联系的节点恢复过来，在这个过程中，那个节点是不允许对外提供服务的，这时候系统处于不可用状态(失去了A属性)。</p><p>最常见的例子是读写分离，某个节点负责写入数据，然后将数据同步到其它节点，其它节点提供读取的服务，当两个节点出现通信问题时，你就面临着选择A（继续提供服务，但是数据不保证准确），C（用户处于等待状态，一直等到数据同步完成）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CP和AP有是什么？有什么区别？&quot;&gt;&lt;a href=&quot;#CP和AP有是什么？有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;CP和AP有是什么？有什么区别？&quot;&gt;&lt;/a&gt;CP和AP有是什么？有什么区别？&lt;/h2&gt;&lt;p&gt;最新推荐文章于 2024-0</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix熔断机制原理剖析</title>
    <link href="http://example.com/2020/08/14/Hystrix%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>http://example.com/2020/08/14/Hystrix%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</id>
    <published>2020-08-14T06:10:27.000Z</published>
    <updated>2024-01-07T10:21:30.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hystrix熔断机制原理剖析"><a href="#Hystrix熔断机制原理剖析" class="headerlink" title="Hystrix熔断机制原理剖析"></a>Hystrix熔断机制原理剖析</h2><p>最新推荐文章于 2024-01-02 12:13:54 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2024-01-02 12:13:54 发布</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在分布式系统架构中多个系统之间通常是通过远程RPC调用进行通信，也就是 A 系统调用 B 系统服务，B 系统调用 C 系统的服务。当尾部应用 C 发生故障而系统 B 没有服务降级时候可能会导致 B，甚至系统 A 瘫痪，这种现象被称为雪崩现象。所以在系统设计时候要使用一定的降级策略，来保证当服务提供方服务不可用时候，服务调用方可以切换到降级后的策略进行执行。</p><h2 id="二、Hystrix-中基于自反馈调节熔断状态的算法原理"><a href="#二、Hystrix-中基于自反馈调节熔断状态的算法原理" class="headerlink" title="二、Hystrix 中基于自反馈调节熔断状态的算法原理"></a>二、Hystrix 中基于自反馈调节熔断状态的算法原理</h2><p>我们可以把熔断器想象为一个保险丝，在电路系统中，一般在所有的家电系统连接外部供电的线路中间都会加一个保险丝，当外部电压过高，达到保险丝的熔点时候，保险丝就会被熔断，从而可以切断家电系统与外部电路的联通，进而保障家电系统不会因为电压过高而损坏。</p><p>Hystrix提供的熔断器就有类似功能，当在一定时间段内服务调用方调用服务提供方的服务的次数达到设定的阈值，并且出错的次数也达到设置的出错阈值，就会进行服务降级，让服务调用方之间执行本地设置的降级策略，而不再发起远程调用。但是Hystrix提供的熔断器具有自我反馈，自我恢复的功能，Hystrix会根据调用接口的情况，让熔断器在closed,open,half-open三种状态之间自动切换。</p><p>open状态说明打开熔断，也就是服务调用方执行本地降级策略，不进行远程调用。<br>closed状态说明关闭了熔断，这时候服务调用方直接发起远程调用。<br>half-open状态，则是一个中间状态，当熔断器处于这种状态时候，直接发起远程调用。</p><p>三种状态的转换：</p><ul><li><p>closed-&gt;open:正常情况下熔断器为closed状态，当访问同一个接口次数超过设定阈值并且错误比例超过设置错误阈值时候，就会打开熔断机制，这时候熔断器状态从closed-&gt;open。</p></li><li><p>open-&gt;half-open:当服务接口对应的熔断器状态为open状态时候，所有服务调用方调用该服务方法时候都是执行本地降级方法，那么什么时候才会恢复到远程调用那？Hystrix提供了一种测试策略，也就是设置了一个时间窗口，从熔断器状态变为open状态开始的一个时间窗口内，调用该服务接口时候都委托服务降级方法进行执行。如果时间超过了时间窗口，则把熔断状态从open-&gt;half-open,这时候服务调用方调用服务接口时候，就可以发起远程调用而不再使用本地降级接口，如果发起远程调用还是失败，则重新设置熔断器状态为open状态，从新记录时间窗口开始时间。</p></li><li><p>half-open-&gt;closed: 当熔断器状态为half-open,这时候服务调用方调用服务接口时候，就可以发起远程调用而不再使用本地降级接口，如果发起远程调用成功，则重新设置熔断器状态为closed状态。</p></li></ul><p>那么有一个问题，用来判断熔断器从closed-&gt;open转换的数据是哪里来的那？其实这个是HystrixCommandMetrics对象来做的，该对象用来存在HystrixCommand的一些指标数据，比如接口调用次数，调用接口失败的次数等等，后面我们会讲解。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>系统设计时候要使用一定的降级策略，来保证当服务提供方服务不可用时候，服务调用方可以切换到降级后的策略进行执行，Hystrix作为熔断器组件使用范围还是很广泛的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hystrix熔断机制原理剖析&quot;&gt;&lt;a href=&quot;#Hystrix熔断机制原理剖析&quot; class=&quot;headerlink&quot; title=&quot;Hystrix熔断机制原理剖析&quot;&gt;&lt;/a&gt;Hystrix熔断机制原理剖析&lt;/h2&gt;&lt;p&gt;最新推荐文章于 2024-01-02</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>谈谈服务限流算法的几种实现</title>
    <link href="http://example.com/2020/08/13/%E8%B0%88%E8%B0%88%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2020/08/13/%E8%B0%88%E8%B0%88%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-08-13T09:53:40.000Z</published>
    <updated>2024-01-07T14:12:39.708Z</updated>
    
    <content type="html"><![CDATA[<p>保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。今天和大家谈谈限流算法的几种实现方式，本文所说的限流并非是Nginx层面的限流，而是业务代码中的逻辑限流。</p><h4 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h4><p>按照服务的调用方，可以分为以下几种类型服务</p><p>1、与用户打交道的服务</p><p>比如web服务、对外API，这种类型的服务有以下几种可能导致机器被拖垮：</p><ul><li><p>用户增长过快（这是好事）</p></li><li><p>因为某个热点事件（微博热搜）</p></li><li><p>竞争对象爬虫</p></li><li><p>恶意的刷单</p></li></ul><p>这些情况都是无法预知的，不知道什么时候会有10倍甚至20倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的（弹性扩容都是虚谈，一秒钟你给我扩一下试试）</p><p>2、对内的RPC服务</p><p>一个服务A的接口可能被BCDE多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对CDE也无法提供服务。 这种情况时有发生，解决方案有两种： 1、每个调用方采用线程池进行资源隔离 2、使用限流手段对每个调用方进行限流</p><h4 id="限流算法实现"><a href="#限流算法实现" class="headerlink" title="限流算法实现"></a>限流算法实现</h4><p>常见的限流算法有：计数器、令牌桶、漏桶。</p><p>1、计数器算法</p><p>采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。</p><p>具体的实现可以是这样的：对于每次服务调用，可以通过 <code>AtomicLong#incrementAndGet()</code>方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。</p><p>这种实现方式，相信大家都知道有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”</p><p>2、漏桶算法</p><p>为了消除”突刺现象”，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。</p><p>不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p><p><img src="https://img-blog.csdn.net/20180722161419529?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。</p><p>这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p><p>3、令牌桶算法</p><p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。</p><p>在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p><p>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p><p><img src="https://img-blog.csdn.net/20180722161357369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。</p><p>幸运的是，通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>18.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过RateLimiter类的create方法，创建限流器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterMain</span> &#123;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>       <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">10</span>);<br> <br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br> <br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br> <br>               <span class="hljs-meta">@Override</span><br> <br>               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <br>                   rateLimiter.acquire()<br> <br>                   System.out.println(<span class="hljs-string">&quot;pass&quot;</span>);<br> <br>               &#125;<br> <br>           &#125;).start();<br> <br>       &#125;<br> <br>   &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>其实Guava提供了多种create方法，方便创建适合各种需求的限流器。在上述例子中，创建了一个每秒生成10个令牌的限流器，即100ms生成一个，并最多保存10个令牌，多余的会被丢弃。</p><p>rateLimiter提供了acquire()和tryAcquire()接口 1、使用acquire()方法，如果没有可用令牌，会一直阻塞直到有足够的令牌。 2、使用tryAcquire()方法，如果没有可用令牌，就直接返回false。 3、使用tryAcquire()带超时时间的方法，如果没有可用令牌，就会判断在超时时间内是否可以等到令牌，如果不能，就返回false，如果可以，就阻塞等待。</p><p>集群限流</p><p>前面讨论的几种算法都属于单机限流的范畴，但是业务需求五花八门，简单的单机限流，根本无法满足他们。</p><p>比如为了限制某个资源被每个用户或者商户的访问次数，5s只能访问2次，或者一天只能调用1000次，这种需求，单机限流是无法实现的，这时就需要通过集群限流进行实现。</p><p><strong>如何实现？</strong>为了控制访问次数，肯定需要一个计数器，而且这个计数器只能保存在第三方服务，比如redis。</p><p>大概思路：每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问&#x2F;index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。今天和大家谈谈限流算法的几种实现方式，本文所说的限流并非是Nginx层面的限流，而是业务代码中的逻辑限流。&lt;/p&gt;
&lt;h4 id=&quot;为什么需要限流&quot;&gt;&lt;a href=&quot;#为什么需要限流&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>常用4种限流算法介绍及比较</title>
    <link href="http://example.com/2020/08/13/%E5%B8%B8%E7%94%A84%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2020/08/13/%E5%B8%B8%E7%94%A84%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%AF%94%E8%BE%83/</id>
    <published>2020-08-13T09:46:18.000Z</published>
    <updated>2024-01-07T10:21:08.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用4种限流算法介绍及比较"><a href="#常用4种限流算法介绍及比较" class="headerlink" title="常用4种限流算法介绍及比较"></a>常用4种限流算法介绍及比较</h2><p>最新推荐文章于 2023-03-30 00:22:18 发布</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/weixin_37760377" title="Wayyyyyyyy">Wayyyyyyyy</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"> 最新推荐文章于 2023-03-30 00:22:18 发布</p><p><strong>1****、计数器（固定窗口）算法</strong><br>计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。</p><p>此算法在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性和线程安全即可轻松实现。</p><p><img src="https://img-blog.csdnimg.cn/20190716091143141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p>这个算法通常用于QPS限流和统计总访问量，对于秒级以上的时间周期来说，会存在一个非常严重的问题，那就是临界问题，如下图：<br><img src="https://img-blog.csdnimg.cn/20190716091413825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p>假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端。</p><p><strong>2****、滑动窗口算法</strong><br>滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。</p><p>如下图，假设时间周期为1min，将1min再分为2个小周期，统计每个小周期的访问数量，则可以看到，第一个时间周期内，访问数量为75，第二个时间周期内，访问数量为100，超过100的访问则被限流掉了   </p><p><img src="https://img-blog.csdnimg.cn/20190716091612718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p>由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p>此算法可以很好的解决固定窗口算法的临界问题。</p><p><strong>3****、漏桶算法</strong></p><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。</p><p><img src="https://img-blog.csdnimg.cn/20190716090944456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p><strong>4****、令牌桶算法</strong><br>令牌桶算法是程序以r（r&#x3D;时间周期&#x2F;限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略</p><p><img src="https://img-blog.csdnimg.cn/20190716090944463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70"></p><p><strong>各个算法比较</strong></p><table><tbody><tr><td><p>算法</p></td><td><p>确定参数</p></td><td><p>空间复杂度</p></td><td><p>时间复杂度</p></td><td><p>限制突发流量</p></td><td><p>平滑限流</p></td><td><p>分布式环境下实现难度</p></td></tr><tr><td><p>固定窗口</p></td><td><p>计数周期T、</p><p>周期内最大访问数N</p></td><td><p>低O(1)</p><p>（记录周期内访问次数及周期开始时间）</p></td><td><p>低O(1)</p></td><td><p>否</p></td><td><p>否</p></td><td><p>低</p></td></tr><tr><td><p>滑动窗口</p></td><td><p>计数周期T、</p><p>周期内最大访问数N</p></td><td><p>高O(N)</p><p>（记录每个小周期中的访问数量）</p></td><td><p>中O(N)</p></td><td><p>是</p></td><td><p>相对实现。滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑</p></td><td><p>中</p></td></tr><tr><td><p>漏桶</p></td><td><p>漏桶流出速度r、漏桶容量N</p></td><td><p>低O(1)</p><p>（记录当前漏桶中容量）</p></td><td><p>高O(N)</p></td><td><p>是</p></td><td><p>是</p></td><td><p>高</p></td></tr><tr><td><p>令牌桶</p></td><td><p>令牌产生速度r、令牌桶容量N</p></td><td><p>低O(1)</p><p>（记录当前令牌桶中令牌数）</p></td><td><p>高O(N)</p></td><td><p>是</p></td><td><p>是</p></td><td><p>高</p></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用4种限流算法介绍及比较&quot;&gt;&lt;a href=&quot;#常用4种限流算法介绍及比较&quot; class=&quot;headerlink&quot; title=&quot;常用4种限流算法介绍及比较&quot;&gt;&lt;/a&gt;常用4种限流算法介绍及比较&lt;/h2&gt;&lt;p&gt;最新推荐文章于 2023-03-30 00:22:1</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="http://example.com/2020/08/13/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/08/13/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-13T09:42:02.000Z</published>
    <updated>2024-01-07T14:12:21.281Z</updated>
    
    <content type="html"><![CDATA[<p>保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。今天和大家谈谈限流算法的几种实现方式，本文所说的限流并非是Nginx层面的限流，而是业务代码中的逻辑限流。</p><h4 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h4><p>按照服务的调用方，可以分为以下几种类型服务</p><p>1、与用户打交道的服务</p><p>比如web服务、对外API，这种类型的服务有以下几种可能导致机器被拖垮：</p><ul><li><p>用户增长过快（这是好事）</p></li><li><p>因为某个热点事件（微博热搜）</p></li><li><p>竞争对象爬虫</p></li><li><p>恶意的刷单</p></li></ul><p>这些情况都是无法预知的，不知道什么时候会有10倍甚至20倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的（弹性扩容都是虚谈，一秒钟你给我扩一下试试）</p><p>2、对内的RPC服务</p><p>一个服务A的接口可能被BCDE多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对CDE也无法提供服务。 这种情况时有发生，解决方案有两种： 1、每个调用方采用线程池进行资源隔离 2、使用限流手段对每个调用方进行限流</p><h4 id="限流算法实现"><a href="#限流算法实现" class="headerlink" title="限流算法实现"></a>限流算法实现</h4><p>常见的限流算法有：计数器、令牌桶、漏桶。</p><p>1、计数器算法</p><p>采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。</p><p>具体的实现可以是这样的：对于每次服务调用，可以通过 <code>AtomicLong#incrementAndGet()</code>方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。</p><p>这种实现方式，相信大家都知道有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”</p><p>2、漏桶算法</p><p>为了消除”突刺现象”，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。</p><p>不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p><p><img src="https://img-blog.csdn.net/20180722161419529?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。</p><p>这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p><p>3、令牌桶算法</p><p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。</p><p>在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p><p>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p><p><img src="https://img-blog.csdn.net/20180722161357369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmh1aTI1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。</p><p>幸运的是，通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>18.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">通过RateLimiter类的create方法，创建限流器。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterMain</span> &#123;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>       <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">10</span>);<br> <br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br> <br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br> <br>               <span class="hljs-meta">@Override</span><br> <br>               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <br>                   rateLimiter.acquire()<br> <br>                   System.out.println(<span class="hljs-string">&quot;pass&quot;</span>);<br> <br>               &#125;<br> <br>           &#125;).start();<br> <br>       &#125;<br> <br>   &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>其实Guava提供了多种create方法，方便创建适合各种需求的限流器。在上述例子中，创建了一个每秒生成10个令牌的限流器，即100ms生成一个，并最多保存10个令牌，多余的会被丢弃。</p><p>rateLimiter提供了acquire()和tryAcquire()接口 1、使用acquire()方法，如果没有可用令牌，会一直阻塞直到有足够的令牌。 2、使用tryAcquire()方法，如果没有可用令牌，就直接返回false。 3、使用tryAcquire()带超时时间的方法，如果没有可用令牌，就会判断在超时时间内是否可以等到令牌，如果不能，就返回false，如果可以，就阻塞等待。</p><p>集群限流</p><p>前面讨论的几种算法都属于单机限流的范畴，但是业务需求五花八门，简单的单机限流，根本无法满足他们。</p><p>比如为了限制某个资源被每个用户或者商户的访问次数，5s只能访问2次，或者一天只能调用1000次，这种需求，单机限流是无法实现的，这时就需要通过集群限流进行实现。</p><p><strong>如何实现？</strong>为了控制访问次数，肯定需要一个计数器，而且这个计数器只能保存在第三方服务，比如redis。</p><p>大概思路：每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问&#x2F;index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。今天和大家谈谈限流算法的几种实现方式，本文所说的限流并非是Nginx层面的限流，而是业务代码中的逻辑限流。&lt;/p&gt;
&lt;h4 id=&quot;为什么需要限流&quot;&gt;&lt;a href=&quot;#为什么需要限流&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>代理模式中静态代理、jdk动态代理、cglib动态代理有什么不同？</title>
    <link href="http://example.com/2020/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <id>http://example.com/2020/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</id>
    <published>2020-08-12T03:37:25.000Z</published>
    <updated>2024-01-07T14:15:49.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h3><p>首先，写一个要实现的目标的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:42:20</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TargetInterface</span> &#123;<br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再写一个目标实现类，也就是需要被代理（增强）的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:43:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TargetInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name;<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是代理类的编写，<strong>此处的核心是把被代理类进行注入并调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:44:47</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TargetInterface</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TargetInterface targetInterface;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(TargetInterface targetInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.targetInterface = targetInterface;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理前做点东西&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> targetInterface.sayHello(name);<br>        System.out.println(<span class="hljs-string">&quot;代理后做点东西&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:41:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TargetInterface</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br>        <span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target);<br>        proxy.sayHello(<span class="hljs-string">&quot;way&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重"><a href="#静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重" class="headerlink" title="静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重"></a><strong>静态代理容易实现，容易理解，但是缺点就是每需要增强一个类就需要一个代理类，修改增加方法，代理类也需要改变，耦合严重</strong></h4><h3 id="2-Jdk动态代理"><a href="#2-Jdk动态代理" class="headerlink" title="2.Jdk动态代理"></a><strong>2.Jdk动态代理</strong></h3><h4 id="静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现"><a href="#静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现" class="headerlink" title="静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现"></a><strong>静态代理是编译时便进行了代理，而动态代理则是通过动态修改字节码，并载入JVM来实现</strong></h4><p>Proxy和Target、TargetInterface可以共用上面的代码，我就不重复了</p><p>Jdk动态代理主要就是用了Java 反射包下的Proxy.newInstance这个方法，而这个方法里的参数又需要一个InvocationHandler的实现类，所以首先实现InvocationHandler接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 10:10:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理前做点东西&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;代理后做点东西&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:53:07</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TargetInterface</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">dynamicProxyInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>(target);<br>        <span class="hljs-type">TargetInterface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), dynamicProxyInvocationHandler);<br>        System.out.println(proxy.getClass().getName());<br>        proxy.sayHello(<span class="hljs-string">&quot;way&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）-为什么呢？通过上面的输出可以看到-com-sun-proxy-Proxy0-，proxy是一个代理对象，通过反编译源码可以得知-Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。"><a href="#Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）-为什么呢？通过上面的输出可以看到-com-sun-proxy-Proxy0-，proxy是一个代理对象，通过反编译源码可以得知-Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。" class="headerlink" title="Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）,为什么呢？通过上面的输出可以看到 com.sun.proxy.$Proxy0 ，proxy是一个代理对象，通过反编译源码可以得知$Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。"></a><strong>Jdk代理需要被代理类（也就是Target）实现接口（也就是TargetInterface）,为什么呢？通过上面的输出可以看到 com.sun.proxy.$Proxy0 ，proxy是一个代理对象，通过反编译源码可以得知$Proxy0类继承了Proxy类，那么由于单继承的缘故，proxy要建立与代理类的关系的话那么只能通过接口了。</strong>而这也是Jdk动态代理的一个缺点，因为有时被代理类并非全都有实现接口。</h4><h3 id="3-Cglib动态代理"><a href="#3-Cglib动态代理" class="headerlink" title="3.Cglib动态代理"></a><strong>3.Cglib动态代理</strong></h3><p>首先，引入相关依赖：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这次，为了对比，我们建一个没有实现接口的被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 09:43:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetNoInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name;<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是类似Jdk动态代理的实现相关api：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 10:38:32</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object target, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理前做点东西&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(target, args);<br>        System.out.println(<span class="hljs-string">&quot;代理后做点东西&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是去使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wayleung</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-08-12 10:37:19</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibDynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setClassLoader(TargetNoInterface.class.getClassLoader());<br>        enhancer.setSuperclass(TargetNoInterface.class);<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMethodInterceptor</span>());<br>        <span class="hljs-type">TargetNoInterface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (TargetNoInterface) enhancer.create();<br>        System.out.println(proxy.getClass().getName());<br>        proxy.sayHello(<span class="hljs-string">&quot;way&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib-动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为-final-类型的类和方法，假如被代理类是final类，那么运行时报错："><a href="#通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib-动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为-final-类型的类和方法，假如被代理类是final类，那么运行时报错：" class="headerlink" title="通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib 动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法，假如被代理类是final类，那么运行时报错："></a>通过这个可见，CGlib动态代理不需要被代理类实现接口，值得注意的是，CGlib 动态代理是通过生成一个被代理类的子类（继承）来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法，假如被代理类是final类，那么运行时报错：</h4><p><img src="https://img-blog.csdnimg.cn/202008121134593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p><h4 id="假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）："><a href="#假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）：" class="headerlink" title="假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）："></a>假如被代理方法是final方法，那么能运行，但是方法没有被代理（没有被增强）：</h4><p><img src="https://img-blog.csdnimg.cn/20200812113649327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2MDM3Nw==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-静态代理&quot;&gt;&lt;a href=&quot;#1-静态代理&quot; class=&quot;headerlink&quot; title=&quot;1.静态代理&quot;&gt;&lt;/a&gt;1.静态代理&lt;/h3&gt;&lt;p&gt;首先，写一个要实现的目标的接口：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="原创" scheme="http://example.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS详解</title>
    <link href="http://example.com/2020/07/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2020/07/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-07-29T07:15:08.000Z</published>
    <updated>2024-01-07T14:16:06.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java并发之AQS详解"><a href="#Java并发之AQS详解" class="headerlink" title="Java并发之AQS详解"></a><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></h2><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>　　谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！</p><p>　　类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…。</p><p>　　以下是本文的目录大纲：</p><ol><li><ol><li>概述</li><li>框架</li><li>源码详解</li><li>简单应用</li></ol></li></ol><p>　　若有不正之处，请谅解和批评指正，不胜感激。</p><p>　　请尊重作者劳动成果，转载请标明原文链接（原文持续更新，建议阅读原文）：<a href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p><h2 id="二、框架"><a href="#二、框架" class="headerlink" title="二、框架"></a>二、框架</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTcwNS83MjEwNzAtMjAxNzA1MDQxMTAyNDYyMTEtMTA2ODQ0ODUucG5n?x-oss-process=image/format,png"></p><p>　　它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p>　　AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p><p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="三、源码详解"><a href="#三、源码详解" class="headerlink" title="三、源码详解"></a>三、源码详解</h2><p>　　本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。</p><h3 id="3-0-结点状态waitStatus"><a href="#3-0-结点状态waitStatus" class="headerlink" title="3.0 结点状态waitStatus"></a>3.0 结点状态waitStatus</h3><p>      这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p><ul><li><p><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</p></li><li><p><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</p></li><li><p><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</p></li><li><p><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</p></li><li><p><strong>0</strong>：新结点入队时的默认状态。</p></li></ul><p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p><h3 id="3-1-acquire-int"><a href="#3-1-acquire-int" class="headerlink" title="3.1 acquire(int)"></a>3.1 acquire(int)</h3><p>　　此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p><p>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }</p><p>　　函数流程如下：</p><ol><li><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol></li></ol><p>　　这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。就像《大话西游》里唐僧说的：等你明白了舍生取义的道理，你自然会回来和我唱这首歌的。</p><h4 id="3-1-1-tryAcquire-int"><a href="#3-1-1-tryAcquire-int" class="headerlink" title="3.1.1 tryAcquire(int)"></a>3.1.1 tryAcquire(int)</h4><p>　　此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p><p>1     protected boolean tryAcquire(int arg) {<br>2         throw new UnsupportedOperationException();<br>3     }</p><p>　　什么？直接throw异常？说好的功能呢？好吧，<strong>还记得概述里讲的AQS只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现吗？</strong>就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get&#x2F;set&#x2F;CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><p>　　这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</p><h4 id="3-1-2-addWaiter-Node"><a href="#3-1-2-addWaiter-Node" class="headerlink" title="3.1.2 addWaiter(Node)"></a>3.1.2 addWaiter(Node)</h4><p>　　此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private Node addWaiter(Node mode) {<br> 2     &#x2F;&#x2F;以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）<br> 3     Node node &#x3D; new Node(Thread.currentThread(), mode);<br> 4<br> 5     &#x2F;&#x2F;尝试快速方式直接放到队尾。<br> 6     Node pred &#x3D; tail;<br> 7     if (pred !&#x3D; null) {<br> 8         node.prev &#x3D; pred;<br> 9         if (compareAndSetTail(pred, node)) {<br>10             pred.next &#x3D; node;<br>11             return node;<br>12         }<br>13     }<br>14<br>15     &#x2F;&#x2F;上一步失败则通过enq入队。<br>16     enq(node);<br>17     return node;<br>18 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 不用再说了，直接看注释吧。</p><p>3.1.2.1 enq(Node)</p><p> 　　此方法用于将node加入队尾。源码如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private Node enq(final Node node) {<br> 2     &#x2F;&#x2F;CAS”自旋”，直到成功加入队尾<br> 3     for (;;) {<br> 4         Node t &#x3D; tail;<br> 5         if (t &#x3D;&#x3D; null) { &#x2F;&#x2F; 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。<br> 6             if (compareAndSetHead(new Node()))<br> 7                 tail &#x3D; head;<br> 8         } else {&#x2F;&#x2F;正常流程，放入队尾<br> 9             node.prev &#x3D; t;<br>10             if (compareAndSetTail(t, node)) {<br>11                 t.next &#x3D; node;<br>12                 return t;<br>13             }<br>14         }<br>15     }<br>16 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。<strong>CAS自旋volatile变量</strong>，是一种很经典的用法。还不太了解的，自己去百度一下吧。</p><h4 id="3-1-3-acquireQueued-Node-int"><a href="#3-1-3-acquireQueued-Node-int" class="headerlink" title="3.1.3 acquireQueued(Node, int)"></a>3.1.3 acquireQueued(Node, int)</h4><p>　　OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。这个函数非常关键，还是上源码吧：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 final boolean acquireQueued(final Node node, int arg) {<br> 2     boolean failed &#x3D; true;&#x2F;&#x2F;标记是否成功拿到资源<br> 3     try {<br> 4         boolean interrupted &#x3D; false;&#x2F;&#x2F;标记等待过程中是否被中断过<br> 5<br> 6         &#x2F;&#x2F;又是一个“自旋”！<br> 7         for (;;) {<br> 8             final Node p &#x3D; node.predecessor();&#x2F;&#x2F;拿到前驱<br> 9             &#x2F;&#x2F;如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。<br>10             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) {<br>11                 setHead(node);&#x2F;&#x2F;拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。<br>12                 p.next &#x3D; null; &#x2F;&#x2F; setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！<br>13                 failed &#x3D; false; &#x2F;&#x2F; 成功获取资源<br>14                 return interrupted;&#x2F;&#x2F;返回等待过程中是否被中断过<br>15             }<br>16<br>17             &#x2F;&#x2F;如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。<br>18             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>19                 parkAndCheckInterrupt())<br>20                 interrupted &#x3D; true;&#x2F;&#x2F;如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true<br>21         }<br>22     } finally {<br>23         if (failed) &#x2F;&#x2F; 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。<br>24             cancelAcquire(node);<br>25     }<br>26 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</p><p>3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)</p><p>　　此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html">Thread详解</a>），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br> 2     int ws &#x3D; pred.waitStatus;&#x2F;&#x2F;拿到前驱的状态<br> 3     if (ws &#x3D;&#x3D; Node.SIGNAL)<br> 4         &#x2F;&#x2F;如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了<br> 5         return true;<br> 6     if (ws &gt; 0) {<br> 7         &#x2F;*<br> 8          * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。<br> 9          * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！<br>10          *&#x2F;<br>11         do {<br>12             node.prev &#x3D; pred &#x3D; pred.prev;<br>13         } while (pred.waitStatus &gt; 0);<br>14         pred.next &#x3D; node;<br>15     } else {<br>16          &#x2F;&#x2F;如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！<br>17         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>18     }<br>19     return false;<br>20 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><p>3.1.3.2 parkAndCheckInterrupt()</p><p>　　如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p><p>1 private final boolean parkAndCheckInterrupt() {<br>2     LockSupport.park(this);&#x2F;&#x2F;调用park()使线程进入waiting状态<br>3     return Thread.interrupted();&#x2F;&#x2F;如果被唤醒，查看自己是不是被中断的。<br>4 }</p><p> 　　park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html">Thread详解</a>）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p><p>3.1.3.3 小结</p><p>　　OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</p><ol><li>结点进入队尾后，检查状态，找到安全休息点；</li><li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li><li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li></ol><h4 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h4><p>　　OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</p><p>1 public final void acquire(int arg) {<br>2     if (!tryAcquire(arg) &amp;&amp;<br>3         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>4         selfInterrupt();<br>5 }</p><p>再来总结下它的流程吧：</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p>由于此函数是重中之重，我再用流程图总结一下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzIxMDcwLzIwMTUxMS83MjEwNzAtMjAxNTExMDIxNDU3NDM0NjEtNjIzNzk0MzI2LnBuZw?x-oss-process=image/format,png"></p><p>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</p><h3 id="3-2-release-int"><a href="#3-2-release-int" class="headerlink" title="3.2 release(int)"></a>3.2 release(int)</h3><p> 　　上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>1 public final boolean release(int arg) {<br>2     if (tryRelease(arg)) {<br>3         Node h &#x3D; head;&#x2F;&#x2F;找到头结点<br>4         if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)<br>5             unparkSuccessor(h);&#x2F;&#x2F;唤醒等待队列里的下一个线程<br>6         return true;<br>7     }<br>8     return false;<br>9 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，<strong>它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</strong></p><h4 id="3-2-1-tryRelease-int"><a href="#3-2-1-tryRelease-int" class="headerlink" title="3.2.1 tryRelease(int)"></a>3.2.1 tryRelease(int)</h4><p>　　此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p><p>1 protected boolean tryRelease(int arg) {<br>2     throw new UnsupportedOperationException();<br>3 }</p><p>　　跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-&#x3D;arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state&#x3D;0)，要返回true，否则返回false。</p><h4 id="3-2-2-unparkSuccessor-Node"><a href="#3-2-2-unparkSuccessor-Node" class="headerlink" title="3.2.2 unparkSuccessor(Node)"></a>3.2.2 unparkSuccessor(Node)</h4><p>　　此方法用于唤醒等待队列中下一个线程。下面是源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void unparkSuccessor(Node node) {<br> 2     &#x2F;&#x2F;这里，node一般为当前线程所在的结点。<br> 3     int ws &#x3D; node.waitStatus;<br> 4     if (ws &lt; 0)&#x2F;&#x2F;置零当前线程所在的结点状态，允许失败。<br> 5         compareAndSetWaitStatus(node, ws, 0);<br> 6<br> 7     Node s &#x3D; node.next;&#x2F;&#x2F;找到下一个需要唤醒的结点s<br> 8     if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) {&#x2F;&#x2F;如果为空或已取消<br> 9         s &#x3D; null;<br>10         for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev) &#x2F;&#x2F; 从后向前找。<br>11             if (t.waitStatus &lt;&#x3D; 0)&#x2F;&#x2F;从这里可以看出，&lt;&#x3D;0的结点，都是还有效的结点。<br>12                 s &#x3D; t;<br>13     }<br>14     if (s !&#x3D; null)<br>15         LockSupport.unpark(s.thread);&#x2F;&#x2F;唤醒<br>16 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　这个函数并不复杂。一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg))的判断（即使p!&#x3D;head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p&#x3D;&#x3D;head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p><h4 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h4><p>　　release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源。</p><p>      74楼的朋友提了一个非常有趣的问题：如果获取锁的线程在release时异常了，没有unpark队列中的其他结点，这时队列中的其他结点会怎么办？是不是没法再被唤醒了？</p><p>      答案是<strong>YES</strong>（测试程序详见76楼）！！！这时，队列中等待锁的线程将永远处于park状态，无法再被唤醒！！！但是我们再回头想想，获取锁的线程在什么情形下会release抛出异常呢？？</p><ol><li>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</li><li>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</li><li>release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。<strong>除非自己写的tryRelease()有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了</strong>。</li></ol><h3 id="3-3-acquireShared-int"><a href="#3-3-acquireShared-int" class="headerlink" title="3.3 acquireShared(int)"></a>3.3 acquireShared(int)</h3><p>　　此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p><p>1 public final void acquireShared(int arg) {<br>2     if (tryAcquireShared(arg) &lt; 0)<br>3         doAcquireShared(arg);<br>4 }</p><p>　　这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><ol><li><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol></li></ol><h4 id="3-3-1-doAcquireShared-int"><a href="#3-3-1-doAcquireShared-int" class="headerlink" title="3.3.1 doAcquireShared(int)"></a>3.3.1 doAcquireShared(int)</h4><p>　　此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void doAcquireShared(int arg) {<br> 2     final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;加入队列尾部<br> 3     boolean failed &#x3D; true;&#x2F;&#x2F;是否成功标志<br> 4     try {<br> 5         boolean interrupted &#x3D; false;&#x2F;&#x2F;等待过程中是否被中断过的标志<br> 6         for (;;) {<br> 7             final Node p &#x3D; node.predecessor();&#x2F;&#x2F;前驱<br> 8             if (p &#x3D;&#x3D; head) {&#x2F;&#x2F;如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的<br> 9                 int r &#x3D; tryAcquireShared(arg);&#x2F;&#x2F;尝试获取资源<br>10                 if (r &gt;&#x3D; 0) {&#x2F;&#x2F;成功<br>11                     setHeadAndPropagate(node, r);&#x2F;&#x2F;将head指向自己，还有剩余资源可以再唤醒之后的线程<br>12                     p.next &#x3D; null; &#x2F;&#x2F; help GC<br>13                     if (interrupted)&#x2F;&#x2F;如果等待过程中被打断过，此时将中断补上。<br>14                         selfInterrupt();<br>15                     failed &#x3D; false;<br>16                     return;<br>17                 }<br>18             }<br>19<br>20             &#x2F;&#x2F;判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()<br>21             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>22                 parkAndCheckInterrupt())<br>23                 interrupted &#x3D; true;<br>24         }<br>25     } finally {<br>26         if (failed)<br>27             cancelAcquire(node);<br>28     }<br>29 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</p><p>　　跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p><p>3.3.1.1 setHeadAndPropagate(Node, int)</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void setHeadAndPropagate(Node node, int propagate) {<br> 2     Node h &#x3D; head;<br> 3     setHead(node);&#x2F;&#x2F;head指向自己<br> 4      &#x2F;&#x2F;如果还有剩余量，继续唤醒下一个邻居线程<br> 5     if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0) {<br> 6         Node s &#x3D; node.next;<br> 7         if (s &#x3D;&#x3D; null || s.isShared())<br> 8             doReleaseShared();<br> 9     }<br>10 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p><p>　　doReleaseShared()我们留着下一小节的releaseShared()里来讲。</p><h4 id="3-3-2-小结"><a href="#3-3-2-小结" class="headerlink" title="3.3.2 小结"></a>3.3.2 小结</h4><p>　　OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</p><ol><li><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()&#x2F;interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol></li></ol><p>　　其实跟acquire()的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p><h3 id="3-4-releaseShared"><a href="#3-4-releaseShared" class="headerlink" title="3.4 releaseShared()"></a>3.4 releaseShared()</h3><p>　　上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>1 public final boolean releaseShared(int arg) {<br>2     if (tryReleaseShared(arg)) {&#x2F;&#x2F;尝试释放资源<br>3         doReleaseShared();&#x2F;&#x2F;唤醒后继结点<br>4         return true;<br>5     }<br>6     return false;<br>7 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state&#x3D;0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state&#x3D;0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h4 id="3-4-1-doReleaseShared"><a href="#3-4-1-doReleaseShared" class="headerlink" title="3.4.1 doReleaseShared()"></a>3.4.1 doReleaseShared()</h4><p>　　此方法主要用于唤醒后继。下面是它的源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 private void doReleaseShared() {<br> 2     for (;;) {<br> 3         Node h &#x3D; head;<br> 4         if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) {<br> 5             int ws &#x3D; h.waitStatus;<br> 6             if (ws &#x3D;&#x3D; Node.SIGNAL) {<br> 7                 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br> 8                     continue;<br> 9                 unparkSuccessor(h);&#x2F;&#x2F;唤醒后继<br>10             }<br>11             else if (ws &#x3D;&#x3D; 0 &amp;&amp;<br>12                      !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))<br>13                 continue;<br>14         }<br>15         if (h &#x3D;&#x3D; head)&#x2F;&#x2F; head发生变化<br>16             break;<br>17     }<br>18 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>　　本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()&#x2F;acquireSharedInterruptibly()即是，相应的源码跟acquire()和acquireShared()差不多，这里就不再详解了。</p><h2 id="四、简单应用"><a href="#四、简单应用" class="headerlink" title="四、简单应用"></a>四、简单应用</h2><p>　　通过前边几个章节的学习，相信大家已经基本理解AQS的原理了。这里再将“框架”一节中的一段话复制过来：</p><p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>　　OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。</p><h3 id="4-1-Mutex（互斥锁）"><a href="#4-1-Mutex（互斥锁）" class="headerlink" title="4.1 Mutex（互斥锁）"></a>4.1 Mutex（互斥锁）</h3><p>　　Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p> 1 class Mutex implements Lock, java.io.Serializable {<br> 2     &#x2F;&#x2F; 自定义同步器<br> 3     private static class Sync extends AbstractQueuedSynchronizer {<br> 4         &#x2F;&#x2F; 判断是否锁定状态<br> 5         protected boolean isHeldExclusively() {<br> 6             return getState() &#x3D;&#x3D; 1;<br> 7         }<br> 8<br> 9         &#x2F;&#x2F; 尝试获取资源，立即返回。成功则返回true，否则false。<br>10         public boolean tryAcquire(int acquires) {<br>11             assert acquires &#x3D;&#x3D; 1; &#x2F;&#x2F; 这里限定只能为1个量<br>12             if (compareAndSetState(0, 1)) {&#x2F;&#x2F;state为0才设置为1，不可重入！<br>13                 setExclusiveOwnerThread(Thread.currentThread());&#x2F;&#x2F;设置为当前线程独占资源<br>14                 return true;<br>15             }<br>16             return false;<br>17         }<br>18<br>19         &#x2F;&#x2F; 尝试释放资源，立即返回。成功则为true，否则false。<br>20         protected boolean tryRelease(int releases) {<br>21             assert releases &#x3D;&#x3D; 1; &#x2F;&#x2F; 限定为1个量<br>22             if (getState() &#x3D;&#x3D; 0)&#x2F;&#x2F;既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！<br>23                 throw new IllegalMonitorStateException();<br>24             setExclusiveOwnerThread(null);<br>25             setState(0);&#x2F;&#x2F;释放资源，放弃占有状态<br>26             return true;<br>27         }<br>28     }<br>29<br>30     &#x2F;&#x2F; 真正同步类的实现都依赖继承于AQS的自定义同步器！<br>31     private final Sync sync &#x3D; new Sync();<br>32<br>33     &#x2F;&#x2F;lock&lt;–&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。<br>34     public void lock() {<br>35         sync.acquire(1);<br>36     }<br>37<br>38     &#x2F;&#x2F;tryLock&lt;–&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。<br>39     public boolean tryLock() {<br>40         return sync.tryAcquire(1);<br>41     }<br>42<br>43     &#x2F;&#x2F;unlock&lt;–&gt;release。两者语文一样：释放资源。<br>44     public void unlock() {<br>45         sync.release(1);<br>46     }<br>47<br>48     &#x2F;&#x2F;锁是否占有状态<br>49     public boolean isLocked() {<br>50         return sync.isHeldExclusively();<br>51     }<br>52 }</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jb21tb24uY25ibG9ncy5jb20vaW1hZ2VzL2NvcHljb2RlLmdpZg" alt="复制代码"></p><p>　　同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</p><p>　　除了Mutex，ReentrantLock&#x2F;CountDownLatch&#x2F;Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</p><p>　　OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</p><ul><li>作者：<a href="http://www.cnblogs.com/waterystone">水岩</a></li><li>出处：<a href="http://www.cnblogs.com/waterystone">http://www.cnblogs.com/waterystone</a></li><li>本博客中未标明转载的文章归作者<a href="http://www.cnblogs.com/waterystone/">水岩</a>和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java并发之AQS详解&quot;&gt;&lt;a href=&quot;#Java并发之AQS详解&quot; class=&quot;headerlink&quot; title=&quot;Java并发之AQS详解&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/waterystone/p/492</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>看完这篇ThreadLocal的详解，你也能用得这么溜</title>
    <link href="http://example.com/2020/07/29/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87ThreadLocal%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%83%BD%E7%94%A8%E5%BE%97%E8%BF%99%E4%B9%88%E6%BA%9C/"/>
    <id>http://example.com/2020/07/29/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87ThreadLocal%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%83%BD%E7%94%A8%E5%BE%97%E8%BF%99%E4%B9%88%E6%BA%9C/</id>
    <published>2020-07-29T02:51:37.000Z</published>
    <updated>2024-01-07T14:15:10.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>张三最近天气很热心情不是很好，所以他决定出去面试跟面试官聊聊天排解一下，结果刚投递简历就有人约了面试。</p><p>我丢，什么情况怎么刚投递出去就有人约我面试了？诶。。。真烦啊，哥已经不在江湖这么久了，江湖还是有哥的传说，我还是这么抢手的么？太烦恼了，帅无罪。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRoc2pyOXI0ajMwNzMwNzNhYTEuanBn?x-oss-process=image/format,png"></p><p>暗自窃喜的张三来到了某东现场面试的办公室，我丢，这面试官？不是吧，这满是划痕的Mac，这发量，难道就是传说中的架构师？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRodXl1bWRhajMwZ28wOGMzeXkuanBn?x-oss-process=image/format,png"></p><p>张三的心态一下子就崩了，出来第一场面试就遇到一个顶级面试官，这谁顶得住啊。</p><p>你好，我是你的面试官Tony，看我的发型应该你能猜到我的身份了，我也话不说，我们直接开始好不好？看你简历写了多线程，来你跟我聊一下ThreadLocal吧，我很久没写代码不太熟悉了，你帮我回忆一下。</p><p>我丢？这TM是人话？这是什么逻辑啊，说是问多线程然后一上来就来个这么冷门的ThreadLocal？心态崩了呀，再说你TM自己忘了不知道下去看看书么，来我这里找答案是什么鬼啊…</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRodnF3M3A5ajMwOGMwOGNteWYuanBn?x-oss-process=image/format,png"></p><p>尽管十分不情愿，但是张三还是高速运转他的小脑袋，回忆起了ThreadLocal的种种细节…</p><p>面试官说实话我在实际开发过程中用到ThreadLocal的地方不是很多，我在写这个文章的时候还刻意去把我电脑上几十个项目打开之后去全局搜索ThreadLocal发现除了系统源码的使用，很少在项目中用到，不过也还是有的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRjc3FkZDcyajMweDIwYWxhYmsuanBn?x-oss-process=image/format,png"></p><p>ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，如何防止自己的变量被其它线程篡改。</p><h4 id="你能跟我说说它隔离有什么用，会用在什么场景么？"><a href="#你能跟我说说它隔离有什么用，会用在什么场景么？" class="headerlink" title="你能跟我说说它隔离有什么用，会用在什么场景么？"></a>你能跟我说说它隔离有什么用，会用在什么场景么？</h4><p>这，我都说了我很少用了，还问我，难受了呀，哦哦哦，有了想起来了，事务隔离级别。</p><p>面试官你好，其实我第一时间想到的就是Spring实现事务隔离级别的源码，这还是当时我大学被女朋友甩了，一个人在图书馆哭泣的时候无意间发现的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRoeTByZXh6ajMwNHgwNTN0OWUuanBn?x-oss-process=image/format,png"></p><p>Spring采用Threadlocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。</p><p>Spring框架里面就是用的ThreadLocal来实现这种隔离，主要是在<code>TransactionSynchronizationManager</code>这个类里面，代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">private static final Log logger = LogFactory.getLog(TransactionSynchronizationManager.class);<br><br>private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =<br>new NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;);<br><br>private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =<br>new NamedThreadLocal&lt;&gt;(&quot;Transaction synchronizations&quot;);<br><br>private static final ThreadLocal&lt;String&gt; currentTransactionName =<br>new NamedThreadLocal&lt;&gt;(&quot;Current transaction name&quot;);<br><br>  ……<br></code></pre></td></tr></table></figure><p>Spring的事务主要是ThreadLocal和AOP去做实现的，我这里提一下，大家知道每个线程自己的链接是靠ThreadLocal保存的就好了，继续的细节我会在Spring章节细说的，暖么？</p><p>除了源码里面使用到ThreadLocal的场景，你自己有使用他的场景么？一般你会怎么用呢？</p><p>来了来了，加分项来了，这个我还真遇到过，装B的机会终于来了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRoenV3cW96ajMwODcwNjRxMnguanBn?x-oss-process=image/format,png"></p><p>有的有的面试官，这个我会！！！</p><p>之前我们上线后发现部分用户的日期居然不对了，排查下来是<code>SimpleDataFormat</code>的锅，当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()，如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。</p><p>其实要解决这个问题很简单，让每个线程都new 一个自己的 <code>SimpleDataFormat</code>就好了，但是1000个线程难道new1000个<code>SimpleDataFormat</code>？</p><p>所以当时我们使用了线程池加上ThreadLocal包装<code>SimpleDataFormat</code>，再调用initialValue让每个线程有一个<code>SimpleDataFormat</code>的副本，从而解决了线程安全的问题，也提高了性能。</p><h4 id="那……"><a href="#那……" class="headerlink" title="那……"></a>那……</h4><p>还有还有，我还有，您别着急问下一个，让我再加点分，拖延一下面试时间。</p><p>我在项目中存在一个线程经常遇到横跨若干方法调用，需要传递的对象，也就是上下文（Context），它是一种状态，经常就是是用户身份、任务信息等，就会存在过渡传参的问题。</p><p>使用到类似责任链模式，给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，对象参数就传不进去了，所以我使用到了ThreadLocal去做了一下改造，这样只需要在调用前在ThreadLocal中设置参数，其他地方get一下就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs auto">before<br>  <br>void work(User user) &#123;<br>    getInfo(user);<br>    checkInfo(user);<br>    setSomeThing(user);<br>    log(user);<br>&#125;<br><br>then<br>  <br>void work(User user) &#123;<br>try&#123;<br>  threadLocalUser.set(user);<br>  // 他们内部  User u = threadLocalUser.get(); 就好了<br>    getInfo();<br>    checkInfo();<br>    setSomeThing();<br>    log();<br>    &#125; finally &#123;<br>     threadLocalUser.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我看了一下很多场景的cookie，session等数据隔离都是通过ThreadLocal去做实现的。</li></ul><p>对了我面试官允许我再秀一下知识广度，在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();<br>private static void prepare(boolean quitAllowed) &#123;<br>    if (sThreadLocal.get() != null) &#123;<br>        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);<br>    &#125;<br>    sThreadLocal.set(new Looper(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>面试官：我丢，这货怎么知道这么多场景？还把Android都扯了出来，不是吧阿sir，下面我要考考他原理了。</p><p>嗯嗯，你回答得很好，那你能跟我说说他底层实现的原理么？</p><p>好的面试官，我先说一下他的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadLocal&lt;String&gt; localName = new ThreadLocal();<br>localName.set(&quot;张三&quot;);<br>String name = localName.get();<br>localName.remove();<br></code></pre></td></tr></table></figure><p>其实使用真的很简单，线程进来之后初始化一个可以泛型的ThreadLocal对象，之后这个线程只要在remove之前去get，都能拿到之前set的值，注意这里我说的是remove之前。</p><p>他是能做到线程间数据隔离的，所以别的线程使用get（）方法是没办法拿到其他线程的值的，但是有办法可以做到，我后面会说。</p><p>我们先看看他set的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs auto">public void set(T value) &#123;<br>    Thread t = Thread.currentThread();// 获取当前线程<br>    ThreadLocalMap map = getMap(t);// 获取ThreadLocalMap对象<br>    if (map != null) // 校验对象是否为空<br>        map.set(this, value); // 不为空set<br>    else<br>        createMap(t, value); // 为空创建一个map对象<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可以发现set的源码很简单，主要就是ThreadLocalMap我们需要关注一下，而ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadLocalMap getMap(Thread t) &#123;<br>        return t.threadLocals;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class Thread implements Runnable &#123;<br>      ……<br><br>    /* ThreadLocal values pertaining to this thread. This map is maintained<br>     * by the ThreadLocal class. */<br>    ThreadLocal.ThreadLocalMap threadLocals = null;<br><br>    /*<br>     * InheritableThreadLocal values pertaining to this thread. This map is<br>     * maintained by the InheritableThreadLocal class.<br>     */<br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;<br>  <br>     ……<br></code></pre></td></tr></table></figure><p>这里我们基本上可以找到ThreadLocal数据隔离的真相了，每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。</p><h4 id="ThreadLocalMap底层结构是怎么样子的呢？"><a href="#ThreadLocalMap底层结构是怎么样子的呢？" class="headerlink" title="ThreadLocalMap底层结构是怎么样子的呢？"></a>ThreadLocalMap底层结构是怎么样子的呢？</h4><p>面试官这个问题问得好啊，内心暗骂，让我歇一会不行么？</p><p>张三笑着回答道，既然有个Map那他的数据结构其实是很像HashMap的，但是看源码可以发现，它并未实现Map接口，而且他的Entry是继承WeakReference（弱引用）的，也没有看到HashMap中的next，所以不存在链表了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">static class ThreadLocalMap &#123;<br><br>        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            /** The value associated with this ThreadLocal. */<br>            Object value;<br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                super(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>        ……<br>    &#125;    <br></code></pre></td></tr></table></figure><p>结构大概长这样：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRmeTZndncwajMwdzAwOTNqc3UuanBn?x-oss-process=image/format,png"></p><h4 id="稍等，我有两个疑问你可以解答一下么？"><a href="#稍等，我有两个疑问你可以解答一下么？" class="headerlink" title="稍等，我有两个疑问你可以解答一下么？"></a>稍等，我有两个疑问你可以解答一下么？</h4><p>好呀，面试官你说。</p><h4 id="为什么需要数组呢？没有了链表怎么解决Hash冲突呢？"><a href="#为什么需要数组呢？没有了链表怎么解决Hash冲突呢？" class="headerlink" title="为什么需要数组呢？没有了链表怎么解决Hash冲突呢？"></a>为什么需要数组呢？没有了链表怎么解决Hash冲突呢？</h4><p>用数组是因为，我们开发过程中可以一个线程可以有多个TreadLocal来存放不同类型的对象的，但是他们都将放到你当前线程的ThreadLocalMap里，所以肯定要数组来存。</p><p>至于Hash冲突，我们先看一下源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs auto">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;<br>           Entry[] tab = table;<br>            int len = tab.length;<br>            int i = key.threadLocalHashCode &amp; (len-1);<br>            for (Entry e = tab[i];<br>                 e != null;<br>                 e = tab[i = nextIndex(i, len)]) &#123;<br>                ThreadLocal&lt;?&gt; k = e.get();<br><br>                if (k == key) &#123;<br>                    e.value = value;<br>                    return;<br>                &#125;<br>                if (k == null) &#123;<br>                    replaceStaleEntry(key, value, i);<br>                    return;<br>                &#125;<br>            &#125;<br>            tab[i] = new Entry(key, value);<br>            int sz = ++size;<br>            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>                rehash();<br>        &#125;<br></code></pre></td></tr></table></figure><p>我从源码里面看到ThreadLocalMap在存储的时候会给每一个ThreadLocal对象一个threadLocalHashCode，在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，**int i &#x3D; key.threadLocalHashCode &amp; (len-1)**。</p><p>然后会判断一下：如果当前位置是空的，就初始化一个Entry对象放在位置i上；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">if (k == null) &#123;<br>    replaceStaleEntry(key, value, i);<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果位置i不为空，如果这个Entry对象的key正好是即将设置的key，那么就刷新Entry中的value；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs auto">if (k == key) &#123;<br>    e.value = value;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果位置i的不为空，而且key不等于entry，那就找下一个空位置，直到为空为止。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRpcGM4MGhmajMwdzEwaHVnbzUuanBn?x-oss-process=image/format,png"></p><p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置，set和get如果冲突严重的话，效率还是很低的。</p><p>以下是get的源码，是不是就感觉很好懂了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs auto"> private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;<br>            int i = key.threadLocalHashCode &amp; (table.length - 1);<br>            Entry e = table[i];<br>            if (e != null &amp;&amp; e.get() == key)<br>                return e;<br>            else<br>                return getEntryAfterMiss(key, i, e);<br>        &#125;<br><br> private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;<br>            Entry[] tab = table;<br>            int len = tab.length;<br>// get的时候一样是根据ThreadLocal获取到table的i值，然后查找数据拿到后会对比key是否相等  if (e != null &amp;&amp; e.get() == key)。<br>            while (e != null) &#123;<br>                ThreadLocal&lt;?&gt; k = e.get();<br>              // 相等就直接返回，不相等就继续查找，找到相等位置。<br>                if (k == key)<br>                    return e;<br>                if (k == null)<br>                    expungeStaleEntry(i);<br>                else<br>                    i = nextIndex(i, len);<br>                e = tab[i];<br>            &#125;<br>            return null;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="能跟我说一下对象存放在哪里么？"><a href="#能跟我说一下对象存放在哪里么？" class="headerlink" title="能跟我说一下对象存放在哪里么？"></a>能跟我说一下对象存放在哪里么？</h4><p>在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，而堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。</p><h4 id="那么是不是说ThreadLocal的实例以及其值存放在栈上呢？"><a href="#那么是不是说ThreadLocal的实例以及其值存放在栈上呢？" class="headerlink" title="那么是不是说ThreadLocal的实例以及其值存放在栈上呢？"></a>那么是不是说ThreadLocal的实例以及其值存放在栈上呢？</h4><p>其实不是的，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有），而ThreadLocal的值其实也是被线程实例持有，它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</p><h4 id="如果我想共享线程的ThreadLocal数据怎么办？"><a href="#如果我想共享线程的ThreadLocal数据怎么办？" class="headerlink" title="如果我想共享线程的ThreadLocal数据怎么办？"></a>如果我想共享线程的ThreadLocal数据怎么办？</h4><p>使用<code>InheritableThreadLocal</code>可以实现多个线程访问ThreadLocal的值，我们在主线程中创建一个<code>InheritableThreadLocal</code>的实例，然后在子线程中得到这个<code>InheritableThreadLocal</code>实例设置的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">private void test() &#123;    <br>final ThreadLocal threadLocal = new InheritableThreadLocal();       <br>threadLocal.set(&quot;帅得一匹&quot;);    <br>Thread t = new Thread() &#123;        <br>    @Override        <br>    public void run() &#123;            <br>      super.run();            <br>      Log.i( &quot;张三帅么 =&quot; + threadLocal.get());        <br>    &#125;    <br>  &#125;;          <br>  t.start(); <br>&#125; <br></code></pre></td></tr></table></figure><p>在子线程中我是能够正常输出那一行日志的，这也是我之前面试视频提到过的父子线程数据传递的问题。</p><h4 id="怎么传递的呀？"><a href="#怎么传递的呀？" class="headerlink" title="怎么传递的呀？"></a>怎么传递的呀？</h4><p>传递的逻辑很简单，我在开头Thread代码提到threadLocals的时候，你们再往下看看我刻意放了另外一个变量：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRncnE5YnhxajMwb28wYmNxNG4uanBn?x-oss-process=image/format,png"></p><p>Thread源码中，我们看看Thread.init初始化创建的时候做了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs auto">public class Thread implements Runnable &#123;<br>  ……<br>   if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)<br>      this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br>  ……<br>&#125;<br></code></pre></td></tr></table></figure><p>我就截取了部分代码，如果线程的<code>inheritThreadLocals</code>变量不为空，比如我们上面的例子，而且父线程的<code>inheritThreadLocals</code>也存在，那么我就把父线程的<code>inheritThreadLocals</code>给当前线程的<code>inheritThreadLocals</code>。</p><p>是不是很有意思？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRrcjV1NjQ5ajMwNHcwNThteGUuanBn?x-oss-process=image/format,png"></p><p>小伙子你懂的确实很多，那你算是一个深度的ThreadLocal用户了，你发现ThreadLocal的问题了么？</p><p>你是说内存泄露么？</p><p>我丢，这小子为啥知道我要问什么？嗯嗯对的，你说一下。</p><p>这个问题确实会存在的，我跟大家说一下为什么，还记得我上面的代码么？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRta3g4dXBqajMwanowNm03NHUuanBn?x-oss-process=image/format,png"></p><p>ThreadLocal在保存的时候会把自己当做Key存在ThreadLocalMap中，正常情况应该是key和value都应该被外界强引用才对，但是现在key被设计成WeakReference弱引用了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaDRuaDh2M2hhajMwdzEwYmJhYnIuanBn?x-oss-process=image/format,png"></p><p>我先给大家介绍一下弱引用：</p><blockquote><p>只具有弱引用的对象拥有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><p>不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote><p>这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p>就比如线程池里面的线程，线程都是复用的，那么之前的线程实例处理完之后，出于复用的目的线程依然存活，所以，ThreadLocal设定的value值被持有，导致内存泄露。</p><p>按照道理一个线程使用完，ThreadLocalMap是应该要被清空的，但是现在线程被复用了。</p><h4 id="那怎么解决？"><a href="#那怎么解决？" class="headerlink" title="那怎么解决？"></a>那怎么解决？</h4><p>在代码的最后使用remove就好了，我们只要记得在使用的最后用remove把值清空就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs auto">ThreadLocal&lt;String&gt; localName = new ThreadLocal();<br>try &#123;<br>    localName.set(&quot;张三&quot;);<br>    ……<br>&#125; finally &#123;<br>    localName.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>remove的源码很简单，找到对应的值全部置空，这样在垃圾回收器回收的时候，会自动把他们回收掉。</p><h4 id="那为什么ThreadLocalMap的key要设计成弱引用？"><a href="#那为什么ThreadLocalMap的key要设计成弱引用？" class="headerlink" title="那为什么ThreadLocalMap的key要设计成弱引用？"></a>那为什么ThreadLocalMap的key要设计成弱引用？</h4><p>key不设置成弱引用的话就会造成和entry中value一样内存泄漏的场景。</p><p>补充一点：ThreadLocal的不足，我觉得可以通过看看netty的fastThreadLocal来弥补，大家有兴趣可以康康。</p><p>好了，你不仅把我问的都回答了，我不知道的你甚至都说了，ThreadLocal你过关了，不过JUC的面试才刚刚开始，希望你以后越战越勇，最后拿个好offer哟。</p><p>什么鬼，突然这么煽情，不是很为难我的么?难道是为了锻炼我？难为大师这样为我着想，我还一直心里暗骂他，不说了回去好好学了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实ThreadLocal用法很简单，里面的方法就那几个，算上注释源码都没多少行，我用了十多分钟就过了一遍了，但是在我深挖每一个方法背后逻辑的时候，也让我不得不感慨Josh Bloch 和 Doug Lea的厉害之处。</p><p>在细节设计的处理其实往往就是我们和大神的区别，我认为很多不合理的点，在Google和自己不断深入了解之后才发现这才是合理，真的不服不行。</p><p>ThreadLocal是多线程里面比较冷门的一个类，使用频率比不上别的方法和类，但是通过我这篇文章，不知道你是否有新的认知呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;开场白&quot;&gt;&lt;a href=&quot;#开场白&quot; class=&quot;headerlink&quot; title=&quot;开场白&quot;&gt;&lt;/a&gt;开场白&lt;/h3&gt;&lt;p&gt;张三最近天气很热心情不是很好，所以他决定出去面试跟面试官聊聊天排解一下，结果刚投递简历就有人约了面试。&lt;/p&gt;
&lt;p&gt;我丢，什么情况</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>synchronized四种锁状态的升级</title>
    <link href="http://example.com/2020/07/10/synchronized%E5%9B%9B%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%87%E7%BA%A7/"/>
    <id>http://example.com/2020/07/10/synchronized%E5%9B%9B%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%87%E7%BA%A7/</id>
    <published>2020-07-10T03:23:26.000Z</published>
    <updated>2024-01-07T14:15:35.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>在 Java 语言中，使用 Synchronized 是能够实现线程同步的，即<strong>加锁</strong>。并且实现的是<strong>悲观锁</strong>，在操作同步资源的时候直接先加锁。</p><p>加锁可以使一段代码在同一时间只有一个线程可以访问，在增加安全性的同时，牺牲掉的是程序的执行性能，所以为了在一定程度上减少获得锁和释放锁带来的性能消耗，在 jdk6 之后便引入了“偏向锁”和“轻量级锁”，所以总共有4种锁状态，级别由低到高依次为：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>。这几个状态会随着竞争情况逐渐升级。</p><p>注意：锁可以升级但不能降级。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjUzODk1Mi04OTVmMDE1Yjc2YzJlNjA0LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93LzEwMjQvZm9ybWF0L3dlYnA?x-oss-process=image/format,png"></p><p>锁状态说明及升级图示</p><p>当然了，在谈这四种状态之前，我们还是有必要再简单了解下 synchronized 的原理。</p><p>在使用 synchronized 来同步代码块的时候，经编译后，会在代码块的起始位置插入 <strong>monitorenter指令</strong>，在结束或异常处插入 <strong>monitorexit指令。</strong>当执行到 monitorenter 指令时，将会尝试获取对象所对应的 **monitor **的所有权，即尝试获得对象的锁。而 synchronized 用的锁是存放在 <strong>Java对象头</strong> 中的。</p><p>所以引出了两个关键词：“Java 对象头” 和 “Monitor”。</p><h3 id="二、Java-对象头和-Monitor"><a href="#二、Java-对象头和-Monitor" class="headerlink" title="二、Java 对象头和 Monitor"></a>二、Java 对象头和 Monitor</h3><p>1、Java 对象头</p><p>我们以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>2、Monitor</p><p>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。</p><p>Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><h3 id="三、无锁"><a href="#三、无锁" class="headerlink" title="三、无锁"></a>三、无锁</h3><p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><h3 id="四、偏向锁"><a href="#四、偏向锁" class="headerlink" title="四、偏向锁"></a>四、偏向锁</h3><p>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p>关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p><p>偏向锁在 JDK 6 及之后版本的 JVM 里是默认启用的。可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false，关闭之后程序默认会进入轻量级锁状态。</p><h3 id="五、轻量级锁"><a href="#五、轻量级锁" class="headerlink" title="五、轻量级锁"></a>五、轻量级锁</h3><p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。</p><p>轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机将首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后将对象头中的 Mark Word 复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p><p>另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p><h3 id="六、重量级锁"><a href="#六、重量级锁" class="headerlink" title="六、重量级锁"></a>六、重量级锁</h3><p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</p><p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。</p><h3 id="七、关于自旋"><a href="#七、关于自旋" class="headerlink" title="七、关于自旋"></a>七、关于自旋</h3><p>关于自旋，简言之就是让线程喝杯咖啡小憩一下，用代码解释就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs auto">do  &#123;<br>    // do something<br>&#125;  while  (自旋的规则，或者说自旋的次数)<br></code></pre></td></tr></table></figure><p>引入自旋这一规则的原因其实也很简单，因为阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。并且在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，这部分操作的开销其实是得不偿失的。</p><p>所以，在物理机器有多个处理器的情况下，当两个或以上的线程同时并行执行时，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋。如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。</p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</p><p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用 -XX:PreBlockSpin 来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>偏向锁通过对比 Mark Word 解决加锁问题，避免执行CAS操作。</p><p>轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</p><p>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h3&gt;&lt;p&gt;在 Java 语言中，使用 Synchronized 是能够实现线程同步的，即&lt;strong&gt;加锁&lt;/strong&gt;。并且实</summary>
      
    
    
    
    <category term="所有文章" scheme="http://example.com/categories/%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
